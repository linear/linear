import { DocumentNode } from "graphql/language/ast";
import * as L from "./_generated_documents";

/** The function for calling the graphql client */
export type LinearRequest = <Response, Variables extends Record<string, unknown>>(
  doc: DocumentNode,
  variables?: Variables
) => Promise<Response>;

/**
 * Base class to provide a request function
 *
 * @param request - function to call the graphql client
 */
export class Request {
  protected _request: LinearRequest;

  public constructor(request: LinearRequest) {
    this._request = request;
  }

  /**
   * Helper to paginate over all pages of a given connection query.
   * @param fn The query to paginate
   * @param args The arguments to pass to the query
   */
  public async paginate<T extends Node, U>(fn: (variables: U) => LinearFetch<Connection<T>>, args: U): Promise<T[]> {
    const boundFn = fn.bind(this);
    let connection: Connection<T> = await boundFn(args);
    const nodes = connection.nodes;
    while (connection.pageInfo.hasNextPage) {
      connection = await boundFn({ first: 50, ...args, after: connection.pageInfo.endCursor });
      nodes.push(...connection.nodes);
    }
    return nodes;
  }
}

/** Fetch return type wrapped in a promise */
export type LinearFetch<Response> = Promise<Response>;

/**
 * Variables required for pagination
 * Follows the Relay spec
 */
export type LinearConnectionVariables = {
  after?: string | null;
  before?: string | null;
  first?: number | null;
  last?: number | null;
};

/**
 * Default connection variables required for pagination
 * Defaults to 50 as per the Linear API
 */
function defaultConnection<Variables extends LinearConnectionVariables>(variables: Variables): Variables {
  return {
    ...variables,
    first: variables.first ?? (variables.after ? 50 : undefined),
    last: variables.last ?? (variables.before ? 50 : undefined),
  };
}

/**
 * Connection models containing a list of nodes and pagination information
 * Follows the Relay spec
 */
export class LinearConnection<Node> extends Request {
  public pageInfo: PageInfo;
  public nodes: Node[];

  public constructor(request: LinearRequest) {
    super(request);
    this.pageInfo = new PageInfo(request, { hasNextPage: false, hasPreviousPage: false, __typename: "PageInfo" });
    this.nodes = [];
  }
}

/**
 * The base connection class to provide pagination
 * Follows the Relay spec
 *
 * @param request - function to call the graphql client
 * @param fetch - Function to refetch the connection given different pagination variables
 * @param nodes - The list of models to initialize the connection
 * @param pageInfo - The pagination information to initialize the connection
 */
export class Connection<Node> extends LinearConnection<Node> {
  private _fetch: (variables?: LinearConnectionVariables) => LinearFetch<LinearConnection<Node> | undefined>;

  public constructor(
    request: LinearRequest,
    fetch: (variables?: LinearConnectionVariables) => LinearFetch<LinearConnection<Node> | undefined>,
    nodes: Node[],
    pageInfo: PageInfo
  ) {
    super(request);
    this._fetch = fetch;
    this.nodes = nodes;
    this.pageInfo = pageInfo;
  }

  /** Add nodes to the end of the existing nodes */
  private _appendNodes(nodes?: Node[]) {
    this.nodes = nodes ? [...(this.nodes ?? []), ...nodes] : this.nodes;
  }

  /** Add nodes to the start of the existing nodes */
  private _prependNodes(nodes?: Node[]) {
    this.nodes = nodes ? [...nodes, ...(this.nodes ?? [])] : this.nodes;
  }

  /** Update the pagination end cursor */
  private _appendPageInfo(pageInfo?: PageInfo) {
    if (this.pageInfo) {
      this.pageInfo.endCursor = pageInfo?.endCursor ?? this.pageInfo.startCursor;
      this.pageInfo.hasNextPage = pageInfo?.hasNextPage ?? this.pageInfo.hasNextPage;
    }
  }

  /** Update the pagination start cursor */
  private _prependPageInfo(pageInfo?: PageInfo) {
    if (this.pageInfo) {
      this.pageInfo.startCursor = pageInfo?.startCursor ?? this.pageInfo.startCursor;
      this.pageInfo.hasPreviousPage = pageInfo?.hasPreviousPage ?? this.pageInfo.hasPreviousPage;
    }
  }

  /** Fetch the next page of results and append to nodes */
  public async fetchNext(): Promise<this> {
    if (this.pageInfo?.hasNextPage) {
      const response = await this._fetch({
        after: this.pageInfo?.endCursor,
      });
      this._appendNodes(response?.nodes);
      this._appendPageInfo(response?.pageInfo);
    }
    return Promise.resolve(this);
  }

  /** Fetch the previous page of results and prepend to nodes */
  public async fetchPrevious(): Promise<this> {
    if (this.pageInfo?.hasPreviousPage) {
      const response = await this._fetch({
        before: this.pageInfo?.startCursor,
      });
      this._prependNodes(response?.nodes);
      this._prependPageInfo(response?.pageInfo);
    }
    return Promise.resolve(this);
  }
}

/**
 * Function to parse custom scalars into Date types
 *
 * @param value - value to parse
 */
function parseDate(value?: any): Date | undefined {
  try {
    return value ? new Date(value) : undefined;
  } catch (e) {
    return undefined;
  }
}

/**
 * Function to parse custom scalars into JSON objects
 *
 * @param value - value to parse
 */
function parseJson(value?: any): Record<string, unknown> | undefined {
  try {
    return value ? JSON.parse(value) : undefined;
  } catch (e) {
    return undefined;
  }
}

/**
 * A bot actor is an actor that is not a user, but an application or integration.
 *
 * @param request - function to call the graphql client
 * @param data - L.ActorBotFragment response data
 */
export class ActorBot extends Request {
  public constructor(request: LinearRequest, data: L.ActorBotFragment) {
    super(request);
    this.avatarUrl = data.avatarUrl ?? undefined;
    this.id = data.id ?? undefined;
    this.name = data.name ?? undefined;
    this.subType = data.subType ?? undefined;
    this.type = data.type;
    this.userDisplayName = data.userDisplayName ?? undefined;
  }

  /** A url pointing to the avatar representing this bot. */
  public avatarUrl?: string;
  public id?: string;
  /** The display name of the bot. */
  public name?: string;
  /** The sub type of the bot. */
  public subType?: string;
  /** The type of bot. */
  public type: string;
  /** The display name of the external user on behalf of which the bot acted. */
  public userDisplayName?: string;
}
/**
 * An activity within an agent context.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityFragment response data
 */
export class AgentActivity extends Request {
  private _agentContext?: L.AgentActivityFragment["agentContext"];
  private _agentSession: L.AgentActivityFragment["agentSession"];
  private _sourceComment?: L.AgentActivityFragment["sourceComment"];

  public constructor(request: LinearRequest, data: L.AgentActivityFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.content = data.content;
    this._agentContext = data.agentContext ?? undefined;
    this._agentSession = data.agentSession;
    this._sourceComment = data.sourceComment ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The content of the activity */
  public content: L.AgentActivityContent;
  /** The agent context this activity belongs to. */
  public get agentContext(): LinearFetch<AgentContext> | undefined {
    return this._agentContext?.id ? new AgentContextQuery(this._request).fetch(this._agentContext?.id) : undefined;
  }
  /** The ID of agent context this activity belongs to. */
  public get agentContextId(): string | undefined {
    return this._agentContext?.id;
  }
  /** The agent session this activity belongs to. */
  public get agentSession(): LinearFetch<AgentSession> | undefined {
    return new AgentSessionQuery(this._request).fetch(this._agentSession.id);
  }
  /** The ID of agent session this activity belongs to. */
  public get agentSessionId(): string | undefined {
    return this._agentSession?.id;
  }
  /** The comment this activity is linked to. */
  public get sourceComment(): LinearFetch<Comment> | undefined {
    return this._sourceComment?.id ? new CommentQuery(this._request).fetch({ id: this._sourceComment?.id }) : undefined;
  }
  /** The ID of comment this activity is linked to. */
  public get sourceCommentId(): string | undefined {
    return this._sourceComment?.id;
  }

  /** Creates an agent activity. */
  public create(input: L.AgentActivityCreateInput) {
    return new CreateAgentActivityMutation(this._request).fetch(input);
  }
}
/**
 * Content for an action activity (tool call or action).
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityActionContentFragment response data
 */
export class AgentActivityActionContent extends Request {
  public constructor(request: LinearRequest, data: L.AgentActivityActionContentFragment) {
    super(request);
    this.action = data.action;
    this.parameter = data.parameter;
    this.result = data.result ?? undefined;
    this.type = data.type;
  }

  /** The action being performed. */
  public action: string;
  /** The parameters for the action, e.g. a file path, a keyword, etc. */
  public parameter: string;
  /** The result of the action in Markdown format. */
  public result?: string;
  /** The type of activity. */
  public type: L.AgentActivityType;
}
/**
 * AgentActivityConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AgentActivityConnection model
 * @param data - AgentActivityConnection response data
 */
export class AgentActivityConnection extends Connection<AgentActivity> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<AgentActivity> | undefined>,
    data: L.AgentActivityConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new AgentActivity(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Content for an elicitation activity.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityElicitationContentFragment response data
 */
export class AgentActivityElicitationContent extends Request {
  public constructor(request: LinearRequest, data: L.AgentActivityElicitationContentFragment) {
    super(request);
    this.body = data.body;
    this.type = data.type;
  }

  /** The elicitation message in Markdown format. */
  public body: string;
  /** The type of activity. */
  public type: L.AgentActivityType;
}
/**
 * Content for an error activity.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityErrorContentFragment response data
 */
export class AgentActivityErrorContent extends Request {
  public constructor(request: LinearRequest, data: L.AgentActivityErrorContentFragment) {
    super(request);
    this.body = data.body;
    this.type = data.type;
  }

  /** The error message in Markdown format. */
  public body: string;
  /** The type of activity. */
  public type: L.AgentActivityType;
}
/**
 * Content for an observation activity (chain of thought).
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityObservationContentFragment response data
 */
export class AgentActivityObservationContent extends Request {
  public constructor(request: LinearRequest, data: L.AgentActivityObservationContentFragment) {
    super(request);
    this.body = data.body;
    this.type = data.type;
  }

  /** The observation content in Markdown format. */
  public body: string;
  /** The type of activity. */
  public type: L.AgentActivityType;
}
/**
 * AgentActivityPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityPayloadFragment response data
 */
export class AgentActivityPayload extends Request {
  private _agentActivity: L.AgentActivityPayloadFragment["agentActivity"];

  public constructor(request: LinearRequest, data: L.AgentActivityPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._agentActivity = data.agentActivity;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The agent activity that was created or updated. */
  public get agentActivity(): LinearFetch<AgentActivity> | undefined {
    return new AgentActivityQuery(this._request).fetch(this._agentActivity.id);
  }
  /** The ID of agent activity that was created or updated. */
  public get agentActivityId(): string | undefined {
    return this._agentActivity?.id;
  }
}
/**
 * Content for a prompt activity.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityPromptContentFragment response data
 */
export class AgentActivityPromptContent extends Request {
  public constructor(request: LinearRequest, data: L.AgentActivityPromptContentFragment) {
    super(request);
    this.body = data.body;
    this.type = data.type;
  }

  /** A message requesting additional information or action from user. */
  public body: string;
  /** The type of activity. */
  public type: L.AgentActivityType;
}
/**
 * Content for a response activity.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentActivityResponseContentFragment response data
 */
export class AgentActivityResponseContent extends Request {
  public constructor(request: LinearRequest, data: L.AgentActivityResponseContentFragment) {
    super(request);
    this.body = data.body;
    this.type = data.type;
  }

  /** The response content in Markdown format. */
  public body: string;
  /** The type of activity. */
  public type: L.AgentActivityType;
}
/**
 * Payload for an agent activity webhook.
 *
 * @param data - L.AgentActivityWebhookPayloadFragment response data
 */
export class AgentActivityWebhookPayload {
  public constructor(data: L.AgentActivityWebhookPayloadFragment) {
    this.agentSessionId = data.agentSessionId;
    this.archivedAt = data.archivedAt ?? undefined;
    this.content = data.content;
    this.createdAt = data.createdAt;
    this.id = data.id;
    this.updatedAt = data.updatedAt;
  }

  /** The ID of the agent session that this activity belongs to. */
  public agentSessionId: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The content of the agent activity. */
  public content: L.Scalars["JSONObject"];
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the entity. */
  public id: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
}
/**
 * [DEPRECATED] A context for agent activities and state management.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentContextFragment response data
 */
export class AgentContext extends Request {
  private _appUser: L.AgentContextFragment["appUser"];
  private _comment?: L.AgentContextFragment["comment"];
  private _creator?: L.AgentContextFragment["creator"];
  private _issue?: L.AgentContextFragment["issue"];

  public constructor(request: LinearRequest, data: L.AgentContextFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.endedAt = parseDate(data.endedAt) ?? undefined;
    this.id = data.id;
    this.sourceMetadata = parseJson(data.sourceMetadata) ?? undefined;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.summary = data.summary ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.activities = data.activities.map(node => new AgentActivity(request, node));
    this.links = data.links.map(node => new EntityExternalLink(request, node));
    this.status = data.status;
    this.type = data.type;
    this._appUser = data.appUser;
    this._comment = data.comment ?? undefined;
    this._creator = data.creator ?? undefined;
    this._issue = data.issue ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The time the agent context ended. */
  public endedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Metadata about the external source that created this agent context. */
  public sourceMetadata?: Record<string, unknown>;
  /** The time the agent context started working. */
  public startedAt?: Date;
  /** A summary of the activities in this context. */
  public summary?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Activities associated with this agent context. */
  public activities: AgentActivity[];
  /** External links associated with this agent context. */
  public links: EntityExternalLink[];
  /** The current status of the agent context. */
  public status: L.AgentSessionStatus;
  /** The type of the agent context. */
  public type: L.AgentSessionType;
  /** The agent user that is associated with this agent context. */
  public get appUser(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._appUser.id);
  }
  /** The ID of agent user that is associated with this agent context. */
  public get appUserId(): string | undefined {
    return this._appUser?.id;
  }
  /** The comment this agent context is associated with. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The ID of comment this agent context is associated with. */
  public get commentId(): string | undefined {
    return this._comment?.id;
  }
  /** The user that created this agent context. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user that created this agent context. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The issue this agent context is associated with. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue this agent context is associated with. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }

  /** Creates an agent context. */
  public create(input: L.AgentContextCreateInput) {
    return new CreateAgentContextMutation(this._request).fetch(input);
  }
  /** Updates an agent context. */
  public update(input: L.AgentContextUpdateInput) {
    return new UpdateAgentContextMutation(this._request).fetch(this.id, input);
  }
}
/**
 * AgentContextConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AgentContextConnection model
 * @param data - AgentContextConnection response data
 */
export class AgentContextConnection extends Connection<AgentContext> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<AgentContext> | undefined>,
    data: L.AgentContextConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new AgentContext(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * AgentContextPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentContextPayloadFragment response data
 */
export class AgentContextPayload extends Request {
  private _agentContext: L.AgentContextPayloadFragment["agentContext"];

  public constructor(request: LinearRequest, data: L.AgentContextPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._agentContext = data.agentContext;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The agent context that was created or updated. */
  public get agentContext(): LinearFetch<AgentContext> | undefined {
    return new AgentContextQuery(this._request).fetch(this._agentContext.id);
  }
  /** The ID of agent context that was created or updated. */
  public get agentContextId(): string | undefined {
    return this._agentContext?.id;
  }
}
/**
 * Payload for an agent context webhook.
 *
 * @param data - L.AgentContextWebhookPayloadFragment response data
 */
export class AgentContextWebhookPayload {
  public constructor(data: L.AgentContextWebhookPayloadFragment) {
    this.appUserId = data.appUserId;
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId;
    this.endedAt = data.endedAt ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId ?? undefined;
    this.organizationId = data.organizationId;
    this.sourceMetadata = data.sourceMetadata ?? undefined;
    this.startedAt = data.startedAt ?? undefined;
    this.status = data.status;
    this.summary = data.summary ?? undefined;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.comment = data.comment ? new CommentChildWebhookPayload(data.comment) : undefined;
    this.creator = new UserChildWebhookPayload(data.creator);
    this.issue = data.issue ? new IssueWithDescriptionChildWebhookPayload(data.issue) : undefined;
  }

  /** The ID of the agent that the agent context belongs to. */
  public appUserId: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment this agent context is associated with. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the user that created the agent context. */
  public creatorId: string;
  /** The time the agent context ended. */
  public endedAt?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this agent context is associated with. */
  public issueId?: string;
  /** The ID of the organization that the agent context belongs to. */
  public organizationId: string;
  /** Metadata about the external source that created this agent context. */
  public sourceMetadata?: L.Scalars["JSONObject"];
  /** The time the agent context started working. */
  public startedAt?: string;
  /** The current status of the agent context. */
  public status: string;
  /** A summary of the activities in this context. */
  public summary?: string;
  /** The type of the agent context. */
  public type: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The comment this agent context is associated with. */
  public comment?: CommentChildWebhookPayload;
  /** The user that created the agent context. */
  public creator: UserChildWebhookPayload;
  /** The issue this agent context is associated with. */
  public issue?: IssueWithDescriptionChildWebhookPayload;
}
/**
 * A session for agent activities and state management.
 *
 * @param request - function to call the graphql client
 * @param data - L.AgentSessionFragment response data
 */
export class AgentSession extends Request {
  private _appUser: L.AgentSessionFragment["appUser"];
  private _comment?: L.AgentSessionFragment["comment"];
  private _creator?: L.AgentSessionFragment["creator"];
  private _issue?: L.AgentSessionFragment["issue"];

  public constructor(request: LinearRequest, data: L.AgentSessionFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.endedAt = parseDate(data.endedAt) ?? undefined;
    this.id = data.id;
    this.sourceMetadata = parseJson(data.sourceMetadata) ?? undefined;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.summary = data.summary ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.links = data.links.map(node => new EntityExternalLink(request, node));
    this.status = data.status;
    this.type = data.type;
    this._appUser = data.appUser;
    this._comment = data.comment ?? undefined;
    this._creator = data.creator ?? undefined;
    this._issue = data.issue ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The time the agent session ended. */
  public endedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Metadata about the external source that created this agent session. */
  public sourceMetadata?: Record<string, unknown>;
  /** The time the agent session started. */
  public startedAt?: Date;
  /** A summary of the activities in this session. */
  public summary?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** External links associated with this agent session. */
  public links: EntityExternalLink[];
  /** The current status of the agent session. */
  public status: L.AgentSessionStatus;
  /** The type of the agent session. */
  public type: L.AgentSessionType;
  /** The agent user that is associated with this agent session. */
  public get appUser(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._appUser.id);
  }
  /** The ID of agent user that is associated with this agent session. */
  public get appUserId(): string | undefined {
    return this._appUser?.id;
  }
  /** The comment this agent session is associated with. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The ID of comment this agent session is associated with. */
  public get commentId(): string | undefined {
    return this._comment?.id;
  }
  /** The user that created this agent session. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user that created this agent session. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The issue this agent session is associated with. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue this agent session is associated with. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** Activities associated with this agent session. */
  public activities(variables?: Omit<L.AgentSession_ActivitiesQueryVariables, "id">) {
    return new AgentSession_ActivitiesQuery(this._request, this.id, variables).fetch(variables);
  }
}
/**
 * AgentSessionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AgentSessionConnection model
 * @param data - AgentSessionConnection response data
 */
export class AgentSessionConnection extends Connection<AgentSession> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<AgentSession> | undefined>,
    data: L.AgentSessionConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new AgentSession(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Payload for agent session webhook events.
 *
 * @param data - L.AgentSessionEventWebhookPayloadFragment response data
 */
export class AgentSessionEventWebhookPayload {
  public constructor(data: L.AgentSessionEventWebhookPayloadFragment) {
    this.action = data.action;
    this.appUserId = data.appUserId;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.oauthClientId = data.oauthClientId;
    this.organizationId = data.organizationId;
    this.type = data.type;
    this.agentActivity = data.agentActivity ? new AgentActivityWebhookPayload(data.agentActivity) : undefined;
    this.agentSession = new AgentSessionWebhookPayload(data.agentSession);
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** ID of the app user the agent session belongs to. */
  public appUserId: string;
  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the OAuth client the app user is tied to. */
  public oauthClientId: string;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** The type of resource. */
  public type: string;
  /** The agent activity that was created. */
  public agentActivity?: AgentActivityWebhookPayload;
  /** The agent session that the event belongs to. */
  public agentSession: AgentSessionWebhookPayload;
}
/**
 * Payload for an agent session webhook.
 *
 * @param data - L.AgentSessionWebhookPayloadFragment response data
 */
export class AgentSessionWebhookPayload {
  public constructor(data: L.AgentSessionWebhookPayloadFragment) {
    this.appUserId = data.appUserId;
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId;
    this.endedAt = data.endedAt ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId ?? undefined;
    this.organizationId = data.organizationId;
    this.sourceMetadata = data.sourceMetadata ?? undefined;
    this.startedAt = data.startedAt ?? undefined;
    this.status = data.status;
    this.summary = data.summary ?? undefined;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.comment = data.comment ? new CommentChildWebhookPayload(data.comment) : undefined;
    this.creator = new UserChildWebhookPayload(data.creator);
    this.issue = data.issue ? new IssueWithDescriptionChildWebhookPayload(data.issue) : undefined;
  }

  /** The ID of the agent that the agent session belongs to. */
  public appUserId: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment this agent session is associated with. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the user that created the agent session. */
  public creatorId: string;
  /** The time the agent session ended. */
  public endedAt?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this agent session is associated with. */
  public issueId?: string;
  /** The ID of the organization that the agent session belongs to. */
  public organizationId: string;
  /** Metadata about the external source that created this agent session. */
  public sourceMetadata?: L.Scalars["JSONObject"];
  /** The time the agent session started working. */
  public startedAt?: string;
  /** The current status of the agent session. */
  public status: string;
  /** A summary of the activities in this session. */
  public summary?: string;
  /** The type of the agent session. */
  public type: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The comment this agent session is associated with. */
  public comment?: CommentChildWebhookPayload;
  /** The user that created the agent session. */
  public creator: UserChildWebhookPayload;
  /** The issue this agent session is associated with. */
  public issue?: IssueWithDescriptionChildWebhookPayload;
}
/**
 * An API key. Grants access to the user's resources.
 *
 * @param request - function to call the graphql client
 * @param data - L.ApiKeyFragment response data
 */
export class ApiKey extends Request {
  public constructor(request: LinearRequest, data: L.ApiKeyFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.label = data.label;
    this.requestedSyncGroups = data.requestedSyncGroups ?? undefined;
    this.scope = data.scope ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The label of the API key. */
  public label: string;
  /** The sync groups that this API key requests access to. If null, the API key has access to all sync groups the user has access to. The final set of sync groups is computed as the intersection of these requested groups with the user's base sync groups. */
  public requestedSyncGroups?: string[];
  /** Scopes associated with the API key. */
  public scope?: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Organization the API key belongs to. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
}
/**
 * ApiKeyConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ApiKeyConnection model
 * @param data - ApiKeyConnection response data
 */
export class ApiKeyConnection extends Connection<ApiKey> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ApiKey> | undefined>,
    data: L.ApiKeyConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ApiKey(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ApiKeyPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ApiKeyPayloadFragment response data
 */
export class ApiKeyPayload extends Request {
  public constructor(request: LinearRequest, data: L.ApiKeyPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.apiKey = new ApiKey(request, data.apiKey);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The API key that was created. */
  public apiKey: ApiKey;
}
/**
 * Payload for app user notification webhook events.
 *
 * @param data - L.AppUserNotificationWebhookPayloadFragment response data
 */
export class AppUserNotificationWebhookPayload {
  public constructor(data: L.AppUserNotificationWebhookPayloadFragment) {
    this.action = data.action;
    this.appUserId = data.appUserId;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.oauthClientId = data.oauthClientId;
    this.organizationId = data.organizationId;
    this.type = data.type;
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** ID of the app user the notification is for. */
  public appUserId: string;
  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the OAuth client the app user is tied to. */
  public oauthClientId: string;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** The type of resource. */
  public type: string;
}
/**
 * Payload for app user team access change webhook events.
 *
 * @param data - L.AppUserTeamAccessChangedWebhookPayloadFragment response data
 */
export class AppUserTeamAccessChangedWebhookPayload {
  public constructor(data: L.AppUserTeamAccessChangedWebhookPayloadFragment) {
    this.action = data.action;
    this.addedTeamIds = data.addedTeamIds;
    this.appUserId = data.appUserId;
    this.canAccessAllPublicTeams = data.canAccessAllPublicTeams;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.oauthClientId = data.oauthClientId;
    this.organizationId = data.organizationId;
    this.removedTeamIds = data.removedTeamIds;
    this.type = data.type;
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** IDs of the teams the app user was added to. */
  public addedTeamIds: string[];
  /** ID of the app user the notification is for. */
  public appUserId: string;
  /** Whether the app user can access all public teams. */
  public canAccessAllPublicTeams: boolean;
  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the OAuth client the app user is tied to. */
  public oauthClientId: string;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** IDs of the teams the app user was removed from. */
  public removedTeamIds: string[];
  /** The type of resource. */
  public type: string;
}
/**
 * Public information of the OAuth application.
 *
 * @param request - function to call the graphql client
 * @param data - L.ApplicationFragment response data
 */
export class Application extends Request {
  public constructor(request: LinearRequest, data: L.ApplicationFragment) {
    super(request);
    this.clientId = data.clientId;
    this.description = data.description ?? undefined;
    this.developer = data.developer;
    this.developerUrl = data.developerUrl;
    this.id = data.id;
    this.imageUrl = data.imageUrl ?? undefined;
    this.name = data.name;
  }

  /** OAuth application's client ID. */
  public clientId: string;
  /** Information about the application. */
  public description?: string;
  /** Name of the developer. */
  public developer: string;
  /** Url of the developer (homepage or docs). */
  public developerUrl: string;
  /** OAuth application's ID. */
  public id: string;
  /** Image of the application. */
  public imageUrl?: string;
  /** Application name. */
  public name: string;
}
/**
 * A generic payload return from entity archive or deletion mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.ArchivePayloadFragment response data
 */
export class ArchivePayload extends Request {
  public constructor(request: LinearRequest, data: L.ArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Contains requested archived model objects.
 *
 * @param request - function to call the graphql client
 * @param data - L.ArchiveResponseFragment response data
 */
export class ArchiveResponse extends Request {
  public constructor(request: LinearRequest, data: L.ArchiveResponseFragment) {
    super(request);
    this.archive = data.archive;
    this.databaseVersion = data.databaseVersion;
    this.includesDependencies = data.includesDependencies;
    this.totalCount = data.totalCount;
  }

  /** A JSON serialized collection of model objects loaded from the archive */
  public archive: string;
  /** The version of the remote database. Incremented by 1 for each migration run on the database. */
  public databaseVersion: number;
  /** Whether the dependencies for the model objects are included in the archive. */
  public includesDependencies: string[];
  /** The total number of entities in the archive. */
  public totalCount: number;
}
/**
 * AsksChannelConnectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AsksChannelConnectPayloadFragment response data
 */
export class AsksChannelConnectPayload extends Request {
  private _integration?: L.AsksChannelConnectPayloadFragment["integration"];

  public constructor(request: LinearRequest, data: L.AsksChannelConnectPayloadFragment) {
    super(request);
    this.addBot = data.addBot;
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.mapping = new SlackChannelNameMapping(request, data.mapping);
    this._integration = data.integration ?? undefined;
  }

  /** Whether the bot needs to be manually added to the channel. */
  public addBot: boolean;
  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The new Asks Slack channel mapping for the connected channel. */
  public mapping: SlackChannelNameMapping;
  /** The integration that was created or updated. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that was created or updated. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
}
/**
 * Issue attachment (e.g. support ticket, pull request).
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentFragment response data
 */
export class Attachment extends Request {
  private _creator?: L.AttachmentFragment["creator"];
  private _externalUserCreator?: L.AttachmentFragment["externalUserCreator"];
  private _issue: L.AttachmentFragment["issue"];
  private _originalIssue?: L.AttachmentFragment["originalIssue"];

  public constructor(request: LinearRequest, data: L.AttachmentFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.bodyData = data.bodyData ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.groupBySource = data.groupBySource;
    this.id = data.id;
    this.metadata = data.metadata;
    this.source = data.source ?? undefined;
    this.sourceType = data.sourceType ?? undefined;
    this.subtitle = data.subtitle ?? undefined;
    this.title = data.title;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this._creator = data.creator ?? undefined;
    this._externalUserCreator = data.externalUserCreator ?? undefined;
    this._issue = data.issue;
    this._originalIssue = data.originalIssue ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The body data of the attachment, if any. */
  public bodyData?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Indicates if attachments for the same source application should be grouped in the Linear UI. */
  public groupBySource: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** Custom metadata related to the attachment. */
  public metadata: L.Scalars["JSONObject"];
  /** Information about the source which created the attachment. */
  public source?: L.Scalars["JSONObject"];
  /** An accessor helper to source.type, defines the source type of the attachment. */
  public sourceType?: string;
  /** Content for the subtitle line in the Linear attachment widget. */
  public subtitle?: string;
  /** Content for the title line in the Linear attachment widget. */
  public title: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Location of the attachment which is also used as an identifier. */
  public url: string;
  /** The creator of the attachment. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of creator of the attachment. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The non-Linear user who created the attachment. */
  public get externalUserCreator(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserCreator?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserCreator?.id)
      : undefined;
  }
  /** The ID of non-linear user who created the attachment. */
  public get externalUserCreatorId(): string | undefined {
    return this._externalUserCreator?.id;
  }
  /** The issue this attachment belongs to. */
  public get issue(): LinearFetch<Issue> | undefined {
    return new IssueQuery(this._request).fetch(this._issue.id);
  }
  /** The ID of issue this attachment belongs to. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The issue this attachment was originally created on. Will be undefined if the attachment hasn't been moved. */
  public get originalIssue(): LinearFetch<Issue> | undefined {
    return this._originalIssue?.id ? new IssueQuery(this._request).fetch(this._originalIssue?.id) : undefined;
  }
  /** The ID of issue this attachment was originally created on. will be undefined if the attachment hasn't been moved. */
  public get originalIssueId(): string | undefined {
    return this._originalIssue?.id;
  }

  /** Creates a new attachment, or updates existing if the same `url` and `issueId` is used. */
  public create(input: L.AttachmentCreateInput) {
    return new CreateAttachmentMutation(this._request).fetch(input);
  }
  /** Deletes an issue attachment. */
  public delete() {
    return new DeleteAttachmentMutation(this._request).fetch(this.id);
  }
  /** Updates an existing issue attachment. */
  public update(input: L.AttachmentUpdateInput) {
    return new UpdateAttachmentMutation(this._request).fetch(this.id, input);
  }
}
/**
 * AttachmentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AttachmentConnection model
 * @param data - AttachmentConnection response data
 */
export class AttachmentConnection extends Connection<Attachment> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Attachment> | undefined>,
    data: L.AttachmentConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Attachment(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * AttachmentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentPayloadFragment response data
 */
export class AttachmentPayload extends Request {
  private _attachment: L.AttachmentPayloadFragment["attachment"];

  public constructor(request: LinearRequest, data: L.AttachmentPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._attachment = data.attachment;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The issue attachment that was created. */
  public get attachment(): LinearFetch<Attachment> | undefined {
    return new AttachmentQuery(this._request).fetch(this._attachment.id);
  }
  /** The ID of issue attachment that was created. */
  public get attachmentId(): string | undefined {
    return this._attachment?.id;
  }
}
/**
 * AttachmentSourcesPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.AttachmentSourcesPayloadFragment response data
 */
export class AttachmentSourcesPayload extends Request {
  public constructor(request: LinearRequest, data: L.AttachmentSourcesPayloadFragment) {
    super(request);
    this.sources = data.sources;
  }

  /** A unique list of all source types used in this workspace. */
  public sources: L.Scalars["JSONObject"];
}
/**
 * Payload for an attachment webhook.
 *
 * @param data - L.AttachmentWebhookPayloadFragment response data
 */
export class AttachmentWebhookPayload {
  public constructor(data: L.AttachmentWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.externalUserCreatorId = data.externalUserCreatorId ?? undefined;
    this.groupBySource = data.groupBySource;
    this.id = data.id;
    this.issueId = data.issueId;
    this.metadata = data.metadata;
    this.originalIssueId = data.originalIssueId ?? undefined;
    this.source = data.source ?? undefined;
    this.sourceType = data.sourceType ?? undefined;
    this.subtitle = data.subtitle ?? undefined;
    this.title = data.title;
    this.updatedAt = data.updatedAt;
    this.url = data.url;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the creator of the attachment. */
  public creatorId?: string;
  /** The ID of the non-Linear user who created the attachment. */
  public externalUserCreatorId?: string;
  /** Whether attachments for the same source application should be grouped in the Linear UI. */
  public groupBySource: boolean;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this attachment belongs to. */
  public issueId: string;
  /** Custom metadata related to the attachment. */
  public metadata: L.Scalars["JSONObject"];
  /** The ID of the issue this attachment belonged to originally. */
  public originalIssueId?: string;
  /** Information about the source which created the attachment. */
  public source?: L.Scalars["JSONObject"];
  /** The source type of the attachment. */
  public sourceType?: string;
  /** Optional subtitle of the attachment. */
  public subtitle?: string;
  /** The title of the attachment. */
  public title: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the attachment. */
  public url: string;
}
/**
 * Workspace audit log entry object.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuditEntryFragment response data
 */
export class AuditEntry extends Request {
  private _actor?: L.AuditEntryFragment["actor"];

  public constructor(request: LinearRequest, data: L.AuditEntryFragment) {
    super(request);
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.countryCode = data.countryCode ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.ip = data.ip ?? undefined;
    this.metadata = data.metadata ?? undefined;
    this.requestInformation = data.requestInformation ?? undefined;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._actor = data.actor ?? undefined;
  }

  /** The ID of the user that caused the audit entry to be created. */
  public actorId?: string;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Country code of request resulting to audit entry. */
  public countryCode?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** IP from actor when entry was recorded. */
  public ip?: string;
  /** Additional metadata related to the audit entry. */
  public metadata?: L.Scalars["JSONObject"];
  /** Additional information related to the request which performed the action. */
  public requestInformation?: L.Scalars["JSONObject"];
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user that caused the audit entry to be created. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The organization the audit log belongs to. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
}
/**
 * AuditEntryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this AuditEntryConnection model
 * @param data - AuditEntryConnection response data
 */
export class AuditEntryConnection extends Connection<AuditEntry> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<AuditEntry> | undefined>,
    data: L.AuditEntryConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new AuditEntry(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * AuditEntryType model
 *
 * @param request - function to call the graphql client
 * @param data - L.AuditEntryTypeFragment response data
 */
export class AuditEntryType extends Request {
  public constructor(request: LinearRequest, data: L.AuditEntryTypeFragment) {
    super(request);
    this.description = data.description;
    this.type = data.type;
  }

  /** Description of the audit entry type. */
  public description: string;
  /** The audit entry type. */
  public type: string;
}
/**
 * Payload for an audit entry webhook.
 *
 * @param data - L.AuditEntryWebhookPayloadFragment response data
 */
export class AuditEntryWebhookPayload {
  public constructor(data: L.AuditEntryWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.countryCode = data.countryCode ?? undefined;
    this.createdAt = data.createdAt;
    this.id = data.id;
    this.ip = data.ip ?? undefined;
    this.metadata = data.metadata ?? undefined;
    this.organizationId = data.organizationId;
    this.requestInformation = data.requestInformation ?? undefined;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
  }

  /** The ID of the user that caused the audit entry to be created. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** Country code of request resulting to audit entry. */
  public countryCode?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the entity. */
  public id: string;
  /** IP from actor when entry was recorded. */
  public ip?: string;
  /** Additional metadata related to the audit entry. */
  public metadata?: L.Scalars["JSONObject"];
  /** The ID of the organization that the audit entry belongs to. */
  public organizationId: string;
  /** Additional information related to the request which performed the action. */
  public requestInformation?: L.Scalars["JSONObject"];
  /** The type of the audit entry. */
  public type: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
}
/**
 * An organization. Organizations are root-level objects that contain users and teams.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthOrganizationFragment response data
 */
export class AuthOrganization extends Request {
  public constructor(request: LinearRequest, data: L.AuthOrganizationFragment) {
    super(request);
    this.allowedAuthServices = data.allowedAuthServices;
    this.deletionRequestedAt = parseDate(data.deletionRequestedAt) ?? undefined;
    this.enabled = data.enabled;
    this.id = data.id;
    this.logoUrl = data.logoUrl ?? undefined;
    this.name = data.name;
    this.previousUrlKeys = data.previousUrlKeys;
    this.region = data.region;
    this.samlEnabled = data.samlEnabled;
    this.scimEnabled = data.scimEnabled;
    this.serviceId = data.serviceId;
    this.urlKey = data.urlKey;
    this.userCount = data.userCount;
    this.releaseChannel = data.releaseChannel;
  }

  /** Allowed authentication providers, empty array means all are allowed */
  public allowedAuthServices: string[];
  /** The time at which deletion of the organization was requested. */
  public deletionRequestedAt?: Date;
  /** Whether the organization is enabled. Used as a superuser tool to lock down the org. */
  public enabled: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** The organization's logo URL. */
  public logoUrl?: string;
  /** The organization's name. */
  public name: string;
  /** Previously used URL keys for the organization (last 3 are kept and redirected). */
  public previousUrlKeys: string[];
  /** The region the organization is hosted in. */
  public region: string;
  /** Whether SAML authentication is enabled for organization. */
  public samlEnabled: boolean;
  /** Whether SCIM provisioning is enabled for organization. */
  public scimEnabled: boolean;
  /** The email domain or URL key for the organization. */
  public serviceId: string;
  /** The organization's unique URL key. */
  public urlKey: string;
  public userCount: number;
  /** The feature release channel the organization belongs to. */
  public releaseChannel: L.ReleaseChannel;
}
/**
 * AuthResolverResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthResolverResponseFragment response data
 */
export class AuthResolverResponse extends Request {
  public constructor(request: LinearRequest, data: L.AuthResolverResponseFragment) {
    super(request);
    this.allowDomainAccess = data.allowDomainAccess ?? undefined;
    this.email = data.email;
    this.id = data.id;
    this.lastUsedOrganizationId = data.lastUsedOrganizationId ?? undefined;
    this.token = data.token ?? undefined;
    this.availableOrganizations = data.availableOrganizations
      ? data.availableOrganizations.map(node => new AuthOrganization(request, node))
      : undefined;
    this.lockedOrganizations = data.lockedOrganizations
      ? data.lockedOrganizations.map(node => new AuthOrganization(request, node))
      : undefined;
    this.lockedUsers = data.lockedUsers.map(node => new AuthUser(request, node));
    this.users = data.users.map(node => new AuthUser(request, node));
  }

  /** Should the signup flow allow access for the domain. */
  public allowDomainAccess?: boolean;
  /** Email for the authenticated account. */
  public email: string;
  /** User account ID. */
  public id: string;
  /** ID of the organization last accessed by the user. */
  public lastUsedOrganizationId?: string;
  /** Application token. */
  public token?: string;
  /** List of organizations allowing this user account to join automatically. */
  public availableOrganizations?: AuthOrganization[];
  /** List of organization available to this user account but locked due to the current auth method. */
  public lockedOrganizations?: AuthOrganization[];
  /** List of locked users that are locked by login restrictions */
  public lockedUsers: AuthUser[];
  /** List of active users that belong to the user account. */
  public users: AuthUser[];
}
/**
 * A user that has access to the the resources of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthUserFragment response data
 */
export class AuthUser extends Request {
  public constructor(request: LinearRequest, data: L.AuthUserFragment) {
    super(request);
    this.active = data.active;
    this.avatarUrl = data.avatarUrl ?? undefined;
    this.displayName = data.displayName;
    this.email = data.email;
    this.id = data.id;
    this.name = data.name;
    this.userAccountId = data.userAccountId;
    this.organization = new AuthOrganization(request, data.organization);
    this.role = data.role;
  }

  /** Whether the user is active. */
  public active: boolean;
  /** An URL to the user's avatar image. */
  public avatarUrl?: string;
  /** The user's display (nick) name. Unique within each organization. */
  public displayName: string;
  /** The user's email address. */
  public email: string;
  public id: string;
  /** The user's full name. */
  public name: string;
  /** User account ID the user belongs to. */
  public userAccountId: string;
  /** Organization the user belongs to. */
  public organization: AuthOrganization;
  /** Whether the user is an organization admin or guest on a database level. */
  public role: L.UserRoleType;
}
/**
 * Authentication session information.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthenticationSessionResponseFragment response data
 */
export class AuthenticationSessionResponse extends Request {
  public constructor(request: LinearRequest, data: L.AuthenticationSessionResponseFragment) {
    super(request);
    this.browserType = data.browserType ?? undefined;
    this.client = data.client ?? undefined;
    this.countryCodes = data.countryCodes;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.ip = data.ip ?? undefined;
    this.isCurrentSession = data.isCurrentSession;
    this.lastActiveAt = parseDate(data.lastActiveAt) ?? undefined;
    this.location = data.location ?? undefined;
    this.locationCity = data.locationCity ?? undefined;
    this.locationCountry = data.locationCountry ?? undefined;
    this.locationCountryCode = data.locationCountryCode ?? undefined;
    this.locationRegionCode = data.locationRegionCode ?? undefined;
    this.name = data.name;
    this.operatingSystem = data.operatingSystem ?? undefined;
    this.service = data.service ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.userAgent = data.userAgent ?? undefined;
    this.type = data.type;
  }

  /** Used web browser. */
  public browserType?: string;
  /** Client used for the session */
  public client?: string;
  /** Country codes of all seen locations. */
  public countryCodes: string[];
  /** Date when the session was created. */
  public createdAt: Date;
  public id: string;
  /** IP address. */
  public ip?: string;
  /** Identifies the session used to make the request. */
  public isCurrentSession: boolean;
  /** When was the session last seen */
  public lastActiveAt?: Date;
  /** Human readable location */
  public location?: string;
  /** Location city name. */
  public locationCity?: string;
  /** Location country name. */
  public locationCountry?: string;
  /** Location country code. */
  public locationCountryCode?: string;
  /** Location region code. */
  public locationRegionCode?: string;
  /** Name of the session, derived from the client and operating system */
  public name: string;
  /** Operating system used for the session */
  public operatingSystem?: string;
  /** Service used for logging in. */
  public service?: string;
  /** Date when the session was last updated. */
  public updatedAt: Date;
  /** Session's user-agent. */
  public userAgent?: string;
  /** Type of application used to authenticate. */
  public type: L.AuthenticationSessionType;
}
/**
 * Details of the app user's authorizing user.
 *
 * @param request - function to call the graphql client
 * @param data - L.AuthorizingUserFragment response data
 */
export class AuthorizingUser extends Request {
  public constructor(request: LinearRequest, data: L.AuthorizingUserFragment) {
    super(request);
    this.displayName = data.displayName;
    this.name = data.name;
  }

  /** The user's display name. */
  public displayName: string;
  /** The user's full name. */
  public name: string;
}
/**
 * Base fields for all webhook payloads.
 *
 * @param data - L.BaseWebhookPayloadFragment response data
 */
export class BaseWebhookPayload {
  public constructor(data: L.BaseWebhookPayloadFragment) {
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.organizationId = data.organizationId;
  }

  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
}
/**
 * A comment associated with an issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.CommentFragment response data
 */
export class Comment extends Request {
  private _externalUser?: L.CommentFragment["externalUser"];
  private _initiativeUpdate?: L.CommentFragment["initiativeUpdate"];
  private _issue?: L.CommentFragment["issue"];
  private _parent?: L.CommentFragment["parent"];
  private _projectUpdate?: L.CommentFragment["projectUpdate"];
  private _resolvingComment?: L.CommentFragment["resolvingComment"];
  private _resolvingUser?: L.CommentFragment["resolvingUser"];
  private _user?: L.CommentFragment["user"];

  public constructor(request: LinearRequest, data: L.CommentFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.body = data.body;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.editedAt = parseDate(data.editedAt) ?? undefined;
    this.id = data.id;
    this.quotedText = data.quotedText ?? undefined;
    this.reactionData = data.reactionData;
    this.resolvedAt = parseDate(data.resolvedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this.documentContent = data.documentContent ? new DocumentContent(request, data.documentContent) : undefined;
    this.externalThread = data.externalThread ? new SyncedExternalThread(request, data.externalThread) : undefined;
    this.reactions = data.reactions.map(node => new Reaction(request, node));
    this.syncedWith = data.syncedWith ? data.syncedWith.map(node => new ExternalEntityInfo(request, node)) : undefined;
    this._externalUser = data.externalUser ?? undefined;
    this._initiativeUpdate = data.initiativeUpdate ?? undefined;
    this._issue = data.issue ?? undefined;
    this._parent = data.parent ?? undefined;
    this._projectUpdate = data.projectUpdate ?? undefined;
    this._resolvingComment = data.resolvingComment ?? undefined;
    this._resolvingUser = data.resolvingUser ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The comment content in markdown format. */
  public body: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The time user edited the comment. */
  public editedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The text that this comment references. Only defined for inline comments. */
  public quotedText?: string;
  /** Emoji reaction summary, grouped by emoji type. */
  public reactionData: L.Scalars["JSONObject"];
  /** The time the resolvingUser resolved the thread. */
  public resolvedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Comment's URL. */
  public url: string;
  /** Reactions associated with the comment. */
  public reactions: Reaction[];
  /** The external services the comment is synced with. */
  public syncedWith?: ExternalEntityInfo[];
  /** The bot that created the comment. */
  public botActor?: ActorBot;
  /** The document content that the comment is associated with. */
  public documentContent?: DocumentContent;
  /** The external thread that the comment is synced with. */
  public externalThread?: SyncedExternalThread;
  /** The external user who wrote the comment. */
  public get externalUser(): LinearFetch<ExternalUser> | undefined {
    return this._externalUser?.id ? new ExternalUserQuery(this._request).fetch(this._externalUser?.id) : undefined;
  }
  /** The ID of external user who wrote the comment. */
  public get externalUserId(): string | undefined {
    return this._externalUser?.id;
  }
  /** The initiative update that the comment is associated with. */
  public get initiativeUpdate(): LinearFetch<InitiativeUpdate> | undefined {
    return this._initiativeUpdate?.id
      ? new InitiativeUpdateQuery(this._request).fetch(this._initiativeUpdate?.id)
      : undefined;
  }
  /** The ID of initiative update that the comment is associated with. */
  public get initiativeUpdateId(): string | undefined {
    return this._initiativeUpdate?.id;
  }
  /** The issue that the comment is associated with. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue that the comment is associated with. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The parent comment under which the current comment is nested. */
  public get parent(): LinearFetch<Comment> | undefined {
    return this._parent?.id ? new CommentQuery(this._request).fetch({ id: this._parent?.id }) : undefined;
  }
  /** The ID of parent comment under which the current comment is nested. */
  public get parentId(): string | undefined {
    return this._parent?.id;
  }
  /** The project update that the comment is associated with. */
  public get projectUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return this._projectUpdate?.id ? new ProjectUpdateQuery(this._request).fetch(this._projectUpdate?.id) : undefined;
  }
  /** The ID of project update that the comment is associated with. */
  public get projectUpdateId(): string | undefined {
    return this._projectUpdate?.id;
  }
  /** The comment that resolved the thread. */
  public get resolvingComment(): LinearFetch<Comment> | undefined {
    return this._resolvingComment?.id
      ? new CommentQuery(this._request).fetch({ id: this._resolvingComment?.id })
      : undefined;
  }
  /** The ID of comment that resolved the thread. */
  public get resolvingCommentId(): string | undefined {
    return this._resolvingComment?.id;
  }
  /** The user that resolved the thread. */
  public get resolvingUser(): LinearFetch<User> | undefined {
    return this._resolvingUser?.id ? new UserQuery(this._request).fetch(this._resolvingUser?.id) : undefined;
  }
  /** The ID of user that resolved the thread. */
  public get resolvingUserId(): string | undefined {
    return this._resolvingUser?.id;
  }
  /** The user who wrote the comment. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user who wrote the comment. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
  /** The children of the comment. */
  public children(variables?: L.Comment_ChildrenQueryVariables) {
    return new Comment_ChildrenQuery(this._request, variables).fetch(variables);
  }
  /** Creates a new comment. */
  public create(input: L.CommentCreateInput) {
    return new CreateCommentMutation(this._request).fetch(input);
  }
  /** Deletes a comment. */
  public delete() {
    return new DeleteCommentMutation(this._request).fetch(this.id);
  }
  /** Updates a comment. */
  public update(input: L.CommentUpdateInput) {
    return new UpdateCommentMutation(this._request).fetch(this.id, input);
  }
}
/**
 * Certain properties of a comment.
 *
 * @param data - L.CommentChildWebhookPayloadFragment response data
 */
export class CommentChildWebhookPayload {
  public constructor(data: L.CommentChildWebhookPayloadFragment) {
    this.body = data.body;
    this.documentContentId = data.documentContentId ?? undefined;
    this.id = data.id;
    this.initiativeUpdateId = data.initiativeUpdateId ?? undefined;
    this.issueId = data.issueId ?? undefined;
    this.projectUpdateId = data.projectUpdateId ?? undefined;
    this.userId = data.userId ?? undefined;
  }

  /** The body of the comment. */
  public body: string;
  /** The ID of the document content this comment belongs to. */
  public documentContentId?: string;
  /** The ID of the comment. */
  public id: string;
  /** The ID of the initiative update this comment belongs to. */
  public initiativeUpdateId?: string;
  /** The ID of the issue this comment belongs to. */
  public issueId?: string;
  /** The ID of the project update this comment belongs to. */
  public projectUpdateId?: string;
  /** The ID of the user who created this comment. */
  public userId?: string;
}
/**
 * CommentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CommentConnection model
 * @param data - CommentConnection response data
 */
export class CommentConnection extends Connection<Comment> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Comment> | undefined>,
    data: L.CommentConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Comment(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * CommentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CommentPayloadFragment response data
 */
export class CommentPayload extends Request {
  private _comment: L.CommentPayloadFragment["comment"];

  public constructor(request: LinearRequest, data: L.CommentPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._comment = data.comment;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The comment that was created or updated. */
  public get comment(): LinearFetch<Comment> | undefined {
    return new CommentQuery(this._request).fetch({ id: this._comment.id });
  }
  /** The ID of comment that was created or updated. */
  public get commentId(): string | undefined {
    return this._comment?.id;
  }
}
/**
 * Payload for a comment webhook.
 *
 * @param data - L.CommentWebhookPayloadFragment response data
 */
export class CommentWebhookPayload {
  public constructor(data: L.CommentWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.body = data.body;
    this.botActor = data.botActor ?? undefined;
    this.createdAt = data.createdAt;
    this.documentContentId = data.documentContentId ?? undefined;
    this.editedAt = data.editedAt ?? undefined;
    this.externalUserId = data.externalUserId ?? undefined;
    this.id = data.id;
    this.initiativeUpdateId = data.initiativeUpdateId ?? undefined;
    this.issueId = data.issueId ?? undefined;
    this.parentId = data.parentId ?? undefined;
    this.postId = data.postId ?? undefined;
    this.projectUpdateId = data.projectUpdateId ?? undefined;
    this.quotedText = data.quotedText ?? undefined;
    this.reactionData = data.reactionData;
    this.resolvedAt = data.resolvedAt ?? undefined;
    this.resolvingCommentId = data.resolvingCommentId ?? undefined;
    this.resolvingUserId = data.resolvingUserId ?? undefined;
    this.syncedWith = data.syncedWith ?? undefined;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId ?? undefined;
    this.documentContent = data.documentContent
      ? new DocumentContentChildWebhookPayload(data.documentContent)
      : undefined;
    this.externalUser = data.externalUser ? new ExternalUserChildWebhookPayload(data.externalUser) : undefined;
    this.initiativeUpdate = data.initiativeUpdate
      ? new InitiativeUpdateChildWebhookPayload(data.initiativeUpdate)
      : undefined;
    this.issue = data.issue ? new IssueChildWebhookPayload(data.issue) : undefined;
    this.parent = data.parent ? new CommentChildWebhookPayload(data.parent) : undefined;
    this.projectUpdate = data.projectUpdate ? new ProjectUpdateChildWebhookPayload(data.projectUpdate) : undefined;
    this.user = data.user ? new UserChildWebhookPayload(data.user) : undefined;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The body of the comment. */
  public body: string;
  /** The bot actor data for this comment. */
  public botActor?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the document content this comment belongs to. */
  public documentContentId?: string;
  /** When the comment was last edited. */
  public editedAt?: string;
  /** The ID of the external user who created this comment. */
  public externalUserId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the initiative update this comment belongs to. */
  public initiativeUpdateId?: string;
  /** The ID of the issue this comment belongs to. */
  public issueId?: string;
  /** The ID of the parent comment. */
  public parentId?: string;
  /** The ID of the post this comment belongs to. */
  public postId?: string;
  /** The ID of the project update this comment belongs to. */
  public projectUpdateId?: string;
  /** The quoted text in this comment. */
  public quotedText?: string;
  /** The reaction data for this comment. */
  public reactionData: L.Scalars["JSONObject"];
  /** When the comment was resolved. */
  public resolvedAt?: string;
  /** The ID of the comment that resolved this comment. */
  public resolvingCommentId?: string;
  /** The ID of the user who resolved this comment. */
  public resolvingUserId?: string;
  /** The entity this comment is synced with. */
  public syncedWith?: L.Scalars["JSONObject"];
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who created this comment. */
  public userId?: string;
  /** The document content for this comment. */
  public documentContent?: DocumentContentChildWebhookPayload;
  /** The external user who created this comment. */
  public externalUser?: ExternalUserChildWebhookPayload;
  /** The initiative update this comment belongs to. */
  public initiativeUpdate?: InitiativeUpdateChildWebhookPayload;
  /** The issue this comment belongs to. */
  public issue?: IssueChildWebhookPayload;
  /** The parent comment. */
  public parent?: CommentChildWebhookPayload;
  /** The project update this comment belongs to. */
  public projectUpdate?: ProjectUpdateChildWebhookPayload;
  /** The user who created this comment. */
  public user?: UserChildWebhookPayload;
}
/**
 * ContactPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ContactPayloadFragment response data
 */
export class ContactPayload extends Request {
  public constructor(request: LinearRequest, data: L.ContactPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * CreateCsvExportReportPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CreateCsvExportReportPayloadFragment response data
 */
export class CreateCsvExportReportPayload extends Request {
  public constructor(request: LinearRequest, data: L.CreateCsvExportReportPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * CreateOrJoinOrganizationResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.CreateOrJoinOrganizationResponseFragment response data
 */
export class CreateOrJoinOrganizationResponse extends Request {
  public constructor(request: LinearRequest, data: L.CreateOrJoinOrganizationResponseFragment) {
    super(request);
    this.organization = new AuthOrganization(request, data.organization);
    this.user = new AuthUser(request, data.user);
  }

  public organization: AuthOrganization;
  public user: AuthUser;
}
/**
 * Payload for custom webhook resource events.
 *
 * @param data - L.CustomResourceWebhookPayloadFragment response data
 */
export class CustomResourceWebhookPayload {
  public constructor(data: L.CustomResourceWebhookPayloadFragment) {
    this.action = data.action;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.organizationId = data.organizationId;
    this.type = data.type;
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** The type of resource. */
  public type: string;
}
/**
 * A custom view that has been saved by a user.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewFragment response data
 */
export class CustomView extends Request {
  private _creator: L.CustomViewFragment["creator"];
  private _owner: L.CustomViewFragment["owner"];
  private _team?: L.CustomViewFragment["team"];
  private _updatedBy?: L.CustomViewFragment["updatedBy"];

  public constructor(request: LinearRequest, data: L.CustomViewFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.feedItemFilterData = data.feedItemFilterData ?? undefined;
    this.filterData = data.filterData;
    this.filters = data.filters;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.modelName = data.modelName;
    this.name = data.name;
    this.projectFilterData = data.projectFilterData ?? undefined;
    this.shared = data.shared;
    this.slugId = data.slugId ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.organizationViewPreferences = data.organizationViewPreferences
      ? new ViewPreferences(request, data.organizationViewPreferences)
      : undefined;
    this.userViewPreferences = data.userViewPreferences
      ? new ViewPreferences(request, data.userViewPreferences)
      : undefined;
    this.viewPreferencesValues = data.viewPreferencesValues
      ? new ViewPreferencesValues(request, data.viewPreferencesValues)
      : undefined;
    this._creator = data.creator;
    this._owner = data.owner;
    this._team = data.team ?? undefined;
    this._updatedBy = data.updatedBy ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The color of the icon of the custom view. */
  public color?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The description of the custom view. */
  public description?: string;
  /** The filter applied to feed items in the custom view. */
  public feedItemFilterData?: L.Scalars["JSONObject"];
  /** The filter applied to issues in the custom view. */
  public filterData: L.Scalars["JSONObject"];
  /** The filters applied to issues in the custom view. */
  public filters: L.Scalars["JSONObject"];
  /** The icon of the custom view. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The model name of the custom view. */
  public modelName: string;
  /** The name of the custom view. */
  public name: string;
  /** The filter applied to projects in the custom view. */
  public projectFilterData?: L.Scalars["JSONObject"];
  /** Whether the custom view is shared with everyone in the organization. */
  public shared: boolean;
  /** The custom view's unique URL slug. */
  public slugId?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The organizations default view preferences for this custom view. */
  public organizationViewPreferences?: ViewPreferences;
  /** The current users view preferences for this custom view. */
  public userViewPreferences?: ViewPreferences;
  /** The calculated view preferences values for this custom view. */
  public viewPreferencesValues?: ViewPreferencesValues;
  /** The user who created the custom view. */
  public get creator(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._creator.id);
  }
  /** The ID of user who created the custom view. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization of the custom view. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The user who owns the custom view. */
  public get owner(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._owner.id);
  }
  /** The ID of user who owns the custom view. */
  public get ownerId(): string | undefined {
    return this._owner?.id;
  }
  /** The team associated with the custom view. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the custom view. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user who last updated the custom view. */
  public get updatedBy(): LinearFetch<User> | undefined {
    return this._updatedBy?.id ? new UserQuery(this._request).fetch(this._updatedBy?.id) : undefined;
  }
  /** The ID of user who last updated the custom view. */
  public get updatedById(): string | undefined {
    return this._updatedBy?.id;
  }
  /** Issues associated with the custom view. */
  public issues(variables?: Omit<L.CustomView_IssuesQueryVariables, "id">) {
    return new CustomView_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Projects associated with the custom view. */
  public projects(variables?: Omit<L.CustomView_ProjectsQueryVariables, "id">) {
    return new CustomView_ProjectsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new custom view. */
  public create(input: L.CustomViewCreateInput) {
    return new CreateCustomViewMutation(this._request).fetch(input);
  }
  /** Deletes a custom view. */
  public delete() {
    return new DeleteCustomViewMutation(this._request).fetch(this.id);
  }
  /** Updates a custom view. */
  public update(input: L.CustomViewUpdateInput) {
    return new UpdateCustomViewMutation(this._request).fetch(this.id, input);
  }
}
/**
 * CustomViewConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomViewConnection model
 * @param data - CustomViewConnection response data
 */
export class CustomViewConnection extends Connection<CustomView> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomView> | undefined>,
    data: L.CustomViewConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new CustomView(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * CustomViewHasSubscribersPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewHasSubscribersPayloadFragment response data
 */
export class CustomViewHasSubscribersPayload extends Request {
  public constructor(request: LinearRequest, data: L.CustomViewHasSubscribersPayloadFragment) {
    super(request);
    this.hasSubscribers = data.hasSubscribers;
  }

  /** Whether the custom view has subscribers. */
  public hasSubscribers: boolean;
}
/**
 * A custom view notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewNotificationSubscriptionFragment response data
 */
export class CustomViewNotificationSubscription extends Request {
  private _customView: L.CustomViewNotificationSubscriptionFragment["customView"];
  private _customer?: L.CustomViewNotificationSubscriptionFragment["customer"];
  private _cycle?: L.CustomViewNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.CustomViewNotificationSubscriptionFragment["initiative"];
  private _label?: L.CustomViewNotificationSubscriptionFragment["label"];
  private _project?: L.CustomViewNotificationSubscriptionFragment["project"];
  private _subscriber: L.CustomViewNotificationSubscriptionFragment["subscriber"];
  private _team?: L.CustomViewNotificationSubscriptionFragment["team"];
  private _user?: L.CustomViewNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.CustomViewNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The custom view subscribed to. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return new CustomViewQuery(this._request).fetch(this._customView.id);
  }
  /** The ID of custom view subscribed to. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * CustomViewPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewPayloadFragment response data
 */
export class CustomViewPayload extends Request {
  private _customView: L.CustomViewPayloadFragment["customView"];

  public constructor(request: LinearRequest, data: L.CustomViewPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._customView = data.customView;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The custom view that was created or updated. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return new CustomViewQuery(this._request).fetch(this._customView.id);
  }
  /** The ID of custom view that was created or updated. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
}
/**
 * CustomViewSuggestionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomViewSuggestionPayloadFragment response data
 */
export class CustomViewSuggestionPayload extends Request {
  public constructor(request: LinearRequest, data: L.CustomViewSuggestionPayloadFragment) {
    super(request);
    this.description = data.description ?? undefined;
    this.icon = data.icon ?? undefined;
    this.name = data.name ?? undefined;
  }

  /** The suggested view description. */
  public description?: string;
  /** The suggested view icon. */
  public icon?: string;
  /** The suggested view name. */
  public name?: string;
}
/**
 * A customer whose needs will be tied to issues or projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerFragment response data
 */
export class Customer extends Request {
  private _integration?: L.CustomerFragment["integration"];
  private _owner?: L.CustomerFragment["owner"];
  private _status: L.CustomerFragment["status"];
  private _tier?: L.CustomerFragment["tier"];

  public constructor(request: LinearRequest, data: L.CustomerFragment) {
    super(request);
    this.approximateNeedCount = data.approximateNeedCount;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.domains = data.domains;
    this.externalIds = data.externalIds;
    this.id = data.id;
    this.logoUrl = data.logoUrl ?? undefined;
    this.mainSourceId = data.mainSourceId ?? undefined;
    this.name = data.name;
    this.revenue = data.revenue ?? undefined;
    this.size = data.size ?? undefined;
    this.slackChannelId = data.slackChannelId ?? undefined;
    this.slugId = data.slugId;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._integration = data.integration ?? undefined;
    this._owner = data.owner ?? undefined;
    this._status = data.status;
    this._tier = data.tier ?? undefined;
  }

  /** The approximate number of needs of the customer. */
  public approximateNeedCount: number;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The domains associated with this customer. */
  public domains: string[];
  /** The ids of the customers in external systems. */
  public externalIds: string[];
  /** The unique identifier of the entity. */
  public id: string;
  /** The customer's logo URL. */
  public logoUrl?: string;
  /** The ID of the main source, when a customer has multiple sources. Must be one of externalIds. */
  public mainSourceId?: string;
  /** The customer's name. */
  public name: string;
  /** The annual revenue generated by the customer. */
  public revenue?: number;
  /** The size of the customer. */
  public size?: number;
  /** The ID of the Slack channel used to interact with the customer. */
  public slackChannelId?: string;
  /** The customer's unique URL slug. */
  public slugId: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The integration that manages the Customer. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that manages the customer. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
  /** The user who owns the customer. */
  public get owner(): LinearFetch<User> | undefined {
    return this._owner?.id ? new UserQuery(this._request).fetch(this._owner?.id) : undefined;
  }
  /** The ID of user who owns the customer. */
  public get ownerId(): string | undefined {
    return this._owner?.id;
  }
  /** The current status of the customer. */
  public get status(): LinearFetch<CustomerStatus> | undefined {
    return new CustomerStatusQuery(this._request).fetch(this._status.id);
  }
  /** The ID of current status of the customer. */
  public get statusId(): string | undefined {
    return this._status?.id;
  }
  /** The tier of the customer. */
  public get tier(): LinearFetch<CustomerTier> | undefined {
    return this._tier?.id ? new CustomerTierQuery(this._request).fetch(this._tier?.id) : undefined;
  }
  /** The ID of tier of the customer. */
  public get tierId(): string | undefined {
    return this._tier?.id;
  }

  /** Creates a new customer. */
  public create(input: L.CustomerCreateInput) {
    return new CreateCustomerMutation(this._request).fetch(input);
  }
  /** Deletes a customer. */
  public delete() {
    return new DeleteCustomerMutation(this._request).fetch(this.id);
  }
  /** Updates a customer */
  public update(input: L.CustomerUpdateInput) {
    return new UpdateCustomerMutation(this._request).fetch(this.id, input);
  }
}
/**
 * Certain properties of a customer.
 *
 * @param data - L.CustomerChildWebhookPayloadFragment response data
 */
export class CustomerChildWebhookPayload {
  public constructor(data: L.CustomerChildWebhookPayloadFragment) {
    this.domains = data.domains;
    this.externalIds = data.externalIds;
    this.id = data.id;
    this.name = data.name;
  }

  /** The domains associated with this customer. */
  public domains: string[];
  /** The ids of the customers in external systems. */
  public externalIds: string[];
  /** The ID of the customer. */
  public id: string;
  /** The name of the customer. */
  public name: string;
}
/**
 * CustomerConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomerConnection model
 * @param data - CustomerConnection response data
 */
export class CustomerConnection extends Connection<Customer> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Customer> | undefined>,
    data: L.CustomerConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Customer(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A customer need, expressed through a reference to an issue, project, or comment.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNeedFragment response data
 */
export class CustomerNeed extends Request {
  private _attachment?: L.CustomerNeedFragment["attachment"];
  private _comment?: L.CustomerNeedFragment["comment"];
  private _creator?: L.CustomerNeedFragment["creator"];
  private _customer?: L.CustomerNeedFragment["customer"];
  private _issue?: L.CustomerNeedFragment["issue"];
  private _originalIssue?: L.CustomerNeedFragment["originalIssue"];
  private _project?: L.CustomerNeedFragment["project"];

  public constructor(request: LinearRequest, data: L.CustomerNeedFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.body = data.body ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.priority = data.priority;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url ?? undefined;
    this._attachment = data.attachment ?? undefined;
    this._comment = data.comment ?? undefined;
    this._creator = data.creator ?? undefined;
    this._customer = data.customer ?? undefined;
    this._issue = data.issue ?? undefined;
    this._originalIssue = data.originalIssue ?? undefined;
    this._project = data.project ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The need content in markdown format. */
  public body?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the customer need is important or not. 0 = Not important, 1 = Important. */
  public priority: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The URL of the underlying attachment, if any */
  public url?: string;
  /** The attachment this need is referencing. */
  public get attachment(): LinearFetch<Attachment> | undefined {
    return this._attachment?.id ? new AttachmentQuery(this._request).fetch(this._attachment?.id) : undefined;
  }
  /** The ID of attachment this need is referencing. */
  public get attachmentId(): string | undefined {
    return this._attachment?.id;
  }
  /** The comment this need is referencing. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The ID of comment this need is referencing. */
  public get commentId(): string | undefined {
    return this._comment?.id;
  }
  /** The creator of the customer need. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of creator of the customer need. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The customer that this need is attached to. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer that this need is attached to. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The issue this need is referencing. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue this need is referencing. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The issue this customer need was originally created on. Will be undefined if the customer need hasn't been moved. */
  public get originalIssue(): LinearFetch<Issue> | undefined {
    return this._originalIssue?.id ? new IssueQuery(this._request).fetch(this._originalIssue?.id) : undefined;
  }
  /** The ID of issue this customer need was originally created on. will be undefined if the customer need hasn't been moved. */
  public get originalIssueId(): string | undefined {
    return this._originalIssue?.id;
  }
  /** The project this need is referencing. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project this need is referencing. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }

  /** Archives a customer need. */
  public archive() {
    return new ArchiveCustomerNeedMutation(this._request).fetch(this.id);
  }
  /** Creates a new customer need. */
  public create(input: L.CustomerNeedCreateInput) {
    return new CreateCustomerNeedMutation(this._request).fetch(input);
  }
  /** Deletes a customer need. */
  public delete(variables?: Omit<L.DeleteCustomerNeedMutationVariables, "id">) {
    return new DeleteCustomerNeedMutation(this._request).fetch(this.id, variables);
  }
  /** Unarchives a customer need. */
  public unarchive() {
    return new UnarchiveCustomerNeedMutation(this._request).fetch(this.id);
  }
  /** Updates a customer need */
  public update(input: L.CustomerNeedUpdateInput) {
    return new UpdateCustomerNeedMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNeedArchivePayloadFragment response data
 */
export class CustomerNeedArchivePayload extends Request {
  private _entity?: L.CustomerNeedArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.CustomerNeedArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<CustomerNeed> | undefined {
    return this._entity?.id ? new CustomerNeedQuery(this._request).fetch({ id: this._entity?.id }) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a customer need.
 *
 * @param data - L.CustomerNeedChildWebhookPayloadFragment response data
 */
export class CustomerNeedChildWebhookPayload {
  public constructor(data: L.CustomerNeedChildWebhookPayloadFragment) {
    this.attachmentId = data.attachmentId ?? undefined;
    this.customerId = data.customerId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId ?? undefined;
    this.projectId = data.projectId ?? undefined;
  }

  /** The ID of the attachment this need is referencing. */
  public attachmentId?: string;
  /** The ID of the customer that this need is attached to. */
  public customerId?: string;
  /** The ID of the customer need. */
  public id: string;
  /** The ID of the issue this need is referencing. */
  public issueId?: string;
  /** The ID of the project this need is referencing. */
  public projectId?: string;
}
/**
 * CustomerNeedConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomerNeedConnection model
 * @param data - CustomerNeedConnection response data
 */
export class CustomerNeedConnection extends Connection<CustomerNeed> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomerNeed> | undefined>,
    data: L.CustomerNeedConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new CustomerNeed(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A customer need related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNeedNotificationFragment response data
 */
export class CustomerNeedNotification extends Request {
  private _actor?: L.CustomerNeedNotificationFragment["actor"];
  private _customerNeed: L.CustomerNeedNotificationFragment["customerNeed"];
  private _externalUserActor?: L.CustomerNeedNotificationFragment["externalUserActor"];
  private _relatedIssue?: L.CustomerNeedNotificationFragment["relatedIssue"];
  private _relatedProject?: L.CustomerNeedNotificationFragment["relatedProject"];
  private _user: L.CustomerNeedNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.CustomerNeedNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.customerNeedId = data.customerNeedId;
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._customerNeed = data.customerNeed;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._relatedIssue = data.relatedIssue ?? undefined;
    this._relatedProject = data.relatedProject ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Related customer need. */
  public customerNeedId: string;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The customer need related to the notification. */
  public get customerNeed(): LinearFetch<CustomerNeed> | undefined {
    return new CustomerNeedQuery(this._request).fetch({ id: this._customerNeed.id });
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The issue related to the notification. */
  public get relatedIssue(): LinearFetch<Issue> | undefined {
    return this._relatedIssue?.id ? new IssueQuery(this._request).fetch(this._relatedIssue?.id) : undefined;
  }
  /** The ID of issue related to the notification. */
  public get relatedIssueId(): string | undefined {
    return this._relatedIssue?.id;
  }
  /** The project related to the notification. */
  public get relatedProject(): LinearFetch<Project> | undefined {
    return this._relatedProject?.id ? new ProjectQuery(this._request).fetch(this._relatedProject?.id) : undefined;
  }
  /** The ID of project related to the notification. */
  public get relatedProjectId(): string | undefined {
    return this._relatedProject?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * CustomerNeedPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNeedPayloadFragment response data
 */
export class CustomerNeedPayload extends Request {
  private _need: L.CustomerNeedPayloadFragment["need"];

  public constructor(request: LinearRequest, data: L.CustomerNeedPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._need = data.need;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The customer need that was created or updated. */
  public get need(): LinearFetch<CustomerNeed> | undefined {
    return new CustomerNeedQuery(this._request).fetch({ id: this._need.id });
  }
  /** The ID of customer need that was created or updated. */
  public get needId(): string | undefined {
    return this._need?.id;
  }
}
/**
 * CustomerNeedUpdatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNeedUpdatePayloadFragment response data
 */
export class CustomerNeedUpdatePayload extends Request {
  private _need: L.CustomerNeedUpdatePayloadFragment["need"];

  public constructor(request: LinearRequest, data: L.CustomerNeedUpdatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.updatedRelatedNeeds = data.updatedRelatedNeeds.map(node => new CustomerNeed(request, node));
    this._need = data.need;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The related customer needs that were updated. */
  public updatedRelatedNeeds: CustomerNeed[];
  /** The customer need that was created or updated. */
  public get need(): LinearFetch<CustomerNeed> | undefined {
    return new CustomerNeedQuery(this._request).fetch({ id: this._need.id });
  }
  /** The ID of customer need that was created or updated. */
  public get needId(): string | undefined {
    return this._need?.id;
  }
}
/**
 * Payload for a customer need webhook.
 *
 * @param data - L.CustomerNeedWebhookPayloadFragment response data
 */
export class CustomerNeedWebhookPayload {
  public constructor(data: L.CustomerNeedWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.attachmentId = data.attachmentId ?? undefined;
    this.body = data.body ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.customerId = data.customerId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId ?? undefined;
    this.originalIssueId = data.originalIssueId ?? undefined;
    this.priority = data.priority;
    this.projectAttachmentId = data.projectAttachmentId ?? undefined;
    this.projectId = data.projectId ?? undefined;
    this.updatedAt = data.updatedAt;
    this.attachment = data.attachment ? new AttachmentWebhookPayload(data.attachment) : undefined;
    this.customer = data.customer ? new CustomerChildWebhookPayload(data.customer) : undefined;
    this.issue = data.issue ? new IssueChildWebhookPayload(data.issue) : undefined;
    this.project = data.project ? new ProjectChildWebhookPayload(data.project) : undefined;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the attachment this need is referencing. */
  public attachmentId?: string;
  /** The body of the need in Markdown format. */
  public body?: string;
  /** The ID of the comment this need is referencing. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the creator of the customer need. */
  public creatorId?: string;
  /** The ID of the customer that this need is attached to. */
  public customerId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this need is referencing. */
  public issueId?: string;
  /** The issue ID this customer need was originally created on. Will be undefined if the customer need hasn't been moved. */
  public originalIssueId?: string;
  /** The priority of the need. */
  public priority: number;
  /** The ID of the project attachment this need is referencing. */
  public projectAttachmentId?: string;
  /** The ID of the project this need is referencing. */
  public projectId?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The attachment this need is referencing. */
  public attachment?: AttachmentWebhookPayload;
  /** The customer that this need is attached to. */
  public customer?: CustomerChildWebhookPayload;
  /** The issue this need is referencing. */
  public issue?: IssueChildWebhookPayload;
  /** The project this need is referencing. */
  public project?: ProjectChildWebhookPayload;
}
/**
 * A customer related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNotificationFragment response data
 */
export class CustomerNotification extends Request {
  private _actor?: L.CustomerNotificationFragment["actor"];
  private _customer: L.CustomerNotificationFragment["customer"];
  private _externalUserActor?: L.CustomerNotificationFragment["externalUserActor"];
  private _user: L.CustomerNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.CustomerNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.customerId = data.customerId;
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._customer = data.customer;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Related customer. */
  public customerId: string;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The customer related to the notification. */
  public get customer(): LinearFetch<Customer> | undefined {
    return new CustomerQuery(this._request).fetch(this._customer.id);
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * A customer notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerNotificationSubscriptionFragment response data
 */
export class CustomerNotificationSubscription extends Request {
  private _customView?: L.CustomerNotificationSubscriptionFragment["customView"];
  private _customer: L.CustomerNotificationSubscriptionFragment["customer"];
  private _cycle?: L.CustomerNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.CustomerNotificationSubscriptionFragment["initiative"];
  private _label?: L.CustomerNotificationSubscriptionFragment["label"];
  private _project?: L.CustomerNotificationSubscriptionFragment["project"];
  private _subscriber: L.CustomerNotificationSubscriptionFragment["subscriber"];
  private _team?: L.CustomerNotificationSubscriptionFragment["team"];
  private _user?: L.CustomerNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.CustomerNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer subscribed to. */
  public get customer(): LinearFetch<Customer> | undefined {
    return new CustomerQuery(this._request).fetch(this._customer.id);
  }
  /** The ID of customer subscribed to. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * CustomerPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerPayloadFragment response data
 */
export class CustomerPayload extends Request {
  private _customer: L.CustomerPayloadFragment["customer"];

  public constructor(request: LinearRequest, data: L.CustomerPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._customer = data.customer;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The customer that was created or updated. */
  public get customer(): LinearFetch<Customer> | undefined {
    return new CustomerQuery(this._request).fetch(this._customer.id);
  }
  /** The ID of customer that was created or updated. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
}
/**
 * A customer status.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerStatusFragment response data
 */
export class CustomerStatus extends Request {
  public constructor(request: LinearRequest, data: L.CustomerStatusFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.displayName = data.displayName;
    this.id = data.id;
    this.name = data.name;
    this.position = data.position;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.type = data.type ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The UI color of the status as a HEX string. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Description of the status. */
  public description?: string;
  /** The display name of the status. */
  public displayName: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the status. */
  public name: string;
  /** The position of the status in the workspace's customers flow. */
  public position: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of the customer status. */
  public type?: L.CustomerStatusType;

  /** Creates a new customer status. */
  public create(input: L.CustomerStatusCreateInput) {
    return new CreateCustomerStatusMutation(this._request).fetch(input);
  }
  /** Deletes a customer status. */
  public delete() {
    return new DeleteCustomerStatusMutation(this._request).fetch(this.id);
  }
  /** Updates a customer status. */
  public update(input: L.CustomerStatusUpdateInput) {
    return new UpdateCustomerStatusMutation(this._request).fetch(this.id, input);
  }
}
/**
 * Certain properties of a customer status.
 *
 * @param data - L.CustomerStatusChildWebhookPayloadFragment response data
 */
export class CustomerStatusChildWebhookPayload {
  public constructor(data: L.CustomerStatusChildWebhookPayloadFragment) {
    this.id = data.id;
    this.name = data.name;
    this.type = data.type;
  }

  /** The ID of the customer status. */
  public id: string;
  /** The name of the customer status. */
  public name: string;
  /** The type of the customer status. */
  public type: string;
}
/**
 * CustomerStatusConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomerStatusConnection model
 * @param data - CustomerStatusConnection response data
 */
export class CustomerStatusConnection extends Connection<CustomerStatus> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomerStatus> | undefined>,
    data: L.CustomerStatusConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new CustomerStatus(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * CustomerStatusPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerStatusPayloadFragment response data
 */
export class CustomerStatusPayload extends Request {
  private _status: L.CustomerStatusPayloadFragment["status"];

  public constructor(request: LinearRequest, data: L.CustomerStatusPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._status = data.status;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The customer status that was created or updated. */
  public get status(): LinearFetch<CustomerStatus> | undefined {
    return new CustomerStatusQuery(this._request).fetch(this._status.id);
  }
  /** The ID of customer status that was created or updated. */
  public get statusId(): string | undefined {
    return this._status?.id;
  }
}
/**
 * A customer tier.
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerTierFragment response data
 */
export class CustomerTier extends Request {
  public constructor(request: LinearRequest, data: L.CustomerTierFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.displayName = data.displayName;
    this.id = data.id;
    this.name = data.name;
    this.position = data.position;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The UI color of the tier as a HEX string. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Description of the tier. */
  public description?: string;
  /** The display name of the tier. */
  public displayName: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the tier. */
  public name: string;
  /** The position of the tier in the workspace's customers flow. */
  public position: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;

  /** Creates a new customer tier. */
  public create(input: L.CustomerTierCreateInput) {
    return new CreateCustomerTierMutation(this._request).fetch(input);
  }
  /** Deletes a customer tier. */
  public delete() {
    return new DeleteCustomerTierMutation(this._request).fetch(this.id);
  }
  /** Updates a customer tier. */
  public update(input: L.CustomerTierUpdateInput) {
    return new UpdateCustomerTierMutation(this._request).fetch(this.id, input);
  }
}
/**
 * Certain properties of a customer tier.
 *
 * @param data - L.CustomerTierChildWebhookPayloadFragment response data
 */
export class CustomerTierChildWebhookPayload {
  public constructor(data: L.CustomerTierChildWebhookPayloadFragment) {
    this.color = data.color;
    this.displayName = data.displayName;
    this.id = data.id;
    this.name = data.name;
  }

  /** The color of the customer tier. */
  public color: string;
  /** The display name of the customer tier. */
  public displayName: string;
  /** The ID of the customer tier. */
  public id: string;
  /** The name of the customer tier. */
  public name: string;
}
/**
 * CustomerTierConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CustomerTierConnection model
 * @param data - CustomerTierConnection response data
 */
export class CustomerTierConnection extends Connection<CustomerTier> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<CustomerTier> | undefined>,
    data: L.CustomerTierConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new CustomerTier(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * CustomerTierPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CustomerTierPayloadFragment response data
 */
export class CustomerTierPayload extends Request {
  private _tier: L.CustomerTierPayloadFragment["tier"];

  public constructor(request: LinearRequest, data: L.CustomerTierPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._tier = data.tier;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The customer tier that was created or updated. */
  public get tier(): LinearFetch<CustomerTier> | undefined {
    return new CustomerTierQuery(this._request).fetch(this._tier.id);
  }
  /** The ID of customer tier that was created or updated. */
  public get tierId(): string | undefined {
    return this._tier?.id;
  }
}
/**
 * Payload for a customer webhook.
 *
 * @param data - L.CustomerWebhookPayloadFragment response data
 */
export class CustomerWebhookPayload {
  public constructor(data: L.CustomerWebhookPayloadFragment) {
    this.approximateNeedCount = data.approximateNeedCount;
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.domains = data.domains;
    this.externalIds = data.externalIds;
    this.id = data.id;
    this.logoUrl = data.logoUrl ?? undefined;
    this.mainSourceId = data.mainSourceId ?? undefined;
    this.name = data.name;
    this.ownerId = data.ownerId ?? undefined;
    this.revenue = data.revenue ?? undefined;
    this.size = data.size ?? undefined;
    this.slackChannelId = data.slackChannelId ?? undefined;
    this.slugId = data.slugId;
    this.statusId = data.statusId ?? undefined;
    this.tierId = data.tierId ?? undefined;
    this.updatedAt = data.updatedAt;
    this.status = data.status ? new CustomerStatusChildWebhookPayload(data.status) : undefined;
    this.tier = data.tier ? new CustomerTierChildWebhookPayload(data.tier) : undefined;
  }

  /** The approximate number of needs of the customer. */
  public approximateNeedCount: number;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The domains associated with this customer. */
  public domains: string[];
  /** The ids of the customers in external systems. */
  public externalIds: string[];
  /** The ID of the entity. */
  public id: string;
  /** The customer's logo URL. */
  public logoUrl?: string;
  /** The ID of the main source, when a customer has multiple sources. Must be one of externalIds. */
  public mainSourceId?: string;
  /** The name of the customer. */
  public name: string;
  /** The ID of the user who owns the customer. */
  public ownerId?: string;
  /** The annual revenue generated by the customer. */
  public revenue?: number;
  /** The size of the customer. */
  public size?: number;
  /** The ID of the Slack channel used to interact with the customer. */
  public slackChannelId?: string;
  /** The customer's unique URL slug. */
  public slugId: string;
  /** The ID of the customer status. */
  public statusId?: string;
  /** The ID of the customer tier. */
  public tierId?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The customer status. */
  public status?: CustomerStatusChildWebhookPayload;
  /** The customer tier. */
  public tier?: CustomerTierChildWebhookPayload;
}
/**
 * A set of issues to be resolved in a specified amount of time.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleFragment response data
 */
export class Cycle extends Request {
  private _inheritedFrom?: L.CycleFragment["inheritedFrom"];
  private _team: L.CycleFragment["team"];

  public constructor(request: LinearRequest, data: L.CycleFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoArchivedAt = parseDate(data.autoArchivedAt) ?? undefined;
    this.completedAt = parseDate(data.completedAt) ?? undefined;
    this.completedIssueCountHistory = data.completedIssueCountHistory;
    this.completedScopeHistory = data.completedScopeHistory;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.endsAt = parseDate(data.endsAt) ?? new Date();
    this.id = data.id;
    this.inProgressScopeHistory = data.inProgressScopeHistory;
    this.isActive = data.isActive;
    this.isFuture = data.isFuture;
    this.isNext = data.isNext;
    this.isPast = data.isPast;
    this.isPrevious = data.isPrevious;
    this.issueCountHistory = data.issueCountHistory;
    this.name = data.name ?? undefined;
    this.number = data.number;
    this.progress = data.progress;
    this.scopeHistory = data.scopeHistory;
    this.startsAt = parseDate(data.startsAt) ?? new Date();
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._inheritedFrom = data.inheritedFrom ?? undefined;
    this._team = data.team;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the cycle was automatically archived by the auto pruning process. */
  public autoArchivedAt?: Date;
  /** The completion time of the cycle. If null, the cycle hasn't been completed. */
  public completedAt?: Date;
  /** The number of completed issues in the cycle after each day. */
  public completedIssueCountHistory: number[];
  /** The number of completed estimation points after each day. */
  public completedScopeHistory: number[];
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The cycle's description. */
  public description?: string;
  /** The end time of the cycle. */
  public endsAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The number of in progress estimation points after each day. */
  public inProgressScopeHistory: number[];
  /** Whether the cycle is currently active. */
  public isActive: boolean;
  /** Whether the cycle is in the future. */
  public isFuture: boolean;
  /** Whether the cycle is the next cycle for the team. */
  public isNext: boolean;
  /** Whether the cycle is in the past. */
  public isPast: boolean;
  /** Whether the cycle is the previous cycle for the team. */
  public isPrevious: boolean;
  /** The total number of issues in the cycle after each day. */
  public issueCountHistory: number[];
  /** The custom name of the cycle. */
  public name?: string;
  /** The number of the cycle. */
  public number: number;
  /** The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
  public progress: number;
  /** The total number of estimation points after each day. */
  public scopeHistory: number[];
  /** The start time of the cycle. */
  public startsAt: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The cycle inherited from. */
  public get inheritedFrom(): LinearFetch<Cycle> | undefined {
    return this._inheritedFrom?.id ? new CycleQuery(this._request).fetch(this._inheritedFrom?.id) : undefined;
  }
  /** The ID of cycle inherited from. */
  public get inheritedFromId(): string | undefined {
    return this._inheritedFrom?.id;
  }
  /** The team that the cycle is associated with. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team that the cycle is associated with. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** Issues associated with the cycle. */
  public issues(variables?: Omit<L.Cycle_IssuesQueryVariables, "id">) {
    return new Cycle_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Issues that weren't completed when the cycle was closed. */
  public uncompletedIssuesUponClose(variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">) {
    return new Cycle_UncompletedIssuesUponCloseQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives a cycle. */
  public archive() {
    return new ArchiveCycleMutation(this._request).fetch(this.id);
  }
  /** Creates a new cycle. */
  public create(input: L.CycleCreateInput) {
    return new CreateCycleMutation(this._request).fetch(input);
  }
  /** Updates a cycle. */
  public update(input: L.CycleUpdateInput) {
    return new UpdateCycleMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleArchivePayloadFragment response data
 */
export class CycleArchivePayload extends Request {
  private _entity?: L.CycleArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.CycleArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Cycle> | undefined {
    return this._entity?.id ? new CycleQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a cycle.
 *
 * @param data - L.CycleChildWebhookPayloadFragment response data
 */
export class CycleChildWebhookPayload {
  public constructor(data: L.CycleChildWebhookPayloadFragment) {
    this.endsAt = data.endsAt;
    this.id = data.id;
    this.name = data.name ?? undefined;
    this.number = data.number;
    this.startsAt = data.startsAt;
  }

  /** The end date of the cycle. */
  public endsAt: string;
  /** The ID of the cycle. */
  public id: string;
  /** The name of the cycle. */
  public name?: string;
  /** The number of the cycle. */
  public number: number;
  /** The start date of the cycle. */
  public startsAt: string;
}
/**
 * CycleConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this CycleConnection model
 * @param data - CycleConnection response data
 */
export class CycleConnection extends Connection<Cycle> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Cycle> | undefined>,
    data: L.CycleConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Cycle(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A cycle notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.CycleNotificationSubscriptionFragment response data
 */
export class CycleNotificationSubscription extends Request {
  private _customView?: L.CycleNotificationSubscriptionFragment["customView"];
  private _customer?: L.CycleNotificationSubscriptionFragment["customer"];
  private _cycle: L.CycleNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.CycleNotificationSubscriptionFragment["initiative"];
  private _label?: L.CycleNotificationSubscriptionFragment["label"];
  private _project?: L.CycleNotificationSubscriptionFragment["project"];
  private _subscriber: L.CycleNotificationSubscriptionFragment["subscriber"];
  private _team?: L.CycleNotificationSubscriptionFragment["team"];
  private _user?: L.CycleNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.CycleNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The cycle subscribed to. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return new CycleQuery(this._request).fetch(this._cycle.id);
  }
  /** The ID of cycle subscribed to. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * CyclePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.CyclePayloadFragment response data
 */
export class CyclePayload extends Request {
  private _cycle?: L.CyclePayloadFragment["cycle"];

  public constructor(request: LinearRequest, data: L.CyclePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._cycle = data.cycle ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The Cycle that was created or updated. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of cycle that was created or updated. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
}
/**
 * Payload for a cycle webhook.
 *
 * @param data - L.CycleWebhookPayloadFragment response data
 */
export class CycleWebhookPayload {
  public constructor(data: L.CycleWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.autoArchivedAt = data.autoArchivedAt ?? undefined;
    this.completedAt = data.completedAt ?? undefined;
    this.completedIssueCountHistory = data.completedIssueCountHistory;
    this.completedScopeHistory = data.completedScopeHistory;
    this.createdAt = data.createdAt;
    this.description = data.description ?? undefined;
    this.endsAt = data.endsAt;
    this.id = data.id;
    this.inProgressScopeHistory = data.inProgressScopeHistory;
    this.inheritedFromId = data.inheritedFromId ?? undefined;
    this.issueCountHistory = data.issueCountHistory;
    this.name = data.name ?? undefined;
    this.number = data.number;
    this.scopeHistory = data.scopeHistory;
    this.startsAt = data.startsAt;
    this.teamId = data.teamId;
    this.uncompletedIssuesUponCloseIds = data.uncompletedIssuesUponCloseIds;
    this.updatedAt = data.updatedAt;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the cycle was automatically archived by the auto pruning process. */
  public autoArchivedAt?: string;
  /** The completion time of the cycle. If null, the cycle hasn't been completed. */
  public completedAt?: string;
  /** The number of completed issues in the cycle after each day. */
  public completedIssueCountHistory: number[];
  /** The number of completed estimation points after each day. */
  public completedScopeHistory: number[];
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The cycle's description. */
  public description?: string;
  /** The end date of the cycle. */
  public endsAt: string;
  /** The ID of the entity. */
  public id: string;
  /** The number of in progress estimation points after each day. */
  public inProgressScopeHistory: number[];
  /** The ID of the cycle inherited from. */
  public inheritedFromId?: string;
  /** The total number of issues in the cycle after each day. */
  public issueCountHistory: number[];
  /** The name of the cycle. */
  public name?: string;
  /** The number of the cycle. */
  public number: number;
  /** The total number of estimation points after each day. */
  public scopeHistory: number[];
  /** The start date of the cycle. */
  public startsAt: string;
  /** The team ID of the cycle. */
  public teamId: string;
  /** The IDs of the uncompleted issues upon close. */
  public uncompletedIssuesUponCloseIds: string[];
  /** The time at which the entity was updated. */
  public updatedAt: string;
}
/**
 * A generic payload return from entity deletion mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.DeletePayloadFragment response data
 */
export class DeletePayload extends Request {
  public constructor(request: LinearRequest, data: L.DeletePayloadFragment) {
    super(request);
    this.entityId = data.entityId;
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the deleted entity. */
  public entityId: string;
  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * A document that can be attached to different entities.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentFragment response data
 */
export class Document extends Request {
  private _creator?: L.DocumentFragment["creator"];
  private _initiative?: L.DocumentFragment["initiative"];
  private _lastAppliedTemplate?: L.DocumentFragment["lastAppliedTemplate"];
  private _project?: L.DocumentFragment["project"];
  private _updatedBy?: L.DocumentFragment["updatedBy"];

  public constructor(request: LinearRequest, data: L.DocumentFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color ?? undefined;
    this.content = data.content ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.documentContentId = data.documentContentId ?? undefined;
    this.hiddenAt = parseDate(data.hiddenAt) ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.title = data.title;
    this.trashed = data.trashed ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this._creator = data.creator ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._lastAppliedTemplate = data.lastAppliedTemplate ?? undefined;
    this._project = data.project ?? undefined;
    this._updatedBy = data.updatedBy ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The color of the icon. */
  public color?: string;
  /** The documents content in markdown format. */
  public content?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The ID of the document content associated with the document. */
  public documentContentId?: string;
  /** The time at which the document was hidden. Null if the entity has not been hidden. */
  public hiddenAt?: Date;
  /** The icon of the document. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The document's unique URL slug. */
  public slugId: string;
  /** The order of the item in the resources list. */
  public sortOrder: number;
  /** The document title. */
  public title: string;
  /** A flag that indicates whether the document is in the trash bin. */
  public trashed?: boolean;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The canonical url for the document. */
  public url: string;
  /** The user who created the document. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the document. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The initiative that the document is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of initiative that the document is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The last template that was applied to this document. */
  public get lastAppliedTemplate(): LinearFetch<Template> | undefined {
    return this._lastAppliedTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._lastAppliedTemplate?.id)
      : undefined;
  }
  /** The ID of last template that was applied to this document. */
  public get lastAppliedTemplateId(): string | undefined {
    return this._lastAppliedTemplate?.id;
  }
  /** The project that the document is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project that the document is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user who last updated the document. */
  public get updatedBy(): LinearFetch<User> | undefined {
    return this._updatedBy?.id ? new UserQuery(this._request).fetch(this._updatedBy?.id) : undefined;
  }
  /** The ID of user who last updated the document. */
  public get updatedById(): string | undefined {
    return this._updatedBy?.id;
  }
  /** Comments associated with the document. */
  public comments(variables?: Omit<L.Document_CommentsQueryVariables, "id">) {
    return new Document_CommentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new document. */
  public create(input: L.DocumentCreateInput) {
    return new CreateDocumentMutation(this._request).fetch(input);
  }
  /** Deletes (trashes) a document. */
  public delete() {
    return new DeleteDocumentMutation(this._request).fetch(this.id);
  }
  /** Restores a document. */
  public unarchive() {
    return new UnarchiveDocumentMutation(this._request).fetch(this.id);
  }
  /** Updates a document. */
  public update(input: L.DocumentUpdateInput) {
    return new UpdateDocumentMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentArchivePayloadFragment response data
 */
export class DocumentArchivePayload extends Request {
  private _entity?: L.DocumentArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.DocumentArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Document> | undefined {
    return this._entity?.id ? new DocumentQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a document.
 *
 * @param data - L.DocumentChildWebhookPayloadFragment response data
 */
export class DocumentChildWebhookPayload {
  public constructor(data: L.DocumentChildWebhookPayloadFragment) {
    this.id = data.id;
    this.initiativeId = data.initiativeId ?? undefined;
    this.projectId = data.projectId ?? undefined;
    this.title = data.title;
    this.initiative = data.initiative ? new InitiativeChildWebhookPayload(data.initiative) : undefined;
    this.project = data.project ? new ProjectChildWebhookPayload(data.project) : undefined;
  }

  /** The ID of the document. */
  public id: string;
  /** The ID of the initiative this document belongs to. */
  public initiativeId?: string;
  /** The ID of the project this document belongs to. */
  public projectId?: string;
  /** The title of the document. */
  public title: string;
  /** The initiative this document belongs to. */
  public initiative?: InitiativeChildWebhookPayload;
  /** The project this document belongs to. */
  public project?: ProjectChildWebhookPayload;
}
/**
 * DocumentConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this DocumentConnection model
 * @param data - DocumentConnection response data
 */
export class DocumentConnection extends Connection<Document> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Document> | undefined>,
    data: L.DocumentConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Document(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A document content for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentContentFragment response data
 */
export class DocumentContent extends Request {
  private _document?: L.DocumentContentFragment["document"];
  private _initiative?: L.DocumentContentFragment["initiative"];
  private _issue?: L.DocumentContentFragment["issue"];
  private _project?: L.DocumentContentFragment["project"];
  private _projectMilestone?: L.DocumentContentFragment["projectMilestone"];

  public constructor(request: LinearRequest, data: L.DocumentContentFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.content = data.content ?? undefined;
    this.contentState = data.contentState ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.restoredAt = parseDate(data.restoredAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._document = data.document ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._issue = data.issue ?? undefined;
    this._project = data.project ?? undefined;
    this._projectMilestone = data.projectMilestone ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The document content in markdown format. */
  public content?: string;
  /** The document content state as a base64 encoded string. */
  public contentState?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The time at which the document content was restored from a previous version. */
  public restoredAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The document that the content is associated with. */
  public get document(): LinearFetch<Document> | undefined {
    return this._document?.id ? new DocumentQuery(this._request).fetch(this._document?.id) : undefined;
  }
  /** The ID of document that the content is associated with. */
  public get documentId(): string | undefined {
    return this._document?.id;
  }
  /** The initiative that the content is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of initiative that the content is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The issue that the content is associated with. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue that the content is associated with. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The project that the content is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project that the content is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The project milestone that the content is associated with. */
  public get projectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return this._projectMilestone?.id
      ? new ProjectMilestoneQuery(this._request).fetch(this._projectMilestone?.id)
      : undefined;
  }
  /** The ID of project milestone that the content is associated with. */
  public get projectMilestoneId(): string | undefined {
    return this._projectMilestone?.id;
  }
}
/**
 * Certain properties of a document content.
 *
 * @param data - L.DocumentContentChildWebhookPayloadFragment response data
 */
export class DocumentContentChildWebhookPayload {
  public constructor(data: L.DocumentContentChildWebhookPayloadFragment) {
    this.document = data.document ? new DocumentChildWebhookPayload(data.document) : undefined;
    this.project = data.project ? new ProjectChildWebhookPayload(data.project) : undefined;
  }

  /** The document this document content belongs to. */
  public document?: DocumentChildWebhookPayload;
  /** The project this document belongs to. */
  public project?: ProjectChildWebhookPayload;
}
/**
 * DocumentContentHistoryPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentContentHistoryPayloadFragment response data
 */
export class DocumentContentHistoryPayload extends Request {
  public constructor(request: LinearRequest, data: L.DocumentContentHistoryPayloadFragment) {
    super(request);
    this.success = data.success;
    this.history = data.history.map(node => new DocumentContentHistoryType(request, node));
  }

  /** Whether the operation was successful. */
  public success: boolean;
  /** The document content history entries. */
  public history: DocumentContentHistoryType[];
}
/**
 * DocumentContentHistoryType model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentContentHistoryTypeFragment response data
 */
export class DocumentContentHistoryType extends Request {
  public constructor(request: LinearRequest, data: L.DocumentContentHistoryTypeFragment) {
    super(request);
    this.actorIds = data.actorIds ?? undefined;
    this.contentDataSnapshotAt = parseDate(data.contentDataSnapshotAt) ?? new Date();
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
  }

  /** The ID of the author of the change. */
  public actorIds?: string[];
  /** The date when the document content history snapshot was taken. This can be different than createdAt since the content is captured from its state at the previously known updatedAt timestamp in the case of an update. On document create, these timestamps can be the same. */
  public contentDataSnapshotAt: Date;
  /** The date when the document content history entry was created. */
  public createdAt: Date;
  /** The UUID of the document content history entry. */
  public id: string;
}
/**
 * A document related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentNotificationFragment response data
 */
export class DocumentNotification extends Request {
  private _actor?: L.DocumentNotificationFragment["actor"];
  private _externalUserActor?: L.DocumentNotificationFragment["externalUserActor"];
  private _user: L.DocumentNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.DocumentNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.documentId = data.documentId;
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Related comment ID. Null if the notification is not related to a comment. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Related document ID. */
  public documentId: string;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related parent comment ID. Null if the notification is not related to a comment. */
  public parentCommentId?: string;
  /** Name of the reaction emoji related to the notification. */
  public reactionEmoji?: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * DocumentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentPayloadFragment response data
 */
export class DocumentPayload extends Request {
  private _document: L.DocumentPayloadFragment["document"];

  public constructor(request: LinearRequest, data: L.DocumentPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._document = data.document;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The document that was created or updated. */
  public get document(): LinearFetch<Document> | undefined {
    return new DocumentQuery(this._request).fetch(this._document.id);
  }
  /** The ID of document that was created or updated. */
  public get documentId(): string | undefined {
    return this._document?.id;
  }
}
/**
 * DocumentSearchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentSearchPayloadFragment response data
 */
export class DocumentSearchPayload extends Request {
  public constructor(request: LinearRequest, data: L.DocumentSearchPayloadFragment) {
    super(request);
    this.totalCount = data.totalCount;
    this.archivePayload = new ArchiveResponse(request, data.archivePayload);
    this.pageInfo = new PageInfo(request, data.pageInfo);
    this.nodes = data.nodes.map(node => new DocumentSearchResult(request, node));
  }

  /** Total number of results for query without filters applied. */
  public totalCount: number;
  public nodes: DocumentSearchResult[];
  /** Archived entities matching the search term along with all their dependencies. */
  public archivePayload: ArchiveResponse;
  public pageInfo: PageInfo;
}
/**
 * DocumentSearchResult model
 *
 * @param request - function to call the graphql client
 * @param data - L.DocumentSearchResultFragment response data
 */
export class DocumentSearchResult extends Request {
  private _creator?: L.DocumentSearchResultFragment["creator"];
  private _initiative?: L.DocumentSearchResultFragment["initiative"];
  private _lastAppliedTemplate?: L.DocumentSearchResultFragment["lastAppliedTemplate"];
  private _project?: L.DocumentSearchResultFragment["project"];
  private _updatedBy?: L.DocumentSearchResultFragment["updatedBy"];

  public constructor(request: LinearRequest, data: L.DocumentSearchResultFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color ?? undefined;
    this.content = data.content ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.documentContentId = data.documentContentId ?? undefined;
    this.hiddenAt = parseDate(data.hiddenAt) ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.metadata = data.metadata;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.title = data.title;
    this.trashed = data.trashed ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this._creator = data.creator ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._lastAppliedTemplate = data.lastAppliedTemplate ?? undefined;
    this._project = data.project ?? undefined;
    this._updatedBy = data.updatedBy ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The color of the icon. */
  public color?: string;
  /** The documents content in markdown format. */
  public content?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The ID of the document content associated with the document. */
  public documentContentId?: string;
  /** The time at which the document was hidden. Null if the entity has not been hidden. */
  public hiddenAt?: Date;
  /** The icon of the document. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** Metadata related to search result. */
  public metadata: L.Scalars["JSONObject"];
  /** The document's unique URL slug. */
  public slugId: string;
  /** The order of the item in the resources list. */
  public sortOrder: number;
  /** The document title. */
  public title: string;
  /** A flag that indicates whether the document is in the trash bin. */
  public trashed?: boolean;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The canonical url for the document. */
  public url: string;
  /** The user who created the document. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the document. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The initiative that the document is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of initiative that the document is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The last template that was applied to this document. */
  public get lastAppliedTemplate(): LinearFetch<Template> | undefined {
    return this._lastAppliedTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._lastAppliedTemplate?.id)
      : undefined;
  }
  /** The ID of last template that was applied to this document. */
  public get lastAppliedTemplateId(): string | undefined {
    return this._lastAppliedTemplate?.id;
  }
  /** The project that the document is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project that the document is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user who last updated the document. */
  public get updatedBy(): LinearFetch<User> | undefined {
    return this._updatedBy?.id ? new UserQuery(this._request).fetch(this._updatedBy?.id) : undefined;
  }
  /** The ID of user who last updated the document. */
  public get updatedById(): string | undefined {
    return this._updatedBy?.id;
  }
}
/**
 * Payload for a document webhook.
 *
 * @param data - L.DocumentWebhookPayloadFragment response data
 */
export class DocumentWebhookPayload {
  public constructor(data: L.DocumentWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.color = data.color ?? undefined;
    this.content = data.content ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.description = data.description ?? undefined;
    this.hiddenAt = data.hiddenAt ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.initiativeId = data.initiativeId ?? undefined;
    this.lastAppliedTemplateId = data.lastAppliedTemplateId ?? undefined;
    this.projectId = data.projectId ?? undefined;
    this.resourceFolderId = data.resourceFolderId ?? undefined;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.subscriberIds = data.subscriberIds ?? undefined;
    this.title = data.title;
    this.trashed = data.trashed ?? undefined;
    this.updatedAt = data.updatedAt;
    this.updatedById = data.updatedById ?? undefined;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The color of the document. */
  public color?: string;
  /** The content of the document. */
  public content?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the user who created the document. */
  public creatorId?: string;
  /** The description of the document. */
  public description?: string;
  /** The time at which the document was hidden. */
  public hiddenAt?: string;
  /** The icon of the document. */
  public icon?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the initiative this document belongs to. */
  public initiativeId?: string;
  /** The ID of the last template that was applied to this document. */
  public lastAppliedTemplateId?: string;
  /** The ID of the project this document belongs to. */
  public projectId?: string;
  /** The ID of the resource folder this document belongs to. */
  public resourceFolderId?: string;
  /** The document's unique URL slug. */
  public slugId: string;
  /** The order of the item in the resources list. */
  public sortOrder: number;
  /** The IDs of the users who are subscribed to this document. */
  public subscriberIds?: string[];
  /** The title of the document. */
  public title: string;
  /** A flag that indicates whether the document is in the trash bin. */
  public trashed?: boolean;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who last updated the document. */
  public updatedById?: string;
}
/**
 * A general purpose draft. Used for comments, project updates, etc.
 *
 * @param request - function to call the graphql client
 * @param data - L.DraftFragment response data
 */
export class Draft extends Request {
  private _customerNeed?: L.DraftFragment["customerNeed"];
  private _initiative?: L.DraftFragment["initiative"];
  private _initiativeUpdate?: L.DraftFragment["initiativeUpdate"];
  private _issue?: L.DraftFragment["issue"];
  private _parentComment?: L.DraftFragment["parentComment"];
  private _project?: L.DraftFragment["project"];
  private _projectUpdate?: L.DraftFragment["projectUpdate"];
  private _user: L.DraftFragment["user"];

  public constructor(request: LinearRequest, data: L.DraftFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.bodyData = parseJson(data.bodyData) ?? {};
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.data = data.data ?? undefined;
    this.id = data.id;
    this.isAutogenerated = data.isAutogenerated;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._customerNeed = data.customerNeed ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._initiativeUpdate = data.initiativeUpdate ?? undefined;
    this._issue = data.issue ?? undefined;
    this._parentComment = data.parentComment ?? undefined;
    this._project = data.project ?? undefined;
    this._projectUpdate = data.projectUpdate ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The text content as a Prosemirror document. */
  public bodyData: Record<string, unknown>;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Additional properties for the draft. */
  public data?: L.Scalars["JSONObject"];
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the draft was autogenerated for the user. */
  public isAutogenerated: boolean;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The customer need that this draft is referencing. */
  public get customerNeed(): LinearFetch<CustomerNeed> | undefined {
    return this._customerNeed?.id
      ? new CustomerNeedQuery(this._request).fetch({ id: this._customerNeed?.id })
      : undefined;
  }
  /** The ID of customer need that this draft is referencing. */
  public get customerNeedId(): string | undefined {
    return this._customerNeed?.id;
  }
  /** The initiative for which this is a draft initiative update. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of initiative for which this is a draft initiative update. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The initiative update for which this is a draft comment. */
  public get initiativeUpdate(): LinearFetch<InitiativeUpdate> | undefined {
    return this._initiativeUpdate?.id
      ? new InitiativeUpdateQuery(this._request).fetch(this._initiativeUpdate?.id)
      : undefined;
  }
  /** The ID of initiative update for which this is a draft comment. */
  public get initiativeUpdateId(): string | undefined {
    return this._initiativeUpdate?.id;
  }
  /** The issue for which this is a draft comment. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue for which this is a draft comment. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The comment for which this is a draft comment reply. */
  public get parentComment(): LinearFetch<Comment> | undefined {
    return this._parentComment?.id ? new CommentQuery(this._request).fetch({ id: this._parentComment?.id }) : undefined;
  }
  /** The ID of comment for which this is a draft comment reply. */
  public get parentCommentId(): string | undefined {
    return this._parentComment?.id;
  }
  /** The project for which this is a draft project update. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project for which this is a draft project update. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The project update for which this is a draft comment. */
  public get projectUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return this._projectUpdate?.id ? new ProjectUpdateQuery(this._request).fetch(this._projectUpdate?.id) : undefined;
  }
  /** The ID of project update for which this is a draft comment. */
  public get projectUpdateId(): string | undefined {
    return this._projectUpdate?.id;
  }
  /** The user who created the draft. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user who created the draft. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * DraftConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this DraftConnection model
 * @param data - DraftConnection response data
 */
export class DraftConnection extends Connection<Draft> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Draft> | undefined>,
    data: L.DraftConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Draft(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * An email address that can be used for submitting issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailIntakeAddressFragment response data
 */
export class EmailIntakeAddress extends Request {
  private _creator?: L.EmailIntakeAddressFragment["creator"];
  private _team?: L.EmailIntakeAddressFragment["team"];
  private _template?: L.EmailIntakeAddressFragment["template"];

  public constructor(request: LinearRequest, data: L.EmailIntakeAddressFragment) {
    super(request);
    this.address = data.address;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.customerRequestsEnabled = data.customerRequestsEnabled;
    this.enabled = data.enabled;
    this.forwardingEmailAddress = data.forwardingEmailAddress ?? undefined;
    this.id = data.id;
    this.repliesEnabled = data.repliesEnabled;
    this.senderName = data.senderName ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.sesDomainIdentity = data.sesDomainIdentity
      ? new SesDomainIdentity(request, data.sesDomainIdentity)
      : undefined;
    this.type = data.type;
    this._creator = data.creator ?? undefined;
    this._team = data.team ?? undefined;
    this._template = data.template ?? undefined;
  }

  /** Unique email address user name (before @) used for incoming email. */
  public address: string;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Whether issues created from that email address will be turned into customer requests. */
  public customerRequestsEnabled: boolean;
  /** Whether the email address is enabled. */
  public enabled: boolean;
  /** The email address used to forward emails to the intake address. */
  public forwardingEmailAddress?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether email replies are enabled. */
  public repliesEnabled: boolean;
  /** The name to be used for outgoing emails. */
  public senderName?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The SES domain identity that the email address is associated with. */
  public sesDomainIdentity?: SesDomainIdentity;
  /** The type of the email address. */
  public type: L.EmailIntakeAddressType;
  /** The user who created the email intake address. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the email intake address. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization that the email address is associated with. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The team that the email address is associated with. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team that the email address is associated with. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The template that the email address is associated with. */
  public get template(): LinearFetch<Template> | undefined {
    return this._template?.id ? new TemplateQuery(this._request).fetch(this._template?.id) : undefined;
  }
  /** The ID of template that the email address is associated with. */
  public get templateId(): string | undefined {
    return this._template?.id;
  }

  /** Creates a new email intake address. */
  public create(input: L.EmailIntakeAddressCreateInput) {
    return new CreateEmailIntakeAddressMutation(this._request).fetch(input);
  }
  /** Deletes an email intake address object. */
  public delete() {
    return new DeleteEmailIntakeAddressMutation(this._request).fetch(this.id);
  }
  /** Updates an existing email intake address. */
  public update(input: L.EmailIntakeAddressUpdateInput) {
    return new UpdateEmailIntakeAddressMutation(this._request).fetch(this.id, input);
  }
}
/**
 * EmailIntakeAddressPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailIntakeAddressPayloadFragment response data
 */
export class EmailIntakeAddressPayload extends Request {
  private _emailIntakeAddress: L.EmailIntakeAddressPayloadFragment["emailIntakeAddress"];

  public constructor(request: LinearRequest, data: L.EmailIntakeAddressPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._emailIntakeAddress = data.emailIntakeAddress;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The email address that was created or updated. */
  public get emailIntakeAddress(): LinearFetch<EmailIntakeAddress> | undefined {
    return new EmailIntakeAddressQuery(this._request).fetch(this._emailIntakeAddress.id);
  }
  /** The ID of email address that was created or updated. */
  public get emailIntakeAddressId(): string | undefined {
    return this._emailIntakeAddress?.id;
  }
}
/**
 * EmailUnsubscribePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailUnsubscribePayloadFragment response data
 */
export class EmailUnsubscribePayload extends Request {
  public constructor(request: LinearRequest, data: L.EmailUnsubscribePayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * EmailUserAccountAuthChallengeResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmailUserAccountAuthChallengeResponseFragment response data
 */
export class EmailUserAccountAuthChallengeResponse extends Request {
  public constructor(request: LinearRequest, data: L.EmailUserAccountAuthChallengeResponseFragment) {
    super(request);
    this.authType = data.authType;
    this.success = data.success;
  }

  /** Supported challenge for this user account. Can be either verificationCode or password. */
  public authType: string;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * A custom emoji.
 *
 * @param request - function to call the graphql client
 * @param data - L.EmojiFragment response data
 */
export class Emoji extends Request {
  private _creator?: L.EmojiFragment["creator"];

  public constructor(request: LinearRequest, data: L.EmojiFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.name = data.name;
    this.source = data.source;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this._creator = data.creator ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The emoji's name. */
  public name: string;
  /** The source of the emoji. */
  public source: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The emoji image URL. */
  public url: string;
  /** The user who created the emoji. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the emoji. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization that the emoji belongs to. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }

  /** Creates a custom emoji. */
  public create(input: L.EmojiCreateInput) {
    return new CreateEmojiMutation(this._request).fetch(input);
  }
  /** Deletes an emoji. */
  public delete() {
    return new DeleteEmojiMutation(this._request).fetch(this.id);
  }
}
/**
 * EmojiConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this EmojiConnection model
 * @param data - EmojiConnection response data
 */
export class EmojiConnection extends Connection<Emoji> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Emoji> | undefined>,
    data: L.EmojiConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Emoji(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * EmojiPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EmojiPayloadFragment response data
 */
export class EmojiPayload extends Request {
  private _emoji: L.EmojiPayloadFragment["emoji"];

  public constructor(request: LinearRequest, data: L.EmojiPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._emoji = data.emoji;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The emoji that was created. */
  public get emoji(): LinearFetch<Emoji> | undefined {
    return new EmojiQuery(this._request).fetch(this._emoji.id);
  }
  /** The ID of emoji that was created. */
  public get emojiId(): string | undefined {
    return this._emoji?.id;
  }
}
/**
 * A basic entity.
 *
 * @param request - function to call the graphql client
 * @param data - L.EntityFragment response data
 */
export class Entity extends Request {
  public constructor(request: LinearRequest, data: L.EntityFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
}
/**
 * An external link for an entity like initiative, etc...
 *
 * @param request - function to call the graphql client
 * @param data - L.EntityExternalLinkFragment response data
 */
export class EntityExternalLink extends Request {
  private _creator: L.EntityExternalLinkFragment["creator"];
  private _initiative?: L.EntityExternalLinkFragment["initiative"];

  public constructor(request: LinearRequest, data: L.EntityExternalLinkFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.label = data.label;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this._creator = data.creator;
    this._initiative = data.initiative ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The link's label. */
  public label: string;
  /** The order of the item in the resources list. */
  public sortOrder: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The link's URL. */
  public url: string;
  /** The user who created the link. */
  public get creator(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._creator.id);
  }
  /** The ID of user who created the link. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The initiative that the link is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of initiative that the link is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }

  /** Creates a new entity link. */
  public create(input: L.EntityExternalLinkCreateInput) {
    return new CreateEntityExternalLinkMutation(this._request).fetch(input);
  }
  /** Deletes an entity link. */
  public delete() {
    return new DeleteEntityExternalLinkMutation(this._request).fetch(this.id);
  }
  /** Updates an entity link. */
  public update(input: L.EntityExternalLinkUpdateInput) {
    return new UpdateEntityExternalLinkMutation(this._request).fetch(this.id, input);
  }
}
/**
 * EntityExternalLinkConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this EntityExternalLinkConnection model
 * @param data - EntityExternalLinkConnection response data
 */
export class EntityExternalLinkConnection extends Connection<EntityExternalLink> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<EntityExternalLink> | undefined>,
    data: L.EntityExternalLinkConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new EntityExternalLink(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * EntityExternalLinkPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.EntityExternalLinkPayloadFragment response data
 */
export class EntityExternalLinkPayload extends Request {
  private _entityExternalLink: L.EntityExternalLinkPayloadFragment["entityExternalLink"];

  public constructor(request: LinearRequest, data: L.EntityExternalLinkPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entityExternalLink = data.entityExternalLink;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The link that was created or updated. */
  public get entityExternalLink(): LinearFetch<EntityExternalLink> | undefined {
    return new EntityExternalLinkQuery(this._request).fetch(this._entityExternalLink.id);
  }
  /** The ID of link that was created or updated. */
  public get entityExternalLinkId(): string | undefined {
    return this._entityExternalLink?.id;
  }
}
/**
 * Payload for entity-related webhook events.
 *
 * @param data - L.EntityWebhookPayloadFragment response data
 */
export class EntityWebhookPayload {
  public constructor(data: L.EntityWebhookPayloadFragment) {
    this.action = data.action;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.organizationId = data.organizationId;
    this.type = data.type;
    this.updatedFrom = data.updatedFrom ?? undefined;
    this.url = data.url ?? undefined;
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** The type of resource, i.e., the name of the entity. */
  public type: string;
  /** In case of an update event, previous values of all updated properties. */
  public updatedFrom?: L.Scalars["JSONObject"];
  /** URL for the entity. */
  public url?: string;
}
/**
 * Information about an external entity.
 *
 * @param request - function to call the graphql client
 * @param data - L.ExternalEntityInfoFragment response data
 */
export class ExternalEntityInfo extends Request {
  public constructor(request: LinearRequest, data: L.ExternalEntityInfoFragment) {
    super(request);
    this.id = data.id;
    this.service = data.service;
    this.metadata = data.metadata ?? undefined;
  }

  /** The id of the external entity. */
  public id: string;
  /** The name of the service this entity is synced with. */
  public service: L.ExternalSyncService;
  /** Metadata about the external entity. */
  public metadata?: L.ExternalEntityInfoMetadata;
}
/**
 * Metadata about the external GitHub entity.
 *
 * @param request - function to call the graphql client
 * @param data - L.ExternalEntityInfoGithubMetadataFragment response data
 */
export class ExternalEntityInfoGithubMetadata extends Request {
  public constructor(request: LinearRequest, data: L.ExternalEntityInfoGithubMetadataFragment) {
    super(request);
    this.number = data.number ?? undefined;
    this.owner = data.owner ?? undefined;
    this.repo = data.repo ?? undefined;
  }

  /** The number of the issue. */
  public number?: number;
  /** The owner of the repository. */
  public owner?: string;
  /** The repository name. */
  public repo?: string;
}
/**
 * Metadata about the external Jira entity.
 *
 * @param request - function to call the graphql client
 * @param data - L.ExternalEntityInfoJiraMetadataFragment response data
 */
export class ExternalEntityInfoJiraMetadata extends Request {
  public constructor(request: LinearRequest, data: L.ExternalEntityInfoJiraMetadataFragment) {
    super(request);
    this.issueKey = data.issueKey ?? undefined;
    this.issueTypeId = data.issueTypeId ?? undefined;
    this.projectId = data.projectId ?? undefined;
  }

  /** The key of the Jira issue. */
  public issueKey?: string;
  /** The id of the Jira issue type. */
  public issueTypeId?: string;
  /** The id of the Jira project. */
  public projectId?: string;
}
/**
 * Metadata about the external Slack entity.
 *
 * @param request - function to call the graphql client
 * @param data - L.ExternalEntitySlackMetadataFragment response data
 */
export class ExternalEntitySlackMetadata extends Request {
  public constructor(request: LinearRequest, data: L.ExternalEntitySlackMetadataFragment) {
    super(request);
    this.channelId = data.channelId ?? undefined;
    this.channelName = data.channelName ?? undefined;
    this.isFromSlack = data.isFromSlack;
    this.messageUrl = data.messageUrl ?? undefined;
  }

  /** The id of the Slack channel. */
  public channelId?: string;
  /** The name of the Slack channel. */
  public channelName?: string;
  /** Whether the entity originated from Slack (not Linear). */
  public isFromSlack: boolean;
  /** The URL of the Slack message. */
  public messageUrl?: string;
}
/**
 * An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can create and update entities in Linear from the external system that authenticated them.
 *
 * @param request - function to call the graphql client
 * @param data - L.ExternalUserFragment response data
 */
export class ExternalUser extends Request {
  public constructor(request: LinearRequest, data: L.ExternalUserFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.avatarUrl = data.avatarUrl ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.displayName = data.displayName;
    this.email = data.email ?? undefined;
    this.id = data.id;
    this.lastSeen = parseDate(data.lastSeen) ?? undefined;
    this.name = data.name;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** An URL to the external user's avatar image. */
  public avatarUrl?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The external user's display name. Unique within each organization. Can match the display name of an actual user. */
  public displayName: string;
  /** The external user's email address. */
  public email?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The last time the external user was seen interacting with Linear. */
  public lastSeen?: Date;
  /** The external user's full name. */
  public name: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Organization the external user belongs to. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
}
/**
 * Certain properties of an external user.
 *
 * @param data - L.ExternalUserChildWebhookPayloadFragment response data
 */
export class ExternalUserChildWebhookPayload {
  public constructor(data: L.ExternalUserChildWebhookPayloadFragment) {
    this.email = data.email;
    this.id = data.id;
    this.name = data.name;
  }

  /** The email of the external user. */
  public email: string;
  /** The ID of the external user. */
  public id: string;
  /** The name of the external user. */
  public name: string;
}
/**
 * ExternalUserConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ExternalUserConnection model
 * @param data - ExternalUserConnection response data
 */
export class ExternalUserConnection extends Connection<ExternalUser> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ExternalUser> | undefined>,
    data: L.ExternalUserConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ExternalUser(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A facet. Facets are joins between entities. A facet can tie a custom view to a project, or a a project to a roadmap for example.
 *
 * @param request - function to call the graphql client
 * @param data - L.FacetFragment response data
 */
export class Facet extends Request {
  private _sourceFeedUser?: L.FacetFragment["sourceFeedUser"];
  private _sourceInitiative?: L.FacetFragment["sourceInitiative"];
  private _sourceProject?: L.FacetFragment["sourceProject"];
  private _sourceTeam?: L.FacetFragment["sourceTeam"];
  private _targetCustomView?: L.FacetFragment["targetCustomView"];

  public constructor(request: LinearRequest, data: L.FacetFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.sourcePage = data.sourcePage ?? undefined;
    this._sourceFeedUser = data.sourceFeedUser ?? undefined;
    this._sourceInitiative = data.sourceInitiative ?? undefined;
    this._sourceProject = data.sourceProject ?? undefined;
    this._sourceTeam = data.sourceTeam ?? undefined;
    this._targetCustomView = data.targetCustomView ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The sort order of the facet. */
  public sortOrder: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The owning page. */
  public sourcePage?: L.FacetPageSource;
  /** The owning feed user. */
  public get sourceFeedUser(): LinearFetch<User> | undefined {
    return this._sourceFeedUser?.id ? new UserQuery(this._request).fetch(this._sourceFeedUser?.id) : undefined;
  }
  /** The ID of owning feed user. */
  public get sourceFeedUserId(): string | undefined {
    return this._sourceFeedUser?.id;
  }
  /** The owning initiative. */
  public get sourceInitiative(): LinearFetch<Initiative> | undefined {
    return this._sourceInitiative?.id
      ? new InitiativeQuery(this._request).fetch(this._sourceInitiative?.id)
      : undefined;
  }
  /** The ID of owning initiative. */
  public get sourceInitiativeId(): string | undefined {
    return this._sourceInitiative?.id;
  }
  /** The owning organization. */
  public get sourceOrganization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The owning project. */
  public get sourceProject(): LinearFetch<Project> | undefined {
    return this._sourceProject?.id ? new ProjectQuery(this._request).fetch(this._sourceProject?.id) : undefined;
  }
  /** The ID of owning project. */
  public get sourceProjectId(): string | undefined {
    return this._sourceProject?.id;
  }
  /** The owning team. */
  public get sourceTeam(): LinearFetch<Team> | undefined {
    return this._sourceTeam?.id ? new TeamQuery(this._request).fetch(this._sourceTeam?.id) : undefined;
  }
  /** The ID of owning team. */
  public get sourceTeamId(): string | undefined {
    return this._sourceTeam?.id;
  }
  /** The targeted custom view. */
  public get targetCustomView(): LinearFetch<CustomView> | undefined {
    return this._targetCustomView?.id
      ? new CustomViewQuery(this._request).fetch(this._targetCustomView?.id)
      : undefined;
  }
  /** The ID of targeted custom view. */
  public get targetCustomViewId(): string | undefined {
    return this._targetCustomView?.id;
  }
}
/**
 * User favorites presented in the sidebar.
 *
 * @param request - function to call the graphql client
 * @param data - L.FavoriteFragment response data
 */
export class Favorite extends Request {
  private _customView?: L.FavoriteFragment["customView"];
  private _customer?: L.FavoriteFragment["customer"];
  private _cycle?: L.FavoriteFragment["cycle"];
  private _document?: L.FavoriteFragment["document"];
  private _initiative?: L.FavoriteFragment["initiative"];
  private _issue?: L.FavoriteFragment["issue"];
  private _label?: L.FavoriteFragment["label"];
  private _owner: L.FavoriteFragment["owner"];
  private _parent?: L.FavoriteFragment["parent"];
  private _predefinedViewTeam?: L.FavoriteFragment["predefinedViewTeam"];
  private _project?: L.FavoriteFragment["project"];
  private _projectLabel?: L.FavoriteFragment["projectLabel"];
  private _projectTeam?: L.FavoriteFragment["projectTeam"];
  private _roadmap?: L.FavoriteFragment["roadmap"];
  private _user?: L.FavoriteFragment["user"];

  public constructor(request: LinearRequest, data: L.FavoriteFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.folderName = data.folderName ?? undefined;
    this.id = data.id;
    this.predefinedViewType = data.predefinedViewType ?? undefined;
    this.sortOrder = data.sortOrder;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url ?? undefined;
    this.initiativeTab = data.initiativeTab ?? undefined;
    this.projectTab = data.projectTab ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._document = data.document ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._issue = data.issue ?? undefined;
    this._label = data.label ?? undefined;
    this._owner = data.owner;
    this._parent = data.parent ?? undefined;
    this._predefinedViewTeam = data.predefinedViewTeam ?? undefined;
    this._project = data.project ?? undefined;
    this._projectLabel = data.projectLabel ?? undefined;
    this._projectTeam = data.projectTeam ?? undefined;
    this._roadmap = data.roadmap ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The name of the folder. Only applies to favorites of type folder. */
  public folderName?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of favorited predefined view. */
  public predefinedViewType?: string;
  /** The order of the item in the favorites list. */
  public sortOrder: number;
  /** The type of the favorite. */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** URL of the favorited entity. Folders return 'null' value. */
  public url?: string;
  /** The targeted tab of the initiative. */
  public initiativeTab?: L.InitiativeTab;
  /** The targeted tab of the project. */
  public projectTab?: L.ProjectTab;
  /** The favorited custom view. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of favorited custom view. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The favorited customer. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of favorited customer. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The favorited cycle. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of favorited cycle. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The favorited document. */
  public get document(): LinearFetch<Document> | undefined {
    return this._document?.id ? new DocumentQuery(this._request).fetch(this._document?.id) : undefined;
  }
  /** The ID of favorited document. */
  public get documentId(): string | undefined {
    return this._document?.id;
  }
  /** The favorited initiative. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of favorited initiative. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The favorited issue. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of favorited issue. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The favorited label. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of favorited label. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The owner of the favorite. */
  public get owner(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._owner.id);
  }
  /** The ID of owner of the favorite. */
  public get ownerId(): string | undefined {
    return this._owner?.id;
  }
  /** The parent folder of the favorite. */
  public get parent(): LinearFetch<Favorite> | undefined {
    return this._parent?.id ? new FavoriteQuery(this._request).fetch(this._parent?.id) : undefined;
  }
  /** The ID of parent folder of the favorite. */
  public get parentId(): string | undefined {
    return this._parent?.id;
  }
  /** The team of the favorited predefined view. */
  public get predefinedViewTeam(): LinearFetch<Team> | undefined {
    return this._predefinedViewTeam?.id ? new TeamQuery(this._request).fetch(this._predefinedViewTeam?.id) : undefined;
  }
  /** The ID of team of the favorited predefined view. */
  public get predefinedViewTeamId(): string | undefined {
    return this._predefinedViewTeam?.id;
  }
  /** The favorited project. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of favorited project. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The favorited project label. */
  public get projectLabel(): LinearFetch<ProjectLabel> | undefined {
    return this._projectLabel?.id ? new ProjectLabelQuery(this._request).fetch(this._projectLabel?.id) : undefined;
  }
  /** The ID of favorited project label. */
  public get projectLabelId(): string | undefined {
    return this._projectLabel?.id;
  }
  /** [DEPRECATED] The favorited team of the project. */
  public get projectTeam(): LinearFetch<Team> | undefined {
    return this._projectTeam?.id ? new TeamQuery(this._request).fetch(this._projectTeam?.id) : undefined;
  }
  /** The ID of [deprecated] the favorited team of the project. */
  public get projectTeamId(): string | undefined {
    return this._projectTeam?.id;
  }
  /** The favorited roadmap. */
  public get roadmap(): LinearFetch<Roadmap> | undefined {
    return this._roadmap?.id ? new RoadmapQuery(this._request).fetch(this._roadmap?.id) : undefined;
  }
  /** The ID of favorited roadmap. */
  public get roadmapId(): string | undefined {
    return this._roadmap?.id;
  }
  /** The favorited user. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of favorited user. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
  /** Children of the favorite. Only applies to favorites of type folder. */
  public children(variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">) {
    return new Favorite_ChildrenQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new favorite (project, cycle etc). */
  public create(input: L.FavoriteCreateInput) {
    return new CreateFavoriteMutation(this._request).fetch(input);
  }
  /** Deletes a favorite reference. */
  public delete() {
    return new DeleteFavoriteMutation(this._request).fetch(this.id);
  }
  /** Updates a favorite. */
  public update(input: L.FavoriteUpdateInput) {
    return new UpdateFavoriteMutation(this._request).fetch(this.id, input);
  }
}
/**
 * FavoriteConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this FavoriteConnection model
 * @param data - FavoriteConnection response data
 */
export class FavoriteConnection extends Connection<Favorite> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Favorite> | undefined>,
    data: L.FavoriteConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Favorite(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * FavoritePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FavoritePayloadFragment response data
 */
export class FavoritePayload extends Request {
  private _favorite: L.FavoritePayloadFragment["favorite"];

  public constructor(request: LinearRequest, data: L.FavoritePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._favorite = data.favorite;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The object that was added as a favorite. */
  public get favorite(): LinearFetch<Favorite> | undefined {
    return new FavoriteQuery(this._request).fetch(this._favorite.id);
  }
  /** The ID of object that was added as a favorite. */
  public get favoriteId(): string | undefined {
    return this._favorite?.id;
  }
}
/**
 * FrontAttachmentPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.FrontAttachmentPayloadFragment response data
 */
export class FrontAttachmentPayload extends Request {
  private _attachment: L.FrontAttachmentPayloadFragment["attachment"];

  public constructor(request: LinearRequest, data: L.FrontAttachmentPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._attachment = data.attachment;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The issue attachment that was created. */
  public get attachment(): LinearFetch<Attachment> | undefined {
    return new AttachmentQuery(this._request).fetch(this._attachment.id);
  }
  /** The ID of issue attachment that was created. */
  public get attachmentId(): string | undefined {
    return this._attachment?.id;
  }
}
/**
 * A trigger that updates the issue status according to Git automations.
 *
 * @param request - function to call the graphql client
 * @param data - L.GitAutomationStateFragment response data
 */
export class GitAutomationState extends Request {
  private _state?: L.GitAutomationStateFragment["state"];
  private _team: L.GitAutomationStateFragment["team"];

  public constructor(request: LinearRequest, data: L.GitAutomationStateFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.branchPattern = data.branchPattern ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.targetBranch = data.targetBranch ? new GitAutomationTargetBranch(request, data.targetBranch) : undefined;
    this.event = data.event;
    this._state = data.state ?? undefined;
    this._team = data.team;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** [DEPRECATED] The target branch, if null, the automation will be triggered on any branch. */
  public branchPattern?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The target branch associated to this automation state. */
  public targetBranch?: GitAutomationTargetBranch;
  /** The event that triggers the automation. */
  public event: L.GitAutomationStates;
  /** The associated workflow state. */
  public get state(): LinearFetch<WorkflowState> | undefined {
    return this._state?.id ? new WorkflowStateQuery(this._request).fetch(this._state?.id) : undefined;
  }
  /** The ID of associated workflow state. */
  public get stateId(): string | undefined {
    return this._state?.id;
  }
  /** The team to which this automation state belongs. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team to which this automation state belongs. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }

  /** Creates a new automation state. */
  public create(input: L.GitAutomationStateCreateInput) {
    return new CreateGitAutomationStateMutation(this._request).fetch(input);
  }
  /** Archives an automation state. */
  public delete() {
    return new DeleteGitAutomationStateMutation(this._request).fetch(this.id);
  }
  /** Updates an existing state. */
  public update(input: L.GitAutomationStateUpdateInput) {
    return new UpdateGitAutomationStateMutation(this._request).fetch(this.id, input);
  }
}
/**
 * GitAutomationStateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this GitAutomationStateConnection model
 * @param data - GitAutomationStateConnection response data
 */
export class GitAutomationStateConnection extends Connection<GitAutomationState> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<GitAutomationState> | undefined>,
    data: L.GitAutomationStateConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new GitAutomationState(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * GitAutomationStatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitAutomationStatePayloadFragment response data
 */
export class GitAutomationStatePayload extends Request {
  public constructor(request: LinearRequest, data: L.GitAutomationStatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.gitAutomationState = new GitAutomationState(request, data.gitAutomationState);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The automation state that was created or updated. */
  public gitAutomationState: GitAutomationState;
}
/**
 * A Git target branch for which there are automations (GitAutomationState).
 *
 * @param request - function to call the graphql client
 * @param data - L.GitAutomationTargetBranchFragment response data
 */
export class GitAutomationTargetBranch extends Request {
  private _team: L.GitAutomationTargetBranchFragment["team"];

  public constructor(request: LinearRequest, data: L.GitAutomationTargetBranchFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.branchPattern = data.branchPattern;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.isRegex = data.isRegex;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._team = data.team;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The target branch pattern. */
  public branchPattern: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the branch pattern is a regular expression. */
  public isRegex: boolean;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The team to which this Git target branch automation belongs. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team to which this git target branch automation belongs. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }

  /** Creates a Git target branch automation. */
  public create(input: L.GitAutomationTargetBranchCreateInput) {
    return new CreateGitAutomationTargetBranchMutation(this._request).fetch(input);
  }
  /** Archives a Git target branch automation. */
  public delete() {
    return new DeleteGitAutomationTargetBranchMutation(this._request).fetch(this.id);
  }
  /** Updates an existing Git target branch automation. */
  public update(input: L.GitAutomationTargetBranchUpdateInput) {
    return new UpdateGitAutomationTargetBranchMutation(this._request).fetch(this.id, input);
  }
}
/**
 * GitAutomationTargetBranchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitAutomationTargetBranchPayloadFragment response data
 */
export class GitAutomationTargetBranchPayload extends Request {
  public constructor(request: LinearRequest, data: L.GitAutomationTargetBranchPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.targetBranch = new GitAutomationTargetBranch(request, data.targetBranch);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The Git target branch automation that was created or updated. */
  public targetBranch: GitAutomationTargetBranch;
}
/**
 * GitHubCommitIntegrationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitHubCommitIntegrationPayloadFragment response data
 */
export class GitHubCommitIntegrationPayload extends Request {
  private _integration?: L.GitHubCommitIntegrationPayloadFragment["integration"];

  public constructor(request: LinearRequest, data: L.GitHubCommitIntegrationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.webhookSecret = data.webhookSecret;
    this._integration = data.integration ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The webhook secret to provide to GitHub. */
  public webhookSecret: string;
  /** The integration that was created or updated. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that was created or updated. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
}
/**
 * GitHubEnterpriseServerInstallVerificationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitHubEnterpriseServerInstallVerificationPayloadFragment response data
 */
export class GitHubEnterpriseServerInstallVerificationPayload extends Request {
  public constructor(request: LinearRequest, data: L.GitHubEnterpriseServerInstallVerificationPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Has the install been successful. */
  public success: boolean;
}
/**
 * GitHubEnterpriseServerPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitHubEnterpriseServerPayloadFragment response data
 */
export class GitHubEnterpriseServerPayload extends Request {
  private _integration?: L.GitHubEnterpriseServerPayloadFragment["integration"];

  public constructor(request: LinearRequest, data: L.GitHubEnterpriseServerPayloadFragment) {
    super(request);
    this.installUrl = data.installUrl;
    this.lastSyncId = data.lastSyncId;
    this.setupUrl = data.setupUrl;
    this.success = data.success;
    this.webhookSecret = data.webhookSecret;
    this._integration = data.integration ?? undefined;
  }

  /** The app install address. */
  public installUrl: string;
  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** The setup address. */
  public setupUrl: string;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The webhook secret to provide to GitHub. */
  public webhookSecret: string;
  /** The integration that was created or updated. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that was created or updated. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
}
/**
 * GitLabIntegrationCreatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.GitLabIntegrationCreatePayloadFragment response data
 */
export class GitLabIntegrationCreatePayload extends Request {
  private _integration?: L.GitLabIntegrationCreatePayloadFragment["integration"];

  public constructor(request: LinearRequest, data: L.GitLabIntegrationCreatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.webhookSecret = data.webhookSecret;
    this._integration = data.integration ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The webhook secret to provide to GitLab. */
  public webhookSecret: string;
  /** The integration that was created or updated. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that was created or updated. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
}
/**
 * ImageUploadFromUrlPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ImageUploadFromUrlPayloadFragment response data
 */
export class ImageUploadFromUrlPayload extends Request {
  public constructor(request: LinearRequest, data: L.ImageUploadFromUrlPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.url = data.url ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The URL containing the image. */
  public url?: string;
}
/**
 * An initiative to group projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeFragment response data
 */
export class Initiative extends Request {
  private _creator?: L.InitiativeFragment["creator"];
  private _integrationsSettings?: L.InitiativeFragment["integrationsSettings"];
  private _lastUpdate?: L.InitiativeFragment["lastUpdate"];
  private _owner?: L.InitiativeFragment["owner"];
  private _parentInitiative?: L.InitiativeFragment["parentInitiative"];

  public constructor(request: LinearRequest, data: L.InitiativeFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color ?? undefined;
    this.completedAt = parseDate(data.completedAt) ?? undefined;
    this.content = data.content ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.healthUpdatedAt = parseDate(data.healthUpdatedAt) ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.targetDate = data.targetDate ?? undefined;
    this.trashed = data.trashed ?? undefined;
    this.updateReminderFrequency = data.updateReminderFrequency ?? undefined;
    this.updateReminderFrequencyInWeeks = data.updateReminderFrequencyInWeeks ?? undefined;
    this.updateRemindersHour = data.updateRemindersHour ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.documentContent = data.documentContent ? new DocumentContent(request, data.documentContent) : undefined;
    this.frequencyResolution = data.frequencyResolution;
    this.health = data.health ?? undefined;
    this.status = data.status;
    this.targetDateResolution = data.targetDateResolution ?? undefined;
    this.updateRemindersDay = data.updateRemindersDay ?? undefined;
    this._creator = data.creator ?? undefined;
    this._integrationsSettings = data.integrationsSettings ?? undefined;
    this._lastUpdate = data.lastUpdate ?? undefined;
    this._owner = data.owner ?? undefined;
    this._parentInitiative = data.parentInitiative ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The initiative's color. */
  public color?: string;
  /** The time at which the initiative was moved into completed status. */
  public completedAt?: Date;
  /** The initiative's content in markdown format. */
  public content?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The description of the initiative. */
  public description?: string;
  /** The time at which the initiative health was updated. */
  public healthUpdatedAt?: Date;
  /** The icon of the initiative. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the initiative. */
  public name: string;
  /** The initiative's unique URL slug. */
  public slugId: string;
  /** The sort order of the initiative within the organization. */
  public sortOrder: number;
  /** The time at which the initiative was moved into active status. */
  public startedAt?: Date;
  /** The estimated completion date of the initiative. */
  public targetDate?: L.Scalars["TimelessDate"];
  /** A flag that indicates whether the initiative is in the trash bin. */
  public trashed?: boolean;
  /** The frequency at which to prompt for updates. When not set, reminders are inherited from workspace. */
  public updateReminderFrequency?: number;
  /** The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace. */
  public updateReminderFrequencyInWeeks?: number;
  /** The hour at which to prompt for updates. */
  public updateRemindersHour?: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Initiative URL. */
  public url: string;
  /** The content of the initiative description. */
  public documentContent?: DocumentContent;
  /** The resolution of the reminder frequency. */
  public frequencyResolution: L.FrequencyResolutionType;
  /** The health of the initiative. */
  public health?: L.InitiativeUpdateHealthType;
  /** The status of the initiative. One of Planned, Active, Completed */
  public status: L.InitiativeStatus;
  /** The resolution of the initiative's estimated completion date. */
  public targetDateResolution?: L.DateResolutionType;
  /** The day at which to prompt for updates. */
  public updateRemindersDay?: L.Day;
  /** The user who created the initiative. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the initiative. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** Settings for all integrations associated with that initiative. */
  public get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined {
    return this._integrationsSettings?.id
      ? new IntegrationsSettingsQuery(this._request).fetch(this._integrationsSettings?.id)
      : undefined;
  }
  /** The ID of settings for all integrations associated with that initiative. */
  public get integrationsSettingsId(): string | undefined {
    return this._integrationsSettings?.id;
  }
  /** The last initiative update posted for this initiative. */
  public get lastUpdate(): LinearFetch<InitiativeUpdate> | undefined {
    return this._lastUpdate?.id ? new InitiativeUpdateQuery(this._request).fetch(this._lastUpdate?.id) : undefined;
  }
  /** The ID of last initiative update posted for this initiative. */
  public get lastUpdateId(): string | undefined {
    return this._lastUpdate?.id;
  }
  /** The organization of the initiative. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The user who owns the initiative. */
  public get owner(): LinearFetch<User> | undefined {
    return this._owner?.id ? new UserQuery(this._request).fetch(this._owner?.id) : undefined;
  }
  /** The ID of user who owns the initiative. */
  public get ownerId(): string | undefined {
    return this._owner?.id;
  }
  /** Parent initiative associated with the initiative. */
  public get parentInitiative(): LinearFetch<Initiative> | undefined {
    return this._parentInitiative?.id
      ? new InitiativeQuery(this._request).fetch(this._parentInitiative?.id)
      : undefined;
  }
  /** The ID of parent initiative associated with the initiative. */
  public get parentInitiativeId(): string | undefined {
    return this._parentInitiative?.id;
  }
  /** Documents associated with the initiative. */
  public documents(variables?: Omit<L.Initiative_DocumentsQueryVariables, "id">) {
    return new Initiative_DocumentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** History entries associated with the initiative. */
  public history(variables?: Omit<L.Initiative_HistoryQueryVariables, "id">) {
    return new Initiative_HistoryQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Links associated with the initiative. */
  public links(variables?: Omit<L.Initiative_LinksQueryVariables, "id">) {
    return new Initiative_LinksQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Projects associated with the initiative. */
  public projects(variables?: Omit<L.Initiative_ProjectsQueryVariables, "id">) {
    return new Initiative_ProjectsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Sub-initiatives associated with the initiative. */
  public subInitiatives(variables?: Omit<L.Initiative_SubInitiativesQueryVariables, "id">) {
    return new Initiative_SubInitiativesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives a initiative. */
  public archive() {
    return new ArchiveInitiativeMutation(this._request).fetch(this.id);
  }
  /** Creates a new initiative. */
  public create(input: L.InitiativeCreateInput) {
    return new CreateInitiativeMutation(this._request).fetch(input);
  }
  /** Deletes (trashes) an initiative. */
  public delete() {
    return new DeleteInitiativeMutation(this._request).fetch(this.id);
  }
  /** Unarchives a initiative. */
  public unarchive() {
    return new UnarchiveInitiativeMutation(this._request).fetch(this.id);
  }
  /** Updates a initiative. */
  public update() {
    return new InitiativeUpdateQuery(this._request).fetch(this.id);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeArchivePayloadFragment response data
 */
export class InitiativeArchivePayload extends Request {
  private _entity?: L.InitiativeArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.InitiativeArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Initiative> | undefined {
    return this._entity?.id ? new InitiativeQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of an initiative.
 *
 * @param data - L.InitiativeChildWebhookPayloadFragment response data
 */
export class InitiativeChildWebhookPayload {
  public constructor(data: L.InitiativeChildWebhookPayloadFragment) {
    this.id = data.id;
    this.name = data.name;
    this.url = data.url;
  }

  /** The ID of the initiative. */
  public id: string;
  /** The name of the initiative. */
  public name: string;
  /** The URL of the initiative. */
  public url: string;
}
/**
 * InitiativeConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this InitiativeConnection model
 * @param data - InitiativeConnection response data
 */
export class InitiativeConnection extends Connection<Initiative> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Initiative> | undefined>,
    data: L.InitiativeConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Initiative(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A initiative history containing relevant change events.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeHistoryFragment response data
 */
export class InitiativeHistory extends Request {
  private _initiative: L.InitiativeHistoryFragment["initiative"];

  public constructor(request: LinearRequest, data: L.InitiativeHistoryFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.entries = data.entries;
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._initiative = data.initiative;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The events that happened while recording that history. */
  public entries: L.Scalars["JSONObject"];
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The initiative that the history is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._initiative.id);
  }
  /** The ID of initiative that the history is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
}
/**
 * InitiativeHistoryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this InitiativeHistoryConnection model
 * @param data - InitiativeHistoryConnection response data
 */
export class InitiativeHistoryConnection extends Connection<InitiativeHistory> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<InitiativeHistory> | undefined>,
    data: L.InitiativeHistoryConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new InitiativeHistory(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * An initiative related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeNotificationFragment response data
 */
export class InitiativeNotification extends Request {
  private _actor?: L.InitiativeNotificationFragment["actor"];
  private _comment?: L.InitiativeNotificationFragment["comment"];
  private _document?: L.InitiativeNotificationFragment["document"];
  private _externalUserActor?: L.InitiativeNotificationFragment["externalUserActor"];
  private _initiative?: L.InitiativeNotificationFragment["initiative"];
  private _initiativeUpdate?: L.InitiativeNotificationFragment["initiativeUpdate"];
  private _parentComment?: L.InitiativeNotificationFragment["parentComment"];
  private _user: L.InitiativeNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.InitiativeNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.initiativeId = data.initiativeId;
    this.initiativeUpdateId = data.initiativeUpdateId ?? undefined;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._comment = data.comment ?? undefined;
    this._document = data.document ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._initiativeUpdate = data.initiativeUpdate ?? undefined;
    this._parentComment = data.parentComment ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Related comment ID. Null if the notification is not related to a comment. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related initiative ID. */
  public initiativeId: string;
  /** Related initiative update ID. */
  public initiativeUpdateId?: string;
  /** Related parent comment ID. Null if the notification is not related to a comment. */
  public parentCommentId?: string;
  /** Name of the reaction emoji related to the notification. */
  public reactionEmoji?: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The comment related to the notification. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The document related to the notification. */
  public get document(): LinearFetch<Document> | undefined {
    return this._document?.id ? new DocumentQuery(this._request).fetch(this._document?.id) : undefined;
  }
  /** The ID of document related to the notification. */
  public get documentId(): string | undefined {
    return this._document?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The initiative related to the notification. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The initiative update related to the notification. */
  public get initiativeUpdate(): LinearFetch<InitiativeUpdate> | undefined {
    return this._initiativeUpdate?.id
      ? new InitiativeUpdateQuery(this._request).fetch(this._initiativeUpdate?.id)
      : undefined;
  }
  /** The parent comment related to the notification, if a notification is a reply comment notification. */
  public get parentComment(): LinearFetch<Comment> | undefined {
    return this._parentComment?.id ? new CommentQuery(this._request).fetch({ id: this._parentComment?.id }) : undefined;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * An initiative notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeNotificationSubscriptionFragment response data
 */
export class InitiativeNotificationSubscription extends Request {
  private _customView?: L.InitiativeNotificationSubscriptionFragment["customView"];
  private _customer?: L.InitiativeNotificationSubscriptionFragment["customer"];
  private _cycle?: L.InitiativeNotificationSubscriptionFragment["cycle"];
  private _initiative: L.InitiativeNotificationSubscriptionFragment["initiative"];
  private _label?: L.InitiativeNotificationSubscriptionFragment["label"];
  private _project?: L.InitiativeNotificationSubscriptionFragment["project"];
  private _subscriber: L.InitiativeNotificationSubscriptionFragment["subscriber"];
  private _team?: L.InitiativeNotificationSubscriptionFragment["team"];
  private _user?: L.InitiativeNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.InitiativeNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The initiative subscribed to. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._initiative.id);
  }
  /** The ID of initiative subscribed to. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * The payload returned by the initiative mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativePayloadFragment response data
 */
export class InitiativePayload extends Request {
  private _initiative: L.InitiativePayloadFragment["initiative"];

  public constructor(request: LinearRequest, data: L.InitiativePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._initiative = data.initiative;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The initiative that was created or updated. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._initiative.id);
  }
  /** The ID of initiative that was created or updated. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
}
/**
 * A relation representing the dependency between two initiatives.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeRelationFragment response data
 */
export class InitiativeRelation extends Request {
  private _initiative: L.InitiativeRelationFragment["initiative"];
  private _relatedInitiative: L.InitiativeRelationFragment["relatedInitiative"];
  private _user?: L.InitiativeRelationFragment["user"];

  public constructor(request: LinearRequest, data: L.InitiativeRelationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._initiative = data.initiative;
    this._relatedInitiative = data.relatedInitiative;
    this._user = data.user ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The sort order of the relation within the initiative. */
  public sortOrder: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The parent initiative. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._initiative.id);
  }
  /** The ID of parent initiative. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The child initiative. */
  public get relatedInitiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._relatedInitiative.id);
  }
  /** The ID of child initiative. */
  public get relatedInitiativeId(): string | undefined {
    return this._relatedInitiative?.id;
  }
  /** The last user who created or modified the relation. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of last user who created or modified the relation. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Creates a new initiative relation. */
  public create(input: L.InitiativeRelationCreateInput) {
    return new CreateInitiativeRelationMutation(this._request).fetch(input);
  }
  /** Deletes an initiative relation. */
  public delete() {
    return new DeleteInitiativeRelationMutation(this._request).fetch(this.id);
  }
  /** Updates an initiative relation. */
  public update(input: L.InitiativeRelationUpdateInput) {
    return new UpdateInitiativeRelationMutation(this._request).fetch(this.id, input);
  }
}
/**
 * InitiativeRelationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this InitiativeRelationConnection model
 * @param data - InitiativeRelationConnection response data
 */
export class InitiativeRelationConnection extends Connection<InitiativeRelation> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<InitiativeRelation> | undefined>,
    data: L.InitiativeRelationConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new InitiativeRelation(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * InitiativeRelationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeRelationPayloadFragment response data
 */
export class InitiativeRelationPayload extends Request {
  public constructor(request: LinearRequest, data: L.InitiativeRelationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.initiativeRelation = new InitiativeRelation(request, data.initiativeRelation);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The initiative relation that was created or updated. */
  public initiativeRelation: InitiativeRelation;
}
/**
 * Join table between projects and initiatives.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeToProjectFragment response data
 */
export class InitiativeToProject extends Request {
  private _initiative: L.InitiativeToProjectFragment["initiative"];
  private _project: L.InitiativeToProjectFragment["project"];

  public constructor(request: LinearRequest, data: L.InitiativeToProjectFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._initiative = data.initiative;
    this._project = data.project;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The sort order of the project within the initiative. */
  public sortOrder: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The initiative that the project is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._initiative.id);
  }
  /** The ID of initiative that the project is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The project that the initiative is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project that the initiative is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }

  /** Creates a new initiativeToProject join. */
  public create(input: L.InitiativeToProjectCreateInput) {
    return new CreateInitiativeToProjectMutation(this._request).fetch(input);
  }
  /** Deletes a initiativeToProject. */
  public delete() {
    return new DeleteInitiativeToProjectMutation(this._request).fetch(this.id);
  }
  /** Updates a initiativeToProject. */
  public update(input: L.InitiativeToProjectUpdateInput) {
    return new UpdateInitiativeToProjectMutation(this._request).fetch(this.id, input);
  }
}
/**
 * InitiativeToProjectConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this InitiativeToProjectConnection model
 * @param data - InitiativeToProjectConnection response data
 */
export class InitiativeToProjectConnection extends Connection<InitiativeToProject> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<InitiativeToProject> | undefined>,
    data: L.InitiativeToProjectConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new InitiativeToProject(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * The result of a initiativeToProject mutation.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeToProjectPayloadFragment response data
 */
export class InitiativeToProjectPayload extends Request {
  private _initiativeToProject: L.InitiativeToProjectPayloadFragment["initiativeToProject"];

  public constructor(request: LinearRequest, data: L.InitiativeToProjectPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._initiativeToProject = data.initiativeToProject;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The initiativeToProject that was created or updated. */
  public get initiativeToProject(): LinearFetch<InitiativeToProject> | undefined {
    return new InitiativeToProjectQuery(this._request).fetch(this._initiativeToProject.id);
  }
  /** The ID of initiativetoproject that was created or updated. */
  public get initiativeToProjectId(): string | undefined {
    return this._initiativeToProject?.id;
  }
}
/**
 * An initiative update.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeUpdateFragment response data
 */
export class InitiativeUpdate extends Request {
  private _initiative: L.InitiativeUpdateFragment["initiative"];
  private _user: L.InitiativeUpdateFragment["user"];

  public constructor(request: LinearRequest, data: L.InitiativeUpdateFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.body = data.body;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.diff = data.diff ?? undefined;
    this.diffMarkdown = data.diffMarkdown ?? undefined;
    this.editedAt = parseDate(data.editedAt) ?? undefined;
    this.id = data.id;
    this.isDiffHidden = data.isDiffHidden;
    this.isStale = data.isStale;
    this.reactionData = data.reactionData;
    this.slugId = data.slugId;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.reactions = data.reactions.map(node => new Reaction(request, node));
    this.health = data.health;
    this._initiative = data.initiative;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The update content in markdown format. */
  public body: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The diff between the current update and the previous one. */
  public diff?: L.Scalars["JSONObject"];
  /** The diff between the current update and the previous one, formatted as markdown. */
  public diffMarkdown?: string;
  /** The time the update was edited. */
  public editedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether initiative update diff should be hidden. */
  public isDiffHidden: boolean;
  /** Whether the initiative update is stale. */
  public isStale: boolean;
  /** Emoji reaction summary, grouped by emoji type. */
  public reactionData: L.Scalars["JSONObject"];
  /** The update's unique URL slug. */
  public slugId: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The URL to the initiative update. */
  public url: string;
  /** Reactions associated with the initiative update. */
  public reactions: Reaction[];
  /** The health at the time of the update. */
  public health: L.InitiativeUpdateHealthType;
  /** The initiative that the update is associated with. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return new InitiativeQuery(this._request).fetch(this._initiative.id);
  }
  /** The ID of initiative that the update is associated with. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The user who wrote the update. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user who wrote the update. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
  /** Comments associated with the initiative update. */
  public comments(variables?: Omit<L.InitiativeUpdate_CommentsQueryVariables, "id">) {
    return new InitiativeUpdate_CommentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives an initiative update. */
  public archive() {
    return new ArchiveInitiativeUpdateMutation(this._request).fetch(this.id);
  }
  /** Creates a initiative update. */
  public create(input: L.InitiativeUpdateCreateInput) {
    return new CreateInitiativeUpdateMutation(this._request).fetch(input);
  }
  /** Unarchives an initiative update. */
  public unarchive() {
    return new UnarchiveInitiativeUpdateMutation(this._request).fetch(this.id);
  }
  /** Updates an update. */
  public update(input: L.InitiativeUpdateUpdateInput) {
    return new UpdateInitiativeUpdateMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeUpdateArchivePayloadFragment response data
 */
export class InitiativeUpdateArchivePayload extends Request {
  private _entity?: L.InitiativeUpdateArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.InitiativeUpdateArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<InitiativeUpdate> | undefined {
    return this._entity?.id ? new InitiativeUpdateQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of an initiative update.
 *
 * @param data - L.InitiativeUpdateChildWebhookPayloadFragment response data
 */
export class InitiativeUpdateChildWebhookPayload {
  public constructor(data: L.InitiativeUpdateChildWebhookPayloadFragment) {
    this.bodyData = data.bodyData;
    this.editedAt = data.editedAt;
    this.health = data.health;
    this.id = data.id;
  }

  /** The body of the initiative update. */
  public bodyData: string;
  /** The edited at timestamp of the initiative update. */
  public editedAt: string;
  /** The health of the initiative update. */
  public health: string;
  /** The ID of the initiative update. */
  public id: string;
}
/**
 * InitiativeUpdateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this InitiativeUpdateConnection model
 * @param data - InitiativeUpdateConnection response data
 */
export class InitiativeUpdateConnection extends Connection<InitiativeUpdate> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<InitiativeUpdate> | undefined>,
    data: L.InitiativeUpdateConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new InitiativeUpdate(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * InitiativeUpdatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeUpdatePayloadFragment response data
 */
export class InitiativeUpdatePayload extends Request {
  private _initiativeUpdate: L.InitiativeUpdatePayloadFragment["initiativeUpdate"];

  public constructor(request: LinearRequest, data: L.InitiativeUpdatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._initiativeUpdate = data.initiativeUpdate;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The initiative update that was created. */
  public get initiativeUpdate(): LinearFetch<InitiativeUpdate> | undefined {
    return new InitiativeUpdateQuery(this._request).fetch(this._initiativeUpdate.id);
  }
  /** The ID of initiative update that was created. */
  public get initiativeUpdateId(): string | undefined {
    return this._initiativeUpdate?.id;
  }
}
/**
 * InitiativeUpdateReminderPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.InitiativeUpdateReminderPayloadFragment response data
 */
export class InitiativeUpdateReminderPayload extends Request {
  public constructor(request: LinearRequest, data: L.InitiativeUpdateReminderPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Payload for an initiative update webhook.
 *
 * @param data - L.InitiativeUpdateWebhookPayloadFragment response data
 */
export class InitiativeUpdateWebhookPayload {
  public constructor(data: L.InitiativeUpdateWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.body = data.body;
    this.bodyData = data.bodyData;
    this.createdAt = data.createdAt;
    this.editedAt = data.editedAt;
    this.health = data.health;
    this.id = data.id;
    this.initiativeId = data.initiativeId;
    this.reactionData = data.reactionData;
    this.slugId = data.slugId;
    this.updatedAt = data.updatedAt;
    this.url = data.url ?? undefined;
    this.userId = data.userId;
    this.initiative = new InitiativeChildWebhookPayload(data.initiative);
    this.user = new UserChildWebhookPayload(data.user);
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The body of the initiative update. */
  public body: string;
  /** The body data of the initiative update. */
  public bodyData: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The edited at timestamp of the initiative update. */
  public editedAt: string;
  /** The health of the initiative update. */
  public health: string;
  /** The ID of the entity. */
  public id: string;
  /** The initiative id of the initiative update. */
  public initiativeId: string;
  /** The reaction data for this initiative update. */
  public reactionData: L.Scalars["JSONObject"];
  /** The slug id of the initiative update. */
  public slugId: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the initiative update. */
  public url?: string;
  /** The user id of the initiative update. */
  public userId: string;
  /** The initiative that the initiative update belongs to. */
  public initiative: InitiativeChildWebhookPayload;
  /** The user that created the initiative update. */
  public user: UserChildWebhookPayload;
}
/**
 * Payload for an initiative webhook.
 *
 * @param data - L.InitiativeWebhookPayloadFragment response data
 */
export class InitiativeWebhookPayload {
  public constructor(data: L.InitiativeWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.color = data.color ?? undefined;
    this.completedAt = data.completedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.description = data.description;
    this.frequencyResolution = data.frequencyResolution;
    this.health = data.health ?? undefined;
    this.healthUpdatedAt = data.healthUpdatedAt ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.lastUpdateId = data.lastUpdateId ?? undefined;
    this.name = data.name;
    this.organizationId = data.organizationId;
    this.ownerId = data.ownerId ?? undefined;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.startedAt = data.startedAt ?? undefined;
    this.status = data.status;
    this.targetDate = data.targetDate ?? undefined;
    this.targetDateResolution = data.targetDateResolution ?? undefined;
    this.trashed = data.trashed ?? undefined;
    this.updateReminderFrequency = data.updateReminderFrequency ?? undefined;
    this.updateReminderFrequencyInWeeks = data.updateReminderFrequencyInWeeks ?? undefined;
    this.updateRemindersDay = data.updateRemindersDay ?? undefined;
    this.updateRemindersHour = data.updateRemindersHour ?? undefined;
    this.updatedAt = data.updatedAt;
    this.url = data.url;
    this.creator = data.creator ? new UserChildWebhookPayload(data.creator) : undefined;
    this.lastUpdate = data.lastUpdate ? new InitiativeUpdateChildWebhookPayload(data.lastUpdate) : undefined;
    this.owner = data.owner ? new UserChildWebhookPayload(data.owner) : undefined;
    this.parentInitiative = data.parentInitiative
      ? new InitiativeChildWebhookPayload(data.parentInitiative)
      : undefined;
    this.projects = data.projects ? data.projects.map(node => new ProjectChildWebhookPayload(node)) : undefined;
    this.subInitiatives = data.subInitiatives
      ? data.subInitiatives.map(node => new InitiativeChildWebhookPayload(node))
      : undefined;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The color of the initiative. */
  public color?: string;
  /** When the initiative was completed. */
  public completedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the user who created the initiative. */
  public creatorId?: string;
  /** The description of the initiative. */
  public description: string;
  /** The resolution of the update reminder frequency. */
  public frequencyResolution: string;
  /** The health status of the initiative. */
  public health?: string;
  /** When the health status was last updated. */
  public healthUpdatedAt?: string;
  /** The icon of the initiative. */
  public icon?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the last update for this initiative. */
  public lastUpdateId?: string;
  /** The name of the initiative. */
  public name: string;
  /** The ID of the organization this initiative belongs to. */
  public organizationId: string;
  /** The ID of the user who owns the initiative. */
  public ownerId?: string;
  /** The unique slug identifier of the initiative. */
  public slugId: string;
  /** The sort order of the initiative within the organization. */
  public sortOrder: number;
  /** When the initiative was started. */
  public startedAt?: string;
  /** The current status of the initiative. */
  public status: string;
  /** The target date of the initiative. */
  public targetDate?: string;
  /** The resolution of the target date. */
  public targetDateResolution?: string;
  /** Whether the initiative is trashed. */
  public trashed?: boolean;
  /** The frequency of update reminders. */
  public updateReminderFrequency?: number;
  /** The frequency of update reminders in weeks. */
  public updateReminderFrequencyInWeeks?: number;
  /** The day of the week for update reminders. */
  public updateRemindersDay?: number;
  /** The hour of the day for update reminders. */
  public updateRemindersHour?: number;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the initiative. */
  public url: string;
  /** The projects associated with the initiative. */
  public projects?: ProjectChildWebhookPayload[];
  /** The sub-initiatives associated with the initiative. */
  public subInitiatives?: InitiativeChildWebhookPayload[];
  /** The user who created the initiative. */
  public creator?: UserChildWebhookPayload;
  /** The last update for this initiative. */
  public lastUpdate?: InitiativeUpdateChildWebhookPayload;
  /** The user who owns the initiative. */
  public owner?: UserChildWebhookPayload;
  /** The parent initiative associated with the initiative. */
  public parentInitiative?: InitiativeChildWebhookPayload;
}
/**
 * An integration with an external service.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationFragment response data
 */
export class Integration extends Request {
  private _creator: L.IntegrationFragment["creator"];
  private _team?: L.IntegrationFragment["team"];

  public constructor(request: LinearRequest, data: L.IntegrationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.service = data.service;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._creator = data.creator;
    this._team = data.team ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The integration's type. */
  public service: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user that added the integration. */
  public get creator(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._creator.id);
  }
  /** The ID of user that added the integration. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization that the integration is associated with. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The team that the integration is associated with. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team that the integration is associated with. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }

  /** Archives an integration. */
  public archive() {
    return new ArchiveIntegrationMutation(this._request).fetch(this.id);
  }
  /** Deletes an integration. */
  public delete() {
    return new DeleteIntegrationMutation(this._request).fetch(this.id);
  }
}
/**
 * Certain properties of an integration.
 *
 * @param data - L.IntegrationChildWebhookPayloadFragment response data
 */
export class IntegrationChildWebhookPayload {
  public constructor(data: L.IntegrationChildWebhookPayloadFragment) {
    this.id = data.id;
    this.service = data.service;
  }

  /** The ID of the integration. */
  public id: string;
  /** The service of the integration. */
  public service: string;
}
/**
 * IntegrationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationConnection model
 * @param data - IntegrationConnection response data
 */
export class IntegrationConnection extends Connection<Integration> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Integration> | undefined>,
    data: L.IntegrationConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Integration(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * IntegrationHasScopesPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationHasScopesPayloadFragment response data
 */
export class IntegrationHasScopesPayload extends Request {
  public constructor(request: LinearRequest, data: L.IntegrationHasScopesPayloadFragment) {
    super(request);
    this.hasAllScopes = data.hasAllScopes;
    this.missingScopes = data.missingScopes ?? undefined;
  }

  /** Whether the integration has the required scopes. */
  public hasAllScopes: boolean;
  /** The missing scopes. */
  public missingScopes?: string[];
}
/**
 * IntegrationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationPayloadFragment response data
 */
export class IntegrationPayload extends Request {
  private _integration?: L.IntegrationPayloadFragment["integration"];

  public constructor(request: LinearRequest, data: L.IntegrationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._integration = data.integration ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The integration that was created or updated. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that was created or updated. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
}
/**
 * IntegrationRequestPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationRequestPayloadFragment response data
 */
export class IntegrationRequestPayload extends Request {
  public constructor(request: LinearRequest, data: L.IntegrationRequestPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Join table between templates and integrations.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationTemplateFragment response data
 */
export class IntegrationTemplate extends Request {
  private _integration: L.IntegrationTemplateFragment["integration"];
  private _template: L.IntegrationTemplateFragment["template"];

  public constructor(request: LinearRequest, data: L.IntegrationTemplateFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.foreignEntityId = data.foreignEntityId ?? undefined;
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._integration = data.integration;
    this._template = data.template;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** ID of the foreign entity in the external integration this template is for, e.g., Slack channel ID. */
  public foreignEntityId?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The integration that the template is associated with. */
  public get integration(): LinearFetch<Integration> | undefined {
    return new IntegrationQuery(this._request).fetch(this._integration.id);
  }
  /** The ID of integration that the template is associated with. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
  /** The template that the integration is associated with. */
  public get template(): LinearFetch<Template> | undefined {
    return new TemplateQuery(this._request).fetch(this._template.id);
  }
  /** The ID of template that the integration is associated with. */
  public get templateId(): string | undefined {
    return this._template?.id;
  }

  /** Creates a new integrationTemplate join. */
  public create(input: L.IntegrationTemplateCreateInput) {
    return new CreateIntegrationTemplateMutation(this._request).fetch(input);
  }
  /** Deletes a integrationTemplate. */
  public delete() {
    return new DeleteIntegrationTemplateMutation(this._request).fetch(this.id);
  }
}
/**
 * IntegrationTemplateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IntegrationTemplateConnection model
 * @param data - IntegrationTemplateConnection response data
 */
export class IntegrationTemplateConnection extends Connection<IntegrationTemplate> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IntegrationTemplate> | undefined>,
    data: L.IntegrationTemplateConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new IntegrationTemplate(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * IntegrationTemplatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationTemplatePayloadFragment response data
 */
export class IntegrationTemplatePayload extends Request {
  private _integrationTemplate: L.IntegrationTemplatePayloadFragment["integrationTemplate"];

  public constructor(request: LinearRequest, data: L.IntegrationTemplatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._integrationTemplate = data.integrationTemplate;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The IntegrationTemplate that was created or updated. */
  public get integrationTemplate(): LinearFetch<IntegrationTemplate> | undefined {
    return new IntegrationTemplateQuery(this._request).fetch(this._integrationTemplate.id);
  }
  /** The ID of integrationtemplate that was created or updated. */
  public get integrationTemplateId(): string | undefined {
    return this._integrationTemplate?.id;
  }
}
/**
 * The configuration of all integrations for different entities.
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationsSettingsFragment response data
 */
export class IntegrationsSettings extends Request {
  private _initiative?: L.IntegrationsSettingsFragment["initiative"];
  private _project?: L.IntegrationsSettingsFragment["project"];
  private _team?: L.IntegrationsSettingsFragment["team"];

  public constructor(request: LinearRequest, data: L.IntegrationsSettingsFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.slackInitiativeUpdateCreated = data.slackInitiativeUpdateCreated ?? undefined;
    this.slackIssueAddedToTriage = data.slackIssueAddedToTriage ?? undefined;
    this.slackIssueAddedToView = data.slackIssueAddedToView ?? undefined;
    this.slackIssueCreated = data.slackIssueCreated ?? undefined;
    this.slackIssueNewComment = data.slackIssueNewComment ?? undefined;
    this.slackIssueSlaBreached = data.slackIssueSlaBreached ?? undefined;
    this.slackIssueSlaHighRisk = data.slackIssueSlaHighRisk ?? undefined;
    this.slackIssueStatusChangedAll = data.slackIssueStatusChangedAll ?? undefined;
    this.slackIssueStatusChangedDone = data.slackIssueStatusChangedDone ?? undefined;
    this.slackProjectUpdateCreated = data.slackProjectUpdateCreated ?? undefined;
    this.slackProjectUpdateCreatedToTeam = data.slackProjectUpdateCreatedToTeam ?? undefined;
    this.slackProjectUpdateCreatedToWorkspace = data.slackProjectUpdateCreatedToWorkspace ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._project = data.project ?? undefined;
    this._team = data.team ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether to send a Slack message when a initiate update is created. */
  public slackInitiativeUpdateCreated?: boolean;
  /** Whether to send a Slack message when a new issue is added to triage. */
  public slackIssueAddedToTriage?: boolean;
  /** Whether to send a Slack message when an issue is added to the custom view. */
  public slackIssueAddedToView?: boolean;
  /** Whether to send a Slack message when a new issue is created for the project or the team. */
  public slackIssueCreated?: boolean;
  /** Whether to send a Slack message when a comment is created on any of the project or team's issues. */
  public slackIssueNewComment?: boolean;
  /** Whether to send a Slack message when an SLA is breached. */
  public slackIssueSlaBreached?: boolean;
  /** Whether to send a Slack message when an SLA is at high risk. */
  public slackIssueSlaHighRisk?: boolean;
  /** Whether to send a Slack message when any of the project or team's issues has a change in status. */
  public slackIssueStatusChangedAll?: boolean;
  /** Whether to send a Slack message when any of the project or team's issues change to completed or cancelled. */
  public slackIssueStatusChangedDone?: boolean;
  /** Whether to send a Slack message when a project update is created. */
  public slackProjectUpdateCreated?: boolean;
  /** Whether to send a new project update to team Slack channels. */
  public slackProjectUpdateCreatedToTeam?: boolean;
  /** Whether to send a new project update to workspace Slack channel. */
  public slackProjectUpdateCreatedToWorkspace?: boolean;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the integration settings context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** Initiative which those settings apply to. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of initiative which those settings apply to. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** Project which those settings apply to. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project which those settings apply to. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** Team which those settings apply to. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team which those settings apply to. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }

  /** Creates new settings for one or more integrations. */
  public create(input: L.IntegrationsSettingsCreateInput) {
    return new CreateIntegrationsSettingsMutation(this._request).fetch(input);
  }
  /** Updates settings related to integrations for a project or a team. */
  public update(input: L.IntegrationsSettingsUpdateInput) {
    return new UpdateIntegrationsSettingsMutation(this._request).fetch(this.id, input);
  }
}
/**
 * IntegrationsSettingsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IntegrationsSettingsPayloadFragment response data
 */
export class IntegrationsSettingsPayload extends Request {
  private _integrationsSettings: L.IntegrationsSettingsPayloadFragment["integrationsSettings"];

  public constructor(request: LinearRequest, data: L.IntegrationsSettingsPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._integrationsSettings = data.integrationsSettings;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The settings that were created or updated. */
  public get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined {
    return new IntegrationsSettingsQuery(this._request).fetch(this._integrationsSettings.id);
  }
  /** The ID of settings that were created or updated. */
  public get integrationsSettingsId(): string | undefined {
    return this._integrationsSettings?.id;
  }
}
/**
 * An issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueFragment response data
 */
export class Issue extends Request {
  private _assignee?: L.IssueFragment["assignee"];
  private _creator?: L.IssueFragment["creator"];
  private _cycle?: L.IssueFragment["cycle"];
  private _delegate?: L.IssueFragment["delegate"];
  private _externalUserCreator?: L.IssueFragment["externalUserCreator"];
  private _favorite?: L.IssueFragment["favorite"];
  private _lastAppliedTemplate?: L.IssueFragment["lastAppliedTemplate"];
  private _parent?: L.IssueFragment["parent"];
  private _project?: L.IssueFragment["project"];
  private _projectMilestone?: L.IssueFragment["projectMilestone"];
  private _recurringIssueTemplate?: L.IssueFragment["recurringIssueTemplate"];
  private _snoozedBy?: L.IssueFragment["snoozedBy"];
  private _sourceComment?: L.IssueFragment["sourceComment"];
  private _state: L.IssueFragment["state"];
  private _team: L.IssueFragment["team"];

  public constructor(request: LinearRequest, data: L.IssueFragment) {
    super(request);
    this.addedToCycleAt = parseDate(data.addedToCycleAt) ?? undefined;
    this.addedToProjectAt = parseDate(data.addedToProjectAt) ?? undefined;
    this.addedToTeamAt = parseDate(data.addedToTeamAt) ?? undefined;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoArchivedAt = parseDate(data.autoArchivedAt) ?? undefined;
    this.autoClosedAt = parseDate(data.autoClosedAt) ?? undefined;
    this.boardOrder = data.boardOrder;
    this.branchName = data.branchName;
    this.canceledAt = parseDate(data.canceledAt) ?? undefined;
    this.completedAt = parseDate(data.completedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.customerTicketCount = data.customerTicketCount;
    this.description = data.description ?? undefined;
    this.dueDate = data.dueDate ?? undefined;
    this.estimate = data.estimate ?? undefined;
    this.id = data.id;
    this.identifier = data.identifier;
    this.labelIds = data.labelIds;
    this.number = data.number;
    this.previousIdentifiers = data.previousIdentifiers;
    this.priority = data.priority;
    this.priorityLabel = data.priorityLabel;
    this.prioritySortOrder = data.prioritySortOrder;
    this.reactionData = data.reactionData;
    this.slaBreachesAt = parseDate(data.slaBreachesAt) ?? undefined;
    this.slaHighRiskAt = parseDate(data.slaHighRiskAt) ?? undefined;
    this.slaMediumRiskAt = parseDate(data.slaMediumRiskAt) ?? undefined;
    this.slaStartedAt = parseDate(data.slaStartedAt) ?? undefined;
    this.slaType = data.slaType ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.sortOrder = data.sortOrder;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.startedTriageAt = parseDate(data.startedTriageAt) ?? undefined;
    this.subIssueSortOrder = data.subIssueSortOrder ?? undefined;
    this.title = data.title;
    this.trashed = data.trashed ?? undefined;
    this.triagedAt = parseDate(data.triagedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this.reactions = data.reactions.map(node => new Reaction(request, node));
    this.syncedWith = data.syncedWith ? data.syncedWith.map(node => new ExternalEntityInfo(request, node)) : undefined;
    this.integrationSourceType = data.integrationSourceType ?? undefined;
    this._assignee = data.assignee ?? undefined;
    this._creator = data.creator ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._delegate = data.delegate ?? undefined;
    this._externalUserCreator = data.externalUserCreator ?? undefined;
    this._favorite = data.favorite ?? undefined;
    this._lastAppliedTemplate = data.lastAppliedTemplate ?? undefined;
    this._parent = data.parent ?? undefined;
    this._project = data.project ?? undefined;
    this._projectMilestone = data.projectMilestone ?? undefined;
    this._recurringIssueTemplate = data.recurringIssueTemplate ?? undefined;
    this._snoozedBy = data.snoozedBy ?? undefined;
    this._sourceComment = data.sourceComment ?? undefined;
    this._state = data.state;
    this._team = data.team;
  }

  /** The time at which the issue was added to a cycle. */
  public addedToCycleAt?: Date;
  /** The time at which the issue was added to a project. */
  public addedToProjectAt?: Date;
  /** The time at which the issue was added to a team. */
  public addedToTeamAt?: Date;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the issue was automatically archived by the auto pruning process. */
  public autoArchivedAt?: Date;
  /** The time at which the issue was automatically closed by the auto pruning process. */
  public autoClosedAt?: Date;
  /** The order of the item in its column on the board. */
  public boardOrder: number;
  /** Suggested branch name for the issue. */
  public branchName: string;
  /** The time at which the issue was moved into canceled state. */
  public canceledAt?: Date;
  /** The time at which the issue was moved into completed state. */
  public completedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
  public customerTicketCount: number;
  /** The issue's description in markdown format. */
  public description?: string;
  /** The date at which the issue is due. */
  public dueDate?: L.Scalars["TimelessDate"];
  /** The estimate of the complexity of the issue.. */
  public estimate?: number;
  /** The unique identifier of the entity. */
  public id: string;
  /** Issue's human readable identifier (e.g. ENG-123). */
  public identifier: string;
  /** Id of the labels associated with this issue. */
  public labelIds: string[];
  /** The issue's unique number. */
  public number: number;
  /** Previous identifiers of the issue if it has been moved between teams. */
  public previousIdentifiers: string[];
  /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
  public priority: number;
  /** Label for the priority. */
  public priorityLabel: string;
  /** The order of the item in relation to other items in the organization, when ordered by priority. */
  public prioritySortOrder: number;
  /** Emoji reaction summary, grouped by emoji type. */
  public reactionData: L.Scalars["JSONObject"];
  /** The time at which the issue's SLA will breach. */
  public slaBreachesAt?: Date;
  /** The time at which the issue's SLA will enter high risk state. */
  public slaHighRiskAt?: Date;
  /** The time at which the issue's SLA will enter medium risk state. */
  public slaMediumRiskAt?: Date;
  /** The time at which the issue's SLA began. */
  public slaStartedAt?: Date;
  /** The type of SLA set on the issue. Calendar days or business days. */
  public slaType?: string;
  /** The time until an issue will be snoozed in Triage view. */
  public snoozedUntilAt?: Date;
  /** The order of the item in relation to other items in the organization. */
  public sortOrder: number;
  /** The time at which the issue was moved into started state. */
  public startedAt?: Date;
  /** The time at which the issue entered triage. */
  public startedTriageAt?: Date;
  /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
  public subIssueSortOrder?: number;
  /** The issue's title. */
  public title: string;
  /** A flag that indicates whether the issue is in the trash bin. */
  public trashed?: boolean;
  /** The time at which the issue left triage. */
  public triagedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Issue URL. */
  public url: string;
  /** Reactions associated with the issue. */
  public reactions: Reaction[];
  /** The external services the issue is synced with. */
  public syncedWith?: ExternalEntityInfo[];
  /** The bot that created the issue, if applicable. */
  public botActor?: ActorBot;
  /** Integration type that created this issue, if applicable. */
  public integrationSourceType?: L.IntegrationService;
  /** The user to whom the issue is assigned to. */
  public get assignee(): LinearFetch<User> | undefined {
    return this._assignee?.id ? new UserQuery(this._request).fetch(this._assignee?.id) : undefined;
  }
  /** The ID of user to whom the issue is assigned to. */
  public get assigneeId(): string | undefined {
    return this._assignee?.id;
  }
  /** The user who created the issue. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the issue. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The cycle that the issue is associated with. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of cycle that the issue is associated with. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The app user that is delegated to work on this issue. */
  public get delegate(): LinearFetch<User> | undefined {
    return this._delegate?.id ? new UserQuery(this._request).fetch(this._delegate?.id) : undefined;
  }
  /** The ID of app user that is delegated to work on this issue. */
  public get delegateId(): string | undefined {
    return this._delegate?.id;
  }
  /** The external user who created the issue. */
  public get externalUserCreator(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserCreator?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserCreator?.id)
      : undefined;
  }
  /** The ID of external user who created the issue. */
  public get externalUserCreatorId(): string | undefined {
    return this._externalUserCreator?.id;
  }
  /** The users favorite associated with this issue. */
  public get favorite(): LinearFetch<Favorite> | undefined {
    return this._favorite?.id ? new FavoriteQuery(this._request).fetch(this._favorite?.id) : undefined;
  }
  /** The ID of users favorite associated with this issue. */
  public get favoriteId(): string | undefined {
    return this._favorite?.id;
  }
  /** The last template that was applied to this issue. */
  public get lastAppliedTemplate(): LinearFetch<Template> | undefined {
    return this._lastAppliedTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._lastAppliedTemplate?.id)
      : undefined;
  }
  /** The ID of last template that was applied to this issue. */
  public get lastAppliedTemplateId(): string | undefined {
    return this._lastAppliedTemplate?.id;
  }
  /** The parent of the issue. */
  public get parent(): LinearFetch<Issue> | undefined {
    return this._parent?.id ? new IssueQuery(this._request).fetch(this._parent?.id) : undefined;
  }
  /** The ID of parent of the issue. */
  public get parentId(): string | undefined {
    return this._parent?.id;
  }
  /** The project that the issue is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project that the issue is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The projectMilestone that the issue is associated with. */
  public get projectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return this._projectMilestone?.id
      ? new ProjectMilestoneQuery(this._request).fetch(this._projectMilestone?.id)
      : undefined;
  }
  /** The ID of projectmilestone that the issue is associated with. */
  public get projectMilestoneId(): string | undefined {
    return this._projectMilestone?.id;
  }
  /** The recurring issue template that created this issue. */
  public get recurringIssueTemplate(): LinearFetch<Template> | undefined {
    return this._recurringIssueTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._recurringIssueTemplate?.id)
      : undefined;
  }
  /** The ID of recurring issue template that created this issue. */
  public get recurringIssueTemplateId(): string | undefined {
    return this._recurringIssueTemplate?.id;
  }
  /** The user who snoozed the issue. */
  public get snoozedBy(): LinearFetch<User> | undefined {
    return this._snoozedBy?.id ? new UserQuery(this._request).fetch(this._snoozedBy?.id) : undefined;
  }
  /** The ID of user who snoozed the issue. */
  public get snoozedById(): string | undefined {
    return this._snoozedBy?.id;
  }
  /** The comment that this issue was created from. */
  public get sourceComment(): LinearFetch<Comment> | undefined {
    return this._sourceComment?.id ? new CommentQuery(this._request).fetch({ id: this._sourceComment?.id }) : undefined;
  }
  /** The ID of comment that this issue was created from. */
  public get sourceCommentId(): string | undefined {
    return this._sourceComment?.id;
  }
  /** The workflow state that the issue is associated with. */
  public get state(): LinearFetch<WorkflowState> | undefined {
    return new WorkflowStateQuery(this._request).fetch(this._state.id);
  }
  /** The ID of workflow state that the issue is associated with. */
  public get stateId(): string | undefined {
    return this._state?.id;
  }
  /** The team that the issue is associated with. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team that the issue is associated with. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** Attachments associated with the issue. */
  public attachments(variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">) {
    return new Issue_AttachmentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Children of the issue. */
  public children(variables?: Omit<L.Issue_ChildrenQueryVariables, "id">) {
    return new Issue_ChildrenQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Comments associated with the issue. */
  public comments(variables?: Omit<L.Issue_CommentsQueryVariables, "id">) {
    return new Issue_CommentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Attachments previously associated with the issue before being moved to another issue. */
  public formerAttachments(variables?: Omit<L.Issue_FormerAttachmentsQueryVariables, "id">) {
    return new Issue_FormerAttachmentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Customer needs previously associated with the issue before being moved to another issue. */
  public formerNeeds(variables?: Omit<L.Issue_FormerNeedsQueryVariables, "id">) {
    return new Issue_FormerNeedsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** History entries associated with the issue. */
  public history(variables?: Omit<L.Issue_HistoryQueryVariables, "id">) {
    return new Issue_HistoryQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Inverse relations associated with this issue. */
  public inverseRelations(variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">) {
    return new Issue_InverseRelationsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Labels associated with this issue. */
  public labels(variables?: Omit<L.Issue_LabelsQueryVariables, "id">) {
    return new Issue_LabelsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Customer needs associated with the issue. */
  public needs(variables?: Omit<L.Issue_NeedsQueryVariables, "id">) {
    return new Issue_NeedsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Relations associated with this issue. */
  public relations(variables?: Omit<L.Issue_RelationsQueryVariables, "id">) {
    return new Issue_RelationsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Users who are subscribed to the issue. */
  public subscribers(variables?: Omit<L.Issue_SubscribersQueryVariables, "id">) {
    return new Issue_SubscribersQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives an issue. */
  public archive(variables?: Omit<L.ArchiveIssueMutationVariables, "id">) {
    return new ArchiveIssueMutation(this._request).fetch(this.id, variables);
  }
  /** Creates a new issue. */
  public create(input: L.IssueCreateInput) {
    return new CreateIssueMutation(this._request).fetch(input);
  }
  /** Deletes (trashes) an issue. */
  public delete(variables?: Omit<L.DeleteIssueMutationVariables, "id">) {
    return new DeleteIssueMutation(this._request).fetch(this.id, variables);
  }
  /** Unarchives an issue. */
  public unarchive() {
    return new UnarchiveIssueMutation(this._request).fetch(this.id);
  }
  /** Updates an issue. */
  public update(input: L.IssueUpdateInput) {
    return new UpdateIssueMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueArchivePayloadFragment response data
 */
export class IssueArchivePayload extends Request {
  private _entity?: L.IssueArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.IssueArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Issue> | undefined {
    return this._entity?.id ? new IssueQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Payload for an issue assigned to you notification.
 *
 * @param data - L.IssueAssignedToYouNotificationWebhookPayloadFragment response data
 */
export class IssueAssignedToYouNotificationWebhookPayload {
  public constructor(data: L.IssueAssignedToYouNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** An issue assigned to you notification type. */
  public type: "issueAssignedToYou";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
}
/**
 * IssueBatchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueBatchPayloadFragment response data
 */
export class IssueBatchPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueBatchPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.issues = data.issues.map(node => new Issue(request, node));
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The issues that were updated. */
  public issues: Issue[];
}
/**
 * Certain properties of an issue.
 *
 * @param data - L.IssueChildWebhookPayloadFragment response data
 */
export class IssueChildWebhookPayload {
  public constructor(data: L.IssueChildWebhookPayloadFragment) {
    this.id = data.id;
    this.identifier = data.identifier;
    this.teamId = data.teamId;
    this.title = data.title;
    this.url = data.url;
    this.team = new TeamChildWebhookPayload(data.team);
  }

  /** The ID of the issue. */
  public id: string;
  /** The identifier of the issue. */
  public identifier: string;
  /** The ID of the team that the issue belongs to. */
  public teamId: string;
  /** The title of the issue. */
  public title: string;
  /** The URL of the issue. */
  public url: string;
  /** The ID of the team that the issue belongs to. */
  public team: TeamChildWebhookPayload;
}
/**
 * Payload for an issue comment mention notification.
 *
 * @param data - L.IssueCommentMentionNotificationWebhookPayloadFragment response data
 */
export class IssueCommentMentionNotificationWebhookPayload {
  public constructor(data: L.IssueCommentMentionNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.comment = new CommentChildWebhookPayload(data.comment);
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
    this.parentComment = data.parentComment ? new CommentChildWebhookPayload(data.parentComment) : undefined;
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment this notification belongs to. */
  public commentId: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** The ID of the parent comment for the comment this notification belongs to. */
  public parentCommentId?: string;
  /** An issue comment mention notification type. */
  public type: "issueCommentMention";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The comment this notification belongs to. */
  public comment: CommentChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
  /** The parent comment for the comment this notification belongs to. */
  public parentComment?: CommentChildWebhookPayload;
}
/**
 * Payload for an issue comment reaction notification.
 *
 * @param data - L.IssueCommentReactionNotificationWebhookPayloadFragment response data
 */
export class IssueCommentReactionNotificationWebhookPayload {
  public constructor(data: L.IssueCommentReactionNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.reactionEmoji = data.reactionEmoji;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.comment = new CommentChildWebhookPayload(data.comment);
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
    this.parentComment = data.parentComment ? new CommentChildWebhookPayload(data.parentComment) : undefined;
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment this notification belongs to. */
  public commentId: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** The ID of the parent comment for the comment this notification belongs to. */
  public parentCommentId?: string;
  /** The emoji of the reaction this notification is for. */
  public reactionEmoji: string;
  /** An issue comment reaction notification type. */
  public type: "issueCommentReaction";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The comment this notification belongs to. */
  public comment: CommentChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
  /** The parent comment for the comment this notification belongs to. */
  public parentComment?: CommentChildWebhookPayload;
}
/**
 * IssueConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueConnection model
 * @param data - IssueConnection response data
 */
export class IssueConnection extends Connection<Issue> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Issue> | undefined>,
    data: L.IssueConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Issue(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Payload for an issue emoji reaction notification.
 *
 * @param data - L.IssueEmojiReactionNotificationWebhookPayloadFragment response data
 */
export class IssueEmojiReactionNotificationWebhookPayload {
  public constructor(data: L.IssueEmojiReactionNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.reactionEmoji = data.reactionEmoji;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** The emoji of the reaction this notification is for. */
  public reactionEmoji: string;
  /** An issue emoji reaction notification type. */
  public type: "issueEmojiReaction";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
}
/**
 * IssueFilterSuggestionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueFilterSuggestionPayloadFragment response data
 */
export class IssueFilterSuggestionPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueFilterSuggestionPayloadFragment) {
    super(request);
    this.filter = data.filter ?? undefined;
    this.logId = data.logId ?? undefined;
  }

  /** The json filter that is suggested. */
  public filter?: L.Scalars["JSONObject"];
  /** The log id of the prompt, that created this filter. */
  public logId?: string;
}
/**
 * A record of changes to an issue.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueHistoryFragment response data
 */
export class IssueHistory extends Request {
  private _actor?: L.IssueHistoryFragment["actor"];
  private _attachment?: L.IssueHistoryFragment["attachment"];
  private _fromAssignee?: L.IssueHistoryFragment["fromAssignee"];
  private _fromCycle?: L.IssueHistoryFragment["fromCycle"];
  private _fromParent?: L.IssueHistoryFragment["fromParent"];
  private _fromProject?: L.IssueHistoryFragment["fromProject"];
  private _fromState?: L.IssueHistoryFragment["fromState"];
  private _fromTeam?: L.IssueHistoryFragment["fromTeam"];
  private _issue: L.IssueHistoryFragment["issue"];
  private _toAssignee?: L.IssueHistoryFragment["toAssignee"];
  private _toConvertedProject?: L.IssueHistoryFragment["toConvertedProject"];
  private _toCycle?: L.IssueHistoryFragment["toCycle"];
  private _toParent?: L.IssueHistoryFragment["toParent"];
  private _toProject?: L.IssueHistoryFragment["toProject"];
  private _toState?: L.IssueHistoryFragment["toState"];
  private _toTeam?: L.IssueHistoryFragment["toTeam"];

  public constructor(request: LinearRequest, data: L.IssueHistoryFragment) {
    super(request);
    this.actorId = data.actorId ?? undefined;
    this.addedLabelIds = data.addedLabelIds ?? undefined;
    this.archived = data.archived ?? undefined;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.attachmentId = data.attachmentId ?? undefined;
    this.autoArchived = data.autoArchived ?? undefined;
    this.autoClosed = data.autoClosed ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.customerNeedId = data.customerNeedId ?? undefined;
    this.fromAssigneeId = data.fromAssigneeId ?? undefined;
    this.fromCycleId = data.fromCycleId ?? undefined;
    this.fromDueDate = data.fromDueDate ?? undefined;
    this.fromEstimate = data.fromEstimate ?? undefined;
    this.fromParentId = data.fromParentId ?? undefined;
    this.fromPriority = data.fromPriority ?? undefined;
    this.fromProjectId = data.fromProjectId ?? undefined;
    this.fromStateId = data.fromStateId ?? undefined;
    this.fromTeamId = data.fromTeamId ?? undefined;
    this.fromTitle = data.fromTitle ?? undefined;
    this.id = data.id;
    this.removedLabelIds = data.removedLabelIds ?? undefined;
    this.toAssigneeId = data.toAssigneeId ?? undefined;
    this.toConvertedProjectId = data.toConvertedProjectId ?? undefined;
    this.toCycleId = data.toCycleId ?? undefined;
    this.toDueDate = data.toDueDate ?? undefined;
    this.toEstimate = data.toEstimate ?? undefined;
    this.toParentId = data.toParentId ?? undefined;
    this.toPriority = data.toPriority ?? undefined;
    this.toProjectId = data.toProjectId ?? undefined;
    this.toStateId = data.toStateId ?? undefined;
    this.toTeamId = data.toTeamId ?? undefined;
    this.toTitle = data.toTitle ?? undefined;
    this.trashed = data.trashed ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.updatedDescription = data.updatedDescription ?? undefined;
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this.issueImport = data.issueImport ? new IssueImport(request, data.issueImport) : undefined;
    this.actors = data.actors ? data.actors.map(node => new User(request, node)) : undefined;
    this.addedLabels = data.addedLabels ? data.addedLabels.map(node => new IssueLabel(request, node)) : undefined;
    this.descriptionUpdatedBy = data.descriptionUpdatedBy
      ? data.descriptionUpdatedBy.map(node => new User(request, node))
      : undefined;
    this.relationChanges = data.relationChanges
      ? data.relationChanges.map(node => new IssueRelationHistoryPayload(request, node))
      : undefined;
    this.removedLabels = data.removedLabels ? data.removedLabels.map(node => new IssueLabel(request, node)) : undefined;
    this.triageResponsibilityNotifiedUsers = data.triageResponsibilityNotifiedUsers
      ? data.triageResponsibilityNotifiedUsers.map(node => new User(request, node))
      : undefined;
    this._actor = data.actor ?? undefined;
    this._attachment = data.attachment ?? undefined;
    this._fromAssignee = data.fromAssignee ?? undefined;
    this._fromCycle = data.fromCycle ?? undefined;
    this._fromParent = data.fromParent ?? undefined;
    this._fromProject = data.fromProject ?? undefined;
    this._fromState = data.fromState ?? undefined;
    this._fromTeam = data.fromTeam ?? undefined;
    this._issue = data.issue;
    this._toAssignee = data.toAssignee ?? undefined;
    this._toConvertedProject = data.toConvertedProject ?? undefined;
    this._toCycle = data.toCycle ?? undefined;
    this._toParent = data.toParent ?? undefined;
    this._toProject = data.toProject ?? undefined;
    this._toState = data.toState ?? undefined;
    this._toTeam = data.toTeam ?? undefined;
  }

  /** The id of user who made these changes. If null, possibly means that the change made by an integration. */
  public actorId?: string;
  /** ID's of labels that were added. */
  public addedLabelIds?: string[];
  /** Whether the issue is archived at the time of this history entry. */
  public archived?: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The id of linked attachment. */
  public attachmentId?: string;
  /** Whether the issue was auto-archived. */
  public autoArchived?: boolean;
  /** Whether the issue was auto-closed. */
  public autoClosed?: boolean;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The id of linked customer need. */
  public customerNeedId?: string;
  /** The id of user from whom the issue was re-assigned from. */
  public fromAssigneeId?: string;
  /** The id of previous cycle of the issue. */
  public fromCycleId?: string;
  /** What the due date was changed from. */
  public fromDueDate?: L.Scalars["TimelessDate"];
  /** What the estimate was changed from. */
  public fromEstimate?: number;
  /** The id of previous parent of the issue. */
  public fromParentId?: string;
  /** What the priority was changed from. */
  public fromPriority?: number;
  /** The id of previous project of the issue. */
  public fromProjectId?: string;
  /** The id of previous workflow state of the issue. */
  public fromStateId?: string;
  /** The id of team from which the issue was moved from. */
  public fromTeamId?: string;
  /** What the title was changed from. */
  public fromTitle?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** ID's of labels that were removed. */
  public removedLabelIds?: string[];
  /** The id of user to whom the issue was assigned to. */
  public toAssigneeId?: string;
  /** The id of new project created from the issue. */
  public toConvertedProjectId?: string;
  /** The id of new cycle of the issue. */
  public toCycleId?: string;
  /** What the due date was changed to. */
  public toDueDate?: L.Scalars["TimelessDate"];
  /** What the estimate was changed to. */
  public toEstimate?: number;
  /** The id of new parent of the issue. */
  public toParentId?: string;
  /** What the priority was changed to. */
  public toPriority?: number;
  /** The id of new project of the issue. */
  public toProjectId?: string;
  /** The id of new workflow state of the issue. */
  public toStateId?: string;
  /** The id of team to which the issue was moved to. */
  public toTeamId?: string;
  /** What the title was changed to. */
  public toTitle?: string;
  /** Whether the issue was trashed or un-trashed. */
  public trashed?: boolean;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Whether the issue's description was updated. */
  public updatedDescription?: boolean;
  /** The actors that performed the actions. This field may be empty in the case of integrations or automations. */
  public actors?: User[];
  /** The labels that were added to the issue. */
  public addedLabels?: IssueLabel[];
  /** The actors that edited the description of the issue, if any. */
  public descriptionUpdatedBy?: User[];
  /** Changed issue relationships. */
  public relationChanges?: IssueRelationHistoryPayload[];
  /** The labels that were removed from the issue. */
  public removedLabels?: IssueLabel[];
  /** The users that were notified of the issue. */
  public triageResponsibilityNotifiedUsers?: User[];
  /** The bot that performed the action. */
  public botActor?: ActorBot;
  /** The import record. */
  public issueImport?: IssueImport;
  /** The actor that performed the actions. This field may be empty in the case of integrations or automations. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The linked attachment. */
  public get attachment(): LinearFetch<Attachment> | undefined {
    return this._attachment?.id ? new AttachmentQuery(this._request).fetch(this._attachment?.id) : undefined;
  }
  /** The user that was unassigned from the issue. */
  public get fromAssignee(): LinearFetch<User> | undefined {
    return this._fromAssignee?.id ? new UserQuery(this._request).fetch(this._fromAssignee?.id) : undefined;
  }
  /** The cycle that the issue was moved from. */
  public get fromCycle(): LinearFetch<Cycle> | undefined {
    return this._fromCycle?.id ? new CycleQuery(this._request).fetch(this._fromCycle?.id) : undefined;
  }
  /** The parent issue that the issue was moved from. */
  public get fromParent(): LinearFetch<Issue> | undefined {
    return this._fromParent?.id ? new IssueQuery(this._request).fetch(this._fromParent?.id) : undefined;
  }
  /** The project that the issue was moved from. */
  public get fromProject(): LinearFetch<Project> | undefined {
    return this._fromProject?.id ? new ProjectQuery(this._request).fetch(this._fromProject?.id) : undefined;
  }
  /** The state that the issue was moved from. */
  public get fromState(): LinearFetch<WorkflowState> | undefined {
    return this._fromState?.id ? new WorkflowStateQuery(this._request).fetch(this._fromState?.id) : undefined;
  }
  /** The team that the issue was moved from. */
  public get fromTeam(): LinearFetch<Team> | undefined {
    return this._fromTeam?.id ? new TeamQuery(this._request).fetch(this._fromTeam?.id) : undefined;
  }
  /** The issue that was changed. */
  public get issue(): LinearFetch<Issue> | undefined {
    return new IssueQuery(this._request).fetch(this._issue.id);
  }
  /** The ID of issue that was changed. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The user that was assigned to the issue. */
  public get toAssignee(): LinearFetch<User> | undefined {
    return this._toAssignee?.id ? new UserQuery(this._request).fetch(this._toAssignee?.id) : undefined;
  }
  /** The new project created from the issue. */
  public get toConvertedProject(): LinearFetch<Project> | undefined {
    return this._toConvertedProject?.id
      ? new ProjectQuery(this._request).fetch(this._toConvertedProject?.id)
      : undefined;
  }
  /** The cycle that the issue was moved to. */
  public get toCycle(): LinearFetch<Cycle> | undefined {
    return this._toCycle?.id ? new CycleQuery(this._request).fetch(this._toCycle?.id) : undefined;
  }
  /** The parent issue that the issue was moved to. */
  public get toParent(): LinearFetch<Issue> | undefined {
    return this._toParent?.id ? new IssueQuery(this._request).fetch(this._toParent?.id) : undefined;
  }
  /** The project that the issue was moved to. */
  public get toProject(): LinearFetch<Project> | undefined {
    return this._toProject?.id ? new ProjectQuery(this._request).fetch(this._toProject?.id) : undefined;
  }
  /** The state that the issue was moved to. */
  public get toState(): LinearFetch<WorkflowState> | undefined {
    return this._toState?.id ? new WorkflowStateQuery(this._request).fetch(this._toState?.id) : undefined;
  }
  /** The team that the issue was moved to. */
  public get toTeam(): LinearFetch<Team> | undefined {
    return this._toTeam?.id ? new TeamQuery(this._request).fetch(this._toTeam?.id) : undefined;
  }
}
/**
 * IssueHistoryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueHistoryConnection model
 * @param data - IssueHistoryConnection response data
 */
export class IssueHistoryConnection extends Connection<IssueHistory> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueHistory> | undefined>,
    data: L.IssueHistoryConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new IssueHistory(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * An import job for data from an external service.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportFragment response data
 */
export class IssueImport extends Request {
  public constructor(request: LinearRequest, data: L.IssueImportFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.creatorId = data.creatorId ?? undefined;
    this.csvFileUrl = data.csvFileUrl ?? undefined;
    this.displayName = data.displayName;
    this.error = data.error ?? undefined;
    this.errorMetadata = data.errorMetadata ?? undefined;
    this.id = data.id;
    this.mapping = data.mapping ?? undefined;
    this.progress = data.progress ?? undefined;
    this.service = data.service;
    this.serviceMetadata = data.serviceMetadata ?? undefined;
    this.status = data.status;
    this.teamName = data.teamName ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The id for the user that started the job. */
  public creatorId?: string;
  /** File URL for the uploaded CSV for the import, if there is one. */
  public csvFileUrl?: string;
  /** The display name of the import service. */
  public displayName: string;
  /** User readable error message, if one has occurred during the import. */
  public error?: string;
  /** Error code and metadata, if one has occurred during the import. */
  public errorMetadata?: L.Scalars["JSONObject"];
  /** The unique identifier of the entity. */
  public id: string;
  /** The data mapping configuration for the import job. */
  public mapping?: L.Scalars["JSONObject"];
  /** Current step progress in % (0-100). */
  public progress?: number;
  /** The service from which data will be imported. */
  public service: string;
  /** Metadata related to import service. */
  public serviceMetadata?: L.Scalars["JSONObject"];
  /** The status for the import job. */
  public status: string;
  /** New team's name in cases when teamId not set. */
  public teamName?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;

  /** Deletes an import job. */
  public delete(issueImportId: string) {
    return new DeleteIssueImportMutation(this._request).fetch(issueImportId);
  }
  /** Updates the mapping for the issue import. */
  public update(input: L.IssueImportUpdateInput) {
    return new UpdateIssueImportMutation(this._request).fetch(this.id, input);
  }
}
/**
 * IssueImportCheckPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportCheckPayloadFragment response data
 */
export class IssueImportCheckPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueImportCheckPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * IssueImportDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportDeletePayloadFragment response data
 */
export class IssueImportDeletePayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueImportDeletePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.issueImport = data.issueImport ? new IssueImport(request, data.issueImport) : undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The import job that was deleted. */
  public issueImport?: IssueImport;
}
/**
 * Whether a custom JQL query is valid or not
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportJqlCheckPayloadFragment response data
 */
export class IssueImportJqlCheckPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueImportJqlCheckPayloadFragment) {
    super(request);
    this.count = data.count ?? undefined;
    this.error = data.error ?? undefined;
    this.success = data.success;
  }

  /** Returns an approximate number of issues matching the JQL query, if available */
  public count?: number;
  /** An error message returned by Jira when validating the JQL query. */
  public error?: string;
  /** Returns true if the JQL query has been validated successfully, false otherwise */
  public success: boolean;
}
/**
 * IssueImportPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportPayloadFragment response data
 */
export class IssueImportPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueImportPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.issueImport = data.issueImport ? new IssueImport(request, data.issueImport) : undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The import job that was created or updated. */
  public issueImport?: IssueImport;
}
/**
 * Whether an issue import can be synced at the end of an import or not
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueImportSyncCheckPayloadFragment response data
 */
export class IssueImportSyncCheckPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueImportSyncCheckPayloadFragment) {
    super(request);
    this.canSync = data.canSync;
    this.error = data.error ?? undefined;
  }

  /** Returns true if the import can be synced, false otherwise */
  public canSync: boolean;
  /** An error message with a root cause of why the import cannot be synced */
  public error?: string;
}
/**
 * Labels that can be associated with issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueLabelFragment response data
 */
export class IssueLabel extends Request {
  private _creator?: L.IssueLabelFragment["creator"];
  private _inheritedFrom?: L.IssueLabelFragment["inheritedFrom"];
  private _parent?: L.IssueLabelFragment["parent"];
  private _team?: L.IssueLabelFragment["team"];

  public constructor(request: LinearRequest, data: L.IssueLabelFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.isGroup = data.isGroup;
    this.lastAppliedAt = parseDate(data.lastAppliedAt) ?? undefined;
    this.name = data.name;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._creator = data.creator ?? undefined;
    this._inheritedFrom = data.inheritedFrom ?? undefined;
    this._parent = data.parent ?? undefined;
    this._team = data.team ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The label's color as a HEX string. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The label's description. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the label is a group. */
  public isGroup: boolean;
  /** The date when the label was last applied to an issue or project. */
  public lastAppliedAt?: Date;
  /** The label's name. */
  public name: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user who created the label. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the label. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The original label inherited from. */
  public get inheritedFrom(): LinearFetch<IssueLabel> | undefined {
    return this._inheritedFrom?.id ? new IssueLabelQuery(this._request).fetch(this._inheritedFrom?.id) : undefined;
  }
  /** The ID of original label inherited from. */
  public get inheritedFromId(): string | undefined {
    return this._inheritedFrom?.id;
  }
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The parent label. */
  public get parent(): LinearFetch<IssueLabel> | undefined {
    return this._parent?.id ? new IssueLabelQuery(this._request).fetch(this._parent?.id) : undefined;
  }
  /** The ID of parent label. */
  public get parentId(): string | undefined {
    return this._parent?.id;
  }
  /** The team that the label is associated with. If null, the label is associated with the global workspace. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team that the label is associated with. if null, the label is associated with the global workspace. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** Children of the label. */
  public children(variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">) {
    return new IssueLabel_ChildrenQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Issues associated with the label. */
  public issues(variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">) {
    return new IssueLabel_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new label. */
  public create(input: L.IssueLabelCreateInput, variables?: Omit<L.CreateIssueLabelMutationVariables, "input">) {
    return new CreateIssueLabelMutation(this._request).fetch(input, variables);
  }
  /** Deletes an issue label. */
  public delete() {
    return new DeleteIssueLabelMutation(this._request).fetch(this.id);
  }
  /** Updates an label. */
  public update(input: L.IssueLabelUpdateInput, variables?: Omit<L.UpdateIssueLabelMutationVariables, "id" | "input">) {
    return new UpdateIssueLabelMutation(this._request).fetch(this.id, input, variables);
  }
}
/**
 * Certain properties of an issue label.
 *
 * @param data - L.IssueLabelChildWebhookPayloadFragment response data
 */
export class IssueLabelChildWebhookPayload {
  public constructor(data: L.IssueLabelChildWebhookPayloadFragment) {
    this.color = data.color;
    this.id = data.id;
    this.name = data.name;
    this.parentId = data.parentId ?? undefined;
  }

  /** The color of the issue label. */
  public color: string;
  /** The ID of the issue label. */
  public id: string;
  /** The name of the issue label. */
  public name: string;
  /** The parent ID of the issue label. */
  public parentId?: string;
}
/**
 * IssueLabelConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueLabelConnection model
 * @param data - IssueLabelConnection response data
 */
export class IssueLabelConnection extends Connection<IssueLabel> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueLabel> | undefined>,
    data: L.IssueLabelConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new IssueLabel(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * IssueLabelPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueLabelPayloadFragment response data
 */
export class IssueLabelPayload extends Request {
  private _issueLabel: L.IssueLabelPayloadFragment["issueLabel"];

  public constructor(request: LinearRequest, data: L.IssueLabelPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._issueLabel = data.issueLabel;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The label that was created or updated. */
  public get issueLabel(): LinearFetch<IssueLabel> | undefined {
    return new IssueLabelQuery(this._request).fetch(this._issueLabel.id);
  }
  /** The ID of label that was created or updated. */
  public get issueLabelId(): string | undefined {
    return this._issueLabel?.id;
  }
}
/**
 * Payload for an issue label webhook.
 *
 * @param data - L.IssueLabelWebhookPayloadFragment response data
 */
export class IssueLabelWebhookPayload {
  public constructor(data: L.IssueLabelWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.color = data.color;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.inheritedFromId = data.inheritedFromId ?? undefined;
    this.isGroup = data.isGroup;
    this.name = data.name;
    this.parentId = data.parentId ?? undefined;
    this.teamId = data.teamId ?? undefined;
    this.updatedAt = data.updatedAt;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The color of the issue label. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The creator ID of the issue label. */
  public creatorId?: string;
  /** The label's description. */
  public description?: string;
  /** The ID of the entity. */
  public id: string;
  /** The original label inherited from. */
  public inheritedFromId?: string;
  /** Whether the label is a group. */
  public isGroup: boolean;
  /** The name of the issue label. */
  public name: string;
  /** The parent ID of the issue label. */
  public parentId?: string;
  /** The team ID of the issue label. */
  public teamId?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
}
/**
 * Payload for an issue mention notification.
 *
 * @param data - L.IssueMentionNotificationWebhookPayloadFragment response data
 */
export class IssueMentionNotificationWebhookPayload {
  public constructor(data: L.IssueMentionNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** An issue mention notification type. */
  public type: "issueMention";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
}
/**
 * Payload for an issue new comment notification.
 *
 * @param data - L.IssueNewCommentNotificationWebhookPayloadFragment response data
 */
export class IssueNewCommentNotificationWebhookPayload {
  public constructor(data: L.IssueNewCommentNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.comment = new CommentChildWebhookPayload(data.comment);
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
    this.parentComment = data.parentComment ? new CommentChildWebhookPayload(data.parentComment) : undefined;
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment this notification belongs to. */
  public commentId: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** The ID of the parent comment for the comment this notification belongs to. */
  public parentCommentId?: string;
  /** An issue new comment notification type. */
  public type: "issueNewComment";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The comment this notification belongs to. */
  public comment: CommentChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
  /** The parent comment for the comment this notification belongs to. */
  public parentComment?: CommentChildWebhookPayload;
}
/**
 * An issue related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueNotificationFragment response data
 */
export class IssueNotification extends Request {
  private _actor?: L.IssueNotificationFragment["actor"];
  private _comment?: L.IssueNotificationFragment["comment"];
  private _externalUserActor?: L.IssueNotificationFragment["externalUserActor"];
  private _issue: L.IssueNotificationFragment["issue"];
  private _parentComment?: L.IssueNotificationFragment["parentComment"];
  private _team: L.IssueNotificationFragment["team"];
  private _user: L.IssueNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.IssueNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this.subscriptions = data.subscriptions
      ? data.subscriptions.map(node => new NotificationSubscription(request, node))
      : undefined;
    this._actor = data.actor ?? undefined;
    this._comment = data.comment ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._issue = data.issue;
    this._parentComment = data.parentComment ?? undefined;
    this._team = data.team;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Related comment ID. Null if the notification is not related to a comment. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related issue ID. */
  public issueId: string;
  /** Related parent comment ID. Null if the notification is not related to a comment. */
  public parentCommentId?: string;
  /** Name of the reaction emoji related to the notification. */
  public reactionEmoji?: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The subscriptions related to the notification. */
  public subscriptions?: NotificationSubscription[];
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The comment related to the notification. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The issue related to the notification. */
  public get issue(): LinearFetch<Issue> | undefined {
    return new IssueQuery(this._request).fetch(this._issue.id);
  }
  /** The parent comment related to the notification, if a notification is a reply comment notification. */
  public get parentComment(): LinearFetch<Comment> | undefined {
    return this._parentComment?.id ? new CommentQuery(this._request).fetch({ id: this._parentComment?.id }) : undefined;
  }
  /** The team related to the issue notification. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team related to the issue notification. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * IssuePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssuePayloadFragment response data
 */
export class IssuePayload extends Request {
  private _issue?: L.IssuePayloadFragment["issue"];

  public constructor(request: LinearRequest, data: L.IssuePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._issue = data.issue ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The issue that was created or updated. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue that was created or updated. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
}
/**
 * IssuePriorityValue model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssuePriorityValueFragment response data
 */
export class IssuePriorityValue extends Request {
  public constructor(request: LinearRequest, data: L.IssuePriorityValueFragment) {
    super(request);
    this.label = data.label;
    this.priority = data.priority;
  }

  /** Priority's label. */
  public label: string;
  /** Priority's number value. */
  public priority: number;
}
/**
 * A relation between two issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationFragment response data
 */
export class IssueRelation extends Request {
  private _issue: L.IssueRelationFragment["issue"];
  private _relatedIssue: L.IssueRelationFragment["relatedIssue"];

  public constructor(request: LinearRequest, data: L.IssueRelationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._issue = data.issue;
    this._relatedIssue = data.relatedIssue;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The relationship of the issue with the related issue. */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The issue whose relationship is being described. */
  public get issue(): LinearFetch<Issue> | undefined {
    return new IssueQuery(this._request).fetch(this._issue.id);
  }
  /** The ID of issue whose relationship is being described. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The related issue. */
  public get relatedIssue(): LinearFetch<Issue> | undefined {
    return new IssueQuery(this._request).fetch(this._relatedIssue.id);
  }
  /** The ID of related issue. */
  public get relatedIssueId(): string | undefined {
    return this._relatedIssue?.id;
  }

  /** Creates a new issue relation. */
  public create(input: L.IssueRelationCreateInput, variables?: Omit<L.CreateIssueRelationMutationVariables, "input">) {
    return new CreateIssueRelationMutation(this._request).fetch(input, variables);
  }
  /** Deletes an issue relation. */
  public delete() {
    return new DeleteIssueRelationMutation(this._request).fetch(this.id);
  }
  /** Updates an issue relation. */
  public update(input: L.IssueRelationUpdateInput) {
    return new UpdateIssueRelationMutation(this._request).fetch(this.id, input);
  }
}
/**
 * IssueRelationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueRelationConnection model
 * @param data - IssueRelationConnection response data
 */
export class IssueRelationConnection extends Connection<IssueRelation> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueRelation> | undefined>,
    data: L.IssueRelationConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new IssueRelation(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Issue relation history's payload.
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationHistoryPayloadFragment response data
 */
export class IssueRelationHistoryPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueRelationHistoryPayloadFragment) {
    super(request);
    this.identifier = data.identifier;
    this.type = data.type;
  }

  /** The identifier of the related issue. */
  public identifier: string;
  /** The type of the change. */
  public type: string;
}
/**
 * IssueRelationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueRelationPayloadFragment response data
 */
export class IssueRelationPayload extends Request {
  private _issueRelation: L.IssueRelationPayloadFragment["issueRelation"];

  public constructor(request: LinearRequest, data: L.IssueRelationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._issueRelation = data.issueRelation;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The issue relation that was created or updated. */
  public get issueRelation(): LinearFetch<IssueRelation> | undefined {
    return new IssueRelationQuery(this._request).fetch(this._issueRelation.id);
  }
  /** The ID of issue relation that was created or updated. */
  public get issueRelationId(): string | undefined {
    return this._issueRelation?.id;
  }
}
/**
 * IssueSearchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueSearchPayloadFragment response data
 */
export class IssueSearchPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueSearchPayloadFragment) {
    super(request);
    this.totalCount = data.totalCount;
    this.archivePayload = new ArchiveResponse(request, data.archivePayload);
    this.pageInfo = new PageInfo(request, data.pageInfo);
    this.nodes = data.nodes.map(node => new IssueSearchResult(request, node));
  }

  /** Total number of results for query without filters applied. */
  public totalCount: number;
  public nodes: IssueSearchResult[];
  /** Archived entities matching the search term along with all their dependencies. */
  public archivePayload: ArchiveResponse;
  public pageInfo: PageInfo;
}
/**
 * IssueSearchResult model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueSearchResultFragment response data
 */
export class IssueSearchResult extends Request {
  private _assignee?: L.IssueSearchResultFragment["assignee"];
  private _creator?: L.IssueSearchResultFragment["creator"];
  private _cycle?: L.IssueSearchResultFragment["cycle"];
  private _delegate?: L.IssueSearchResultFragment["delegate"];
  private _externalUserCreator?: L.IssueSearchResultFragment["externalUserCreator"];
  private _favorite?: L.IssueSearchResultFragment["favorite"];
  private _lastAppliedTemplate?: L.IssueSearchResultFragment["lastAppliedTemplate"];
  private _parent?: L.IssueSearchResultFragment["parent"];
  private _project?: L.IssueSearchResultFragment["project"];
  private _projectMilestone?: L.IssueSearchResultFragment["projectMilestone"];
  private _recurringIssueTemplate?: L.IssueSearchResultFragment["recurringIssueTemplate"];
  private _snoozedBy?: L.IssueSearchResultFragment["snoozedBy"];
  private _sourceComment?: L.IssueSearchResultFragment["sourceComment"];
  private _state: L.IssueSearchResultFragment["state"];
  private _team: L.IssueSearchResultFragment["team"];

  public constructor(request: LinearRequest, data: L.IssueSearchResultFragment) {
    super(request);
    this.addedToCycleAt = parseDate(data.addedToCycleAt) ?? undefined;
    this.addedToProjectAt = parseDate(data.addedToProjectAt) ?? undefined;
    this.addedToTeamAt = parseDate(data.addedToTeamAt) ?? undefined;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoArchivedAt = parseDate(data.autoArchivedAt) ?? undefined;
    this.autoClosedAt = parseDate(data.autoClosedAt) ?? undefined;
    this.boardOrder = data.boardOrder;
    this.branchName = data.branchName;
    this.canceledAt = parseDate(data.canceledAt) ?? undefined;
    this.completedAt = parseDate(data.completedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.customerTicketCount = data.customerTicketCount;
    this.description = data.description ?? undefined;
    this.dueDate = data.dueDate ?? undefined;
    this.estimate = data.estimate ?? undefined;
    this.id = data.id;
    this.identifier = data.identifier;
    this.labelIds = data.labelIds;
    this.metadata = data.metadata;
    this.number = data.number;
    this.previousIdentifiers = data.previousIdentifiers;
    this.priority = data.priority;
    this.priorityLabel = data.priorityLabel;
    this.prioritySortOrder = data.prioritySortOrder;
    this.reactionData = data.reactionData;
    this.slaBreachesAt = parseDate(data.slaBreachesAt) ?? undefined;
    this.slaHighRiskAt = parseDate(data.slaHighRiskAt) ?? undefined;
    this.slaMediumRiskAt = parseDate(data.slaMediumRiskAt) ?? undefined;
    this.slaStartedAt = parseDate(data.slaStartedAt) ?? undefined;
    this.slaType = data.slaType ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.sortOrder = data.sortOrder;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.startedTriageAt = parseDate(data.startedTriageAt) ?? undefined;
    this.subIssueSortOrder = data.subIssueSortOrder ?? undefined;
    this.title = data.title;
    this.trashed = data.trashed ?? undefined;
    this.triagedAt = parseDate(data.triagedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this.reactions = data.reactions.map(node => new Reaction(request, node));
    this.syncedWith = data.syncedWith ? data.syncedWith.map(node => new ExternalEntityInfo(request, node)) : undefined;
    this.integrationSourceType = data.integrationSourceType ?? undefined;
    this._assignee = data.assignee ?? undefined;
    this._creator = data.creator ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._delegate = data.delegate ?? undefined;
    this._externalUserCreator = data.externalUserCreator ?? undefined;
    this._favorite = data.favorite ?? undefined;
    this._lastAppliedTemplate = data.lastAppliedTemplate ?? undefined;
    this._parent = data.parent ?? undefined;
    this._project = data.project ?? undefined;
    this._projectMilestone = data.projectMilestone ?? undefined;
    this._recurringIssueTemplate = data.recurringIssueTemplate ?? undefined;
    this._snoozedBy = data.snoozedBy ?? undefined;
    this._sourceComment = data.sourceComment ?? undefined;
    this._state = data.state;
    this._team = data.team;
  }

  /** The time at which the issue was added to a cycle. */
  public addedToCycleAt?: Date;
  /** The time at which the issue was added to a project. */
  public addedToProjectAt?: Date;
  /** The time at which the issue was added to a team. */
  public addedToTeamAt?: Date;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the issue was automatically archived by the auto pruning process. */
  public autoArchivedAt?: Date;
  /** The time at which the issue was automatically closed by the auto pruning process. */
  public autoClosedAt?: Date;
  /** The order of the item in its column on the board. */
  public boardOrder: number;
  /** Suggested branch name for the issue. */
  public branchName: string;
  /** The time at which the issue was moved into canceled state. */
  public canceledAt?: Date;
  /** The time at which the issue was moved into completed state. */
  public completedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk). */
  public customerTicketCount: number;
  /** The issue's description in markdown format. */
  public description?: string;
  /** The date at which the issue is due. */
  public dueDate?: L.Scalars["TimelessDate"];
  /** The estimate of the complexity of the issue.. */
  public estimate?: number;
  /** The unique identifier of the entity. */
  public id: string;
  /** Issue's human readable identifier (e.g. ENG-123). */
  public identifier: string;
  /** Id of the labels associated with this issue. */
  public labelIds: string[];
  /** Metadata related to search result. */
  public metadata: L.Scalars["JSONObject"];
  /** The issue's unique number. */
  public number: number;
  /** Previous identifiers of the issue if it has been moved between teams. */
  public previousIdentifiers: string[];
  /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
  public priority: number;
  /** Label for the priority. */
  public priorityLabel: string;
  /** The order of the item in relation to other items in the organization, when ordered by priority. */
  public prioritySortOrder: number;
  /** Emoji reaction summary, grouped by emoji type. */
  public reactionData: L.Scalars["JSONObject"];
  /** The time at which the issue's SLA will breach. */
  public slaBreachesAt?: Date;
  /** The time at which the issue's SLA will enter high risk state. */
  public slaHighRiskAt?: Date;
  /** The time at which the issue's SLA will enter medium risk state. */
  public slaMediumRiskAt?: Date;
  /** The time at which the issue's SLA began. */
  public slaStartedAt?: Date;
  /** The type of SLA set on the issue. Calendar days or business days. */
  public slaType?: string;
  /** The time until an issue will be snoozed in Triage view. */
  public snoozedUntilAt?: Date;
  /** The order of the item in relation to other items in the organization. */
  public sortOrder: number;
  /** The time at which the issue was moved into started state. */
  public startedAt?: Date;
  /** The time at which the issue entered triage. */
  public startedTriageAt?: Date;
  /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
  public subIssueSortOrder?: number;
  /** The issue's title. */
  public title: string;
  /** A flag that indicates whether the issue is in the trash bin. */
  public trashed?: boolean;
  /** The time at which the issue left triage. */
  public triagedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Issue URL. */
  public url: string;
  /** Reactions associated with the issue. */
  public reactions: Reaction[];
  /** The external services the issue is synced with. */
  public syncedWith?: ExternalEntityInfo[];
  /** The bot that created the issue, if applicable. */
  public botActor?: ActorBot;
  /** Integration type that created this issue, if applicable. */
  public integrationSourceType?: L.IntegrationService;
  /** The user to whom the issue is assigned to. */
  public get assignee(): LinearFetch<User> | undefined {
    return this._assignee?.id ? new UserQuery(this._request).fetch(this._assignee?.id) : undefined;
  }
  /** The ID of user to whom the issue is assigned to. */
  public get assigneeId(): string | undefined {
    return this._assignee?.id;
  }
  /** The user who created the issue. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the issue. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The cycle that the issue is associated with. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of cycle that the issue is associated with. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The app user that is delegated to work on this issue. */
  public get delegate(): LinearFetch<User> | undefined {
    return this._delegate?.id ? new UserQuery(this._request).fetch(this._delegate?.id) : undefined;
  }
  /** The ID of app user that is delegated to work on this issue. */
  public get delegateId(): string | undefined {
    return this._delegate?.id;
  }
  /** The external user who created the issue. */
  public get externalUserCreator(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserCreator?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserCreator?.id)
      : undefined;
  }
  /** The ID of external user who created the issue. */
  public get externalUserCreatorId(): string | undefined {
    return this._externalUserCreator?.id;
  }
  /** The users favorite associated with this issue. */
  public get favorite(): LinearFetch<Favorite> | undefined {
    return this._favorite?.id ? new FavoriteQuery(this._request).fetch(this._favorite?.id) : undefined;
  }
  /** The ID of users favorite associated with this issue. */
  public get favoriteId(): string | undefined {
    return this._favorite?.id;
  }
  /** The last template that was applied to this issue. */
  public get lastAppliedTemplate(): LinearFetch<Template> | undefined {
    return this._lastAppliedTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._lastAppliedTemplate?.id)
      : undefined;
  }
  /** The ID of last template that was applied to this issue. */
  public get lastAppliedTemplateId(): string | undefined {
    return this._lastAppliedTemplate?.id;
  }
  /** The parent of the issue. */
  public get parent(): LinearFetch<Issue> | undefined {
    return this._parent?.id ? new IssueQuery(this._request).fetch(this._parent?.id) : undefined;
  }
  /** The ID of parent of the issue. */
  public get parentId(): string | undefined {
    return this._parent?.id;
  }
  /** The project that the issue is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project that the issue is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The projectMilestone that the issue is associated with. */
  public get projectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return this._projectMilestone?.id
      ? new ProjectMilestoneQuery(this._request).fetch(this._projectMilestone?.id)
      : undefined;
  }
  /** The ID of projectmilestone that the issue is associated with. */
  public get projectMilestoneId(): string | undefined {
    return this._projectMilestone?.id;
  }
  /** The recurring issue template that created this issue. */
  public get recurringIssueTemplate(): LinearFetch<Template> | undefined {
    return this._recurringIssueTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._recurringIssueTemplate?.id)
      : undefined;
  }
  /** The ID of recurring issue template that created this issue. */
  public get recurringIssueTemplateId(): string | undefined {
    return this._recurringIssueTemplate?.id;
  }
  /** The user who snoozed the issue. */
  public get snoozedBy(): LinearFetch<User> | undefined {
    return this._snoozedBy?.id ? new UserQuery(this._request).fetch(this._snoozedBy?.id) : undefined;
  }
  /** The ID of user who snoozed the issue. */
  public get snoozedById(): string | undefined {
    return this._snoozedBy?.id;
  }
  /** The comment that this issue was created from. */
  public get sourceComment(): LinearFetch<Comment> | undefined {
    return this._sourceComment?.id ? new CommentQuery(this._request).fetch({ id: this._sourceComment?.id }) : undefined;
  }
  /** The ID of comment that this issue was created from. */
  public get sourceCommentId(): string | undefined {
    return this._sourceComment?.id;
  }
  /** The workflow state that the issue is associated with. */
  public get state(): LinearFetch<WorkflowState> | undefined {
    return new WorkflowStateQuery(this._request).fetch(this._state.id);
  }
  /** The ID of workflow state that the issue is associated with. */
  public get stateId(): string | undefined {
    return this._state?.id;
  }
  /** The team that the issue is associated with. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team that the issue is associated with. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
}
/**
 * Payload for issue SLA webhook events.
 *
 * @param data - L.IssueSlaWebhookPayloadFragment response data
 */
export class IssueSlaWebhookPayload {
  public constructor(data: L.IssueSlaWebhookPayloadFragment) {
    this.action = data.action;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.organizationId = data.organizationId;
    this.type = data.type;
    this.url = data.url ?? undefined;
    this.issueData = new IssueWebhookPayload(data.issueData);
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** The time the payload was created. */
  public createdAt: Date;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** The type of resource. */
  public type: string;
  /** URL for the issue. */
  public url?: string;
  /** The issue that the SLA event is about. */
  public issueData: IssueWebhookPayload;
}
/**
 * Payload for a terminal issue status change notification.
 *
 * @param data - L.IssueStatusChangedNotificationWebhookPayloadFragment response data
 */
export class IssueStatusChangedNotificationWebhookPayload {
  public constructor(data: L.IssueStatusChangedNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** A terminal issue status change notification type. */
  public type: "issueStatusChanged";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
}
/**
 * IssueSuggestion model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueSuggestionFragment response data
 */
export class IssueSuggestion extends Request {
  private _issue: L.IssueSuggestionFragment["issue"];
  private _suggestedIssue?: L.IssueSuggestionFragment["suggestedIssue"];
  private _suggestedLabel?: L.IssueSuggestionFragment["suggestedLabel"];
  private _suggestedProject?: L.IssueSuggestionFragment["suggestedProject"];
  private _suggestedTeam?: L.IssueSuggestionFragment["suggestedTeam"];
  private _suggestedUser?: L.IssueSuggestionFragment["suggestedUser"];

  public constructor(request: LinearRequest, data: L.IssueSuggestionFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.issueId = data.issueId;
    this.stateChangedAt = parseDate(data.stateChangedAt) ?? new Date();
    this.suggestedIssueId = data.suggestedIssueId ?? undefined;
    this.suggestedLabelId = data.suggestedLabelId ?? undefined;
    this.suggestedUserId = data.suggestedUserId ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.metadata = data.metadata ? new IssueSuggestionMetadata(request, data.metadata) : undefined;
    this.state = data.state;
    this.type = data.type;
    this._issue = data.issue;
    this._suggestedIssue = data.suggestedIssue ?? undefined;
    this._suggestedLabel = data.suggestedLabel ?? undefined;
    this._suggestedProject = data.suggestedProject ?? undefined;
    this._suggestedTeam = data.suggestedTeam ?? undefined;
    this._suggestedUser = data.suggestedUser ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  public issueId: string;
  public stateChangedAt: Date;
  public suggestedIssueId?: string;
  public suggestedLabelId?: string;
  public suggestedUserId?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  public metadata?: IssueSuggestionMetadata;
  public state: L.IssueSuggestionState;
  public type: L.IssueSuggestionType;
  public get issue(): LinearFetch<Issue> | undefined {
    return new IssueQuery(this._request).fetch(this._issue.id);
  }
  public get suggestedIssue(): LinearFetch<Issue> | undefined {
    return this._suggestedIssue?.id ? new IssueQuery(this._request).fetch(this._suggestedIssue?.id) : undefined;
  }
  public get suggestedLabel(): LinearFetch<IssueLabel> | undefined {
    return this._suggestedLabel?.id ? new IssueLabelQuery(this._request).fetch(this._suggestedLabel?.id) : undefined;
  }
  public get suggestedProject(): LinearFetch<Project> | undefined {
    return this._suggestedProject?.id ? new ProjectQuery(this._request).fetch(this._suggestedProject?.id) : undefined;
  }
  /** The ID of suggestedProject */
  public get suggestedProjectId(): string | undefined {
    return this._suggestedProject?.id;
  }
  public get suggestedTeam(): LinearFetch<Team> | undefined {
    return this._suggestedTeam?.id ? new TeamQuery(this._request).fetch(this._suggestedTeam?.id) : undefined;
  }
  /** The ID of suggestedTeam */
  public get suggestedTeamId(): string | undefined {
    return this._suggestedTeam?.id;
  }
  public get suggestedUser(): LinearFetch<User> | undefined {
    return this._suggestedUser?.id ? new UserQuery(this._request).fetch(this._suggestedUser?.id) : undefined;
  }
}
/**
 * IssueSuggestionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this IssueSuggestionConnection model
 * @param data - IssueSuggestionConnection response data
 */
export class IssueSuggestionConnection extends Connection<IssueSuggestion> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<IssueSuggestion> | undefined>,
    data: L.IssueSuggestionConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new IssueSuggestion(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * IssueSuggestionMetadata model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueSuggestionMetadataFragment response data
 */
export class IssueSuggestionMetadata extends Request {
  public constructor(request: LinearRequest, data: L.IssueSuggestionMetadataFragment) {
    super(request);
    this.classification = data.classification ?? undefined;
    this.evalLogId = data.evalLogId ?? undefined;
    this.reasons = data.reasons ?? undefined;
    this.score = data.score ?? undefined;
  }

  public classification?: string;
  public evalLogId?: string;
  public reasons?: string[];
  public score?: number;
}
/**
 * IssueTitleSuggestionFromCustomerRequestPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.IssueTitleSuggestionFromCustomerRequestPayloadFragment response data
 */
export class IssueTitleSuggestionFromCustomerRequestPayload extends Request {
  public constructor(request: LinearRequest, data: L.IssueTitleSuggestionFromCustomerRequestPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.title = data.title;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** The suggested issue title. */
  public title: string;
}
/**
 * Payload for an issue unassignment notification.
 *
 * @param data - L.IssueUnassignedFromYouNotificationWebhookPayloadFragment response data
 */
export class IssueUnassignedFromYouNotificationWebhookPayload {
  public constructor(data: L.IssueUnassignedFromYouNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId;
    this.type = data.type;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.issue = new IssueWithDescriptionChildWebhookPayload(data.issue);
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId: string;
  /** An issue unassignment notification type. */
  public type: "issueUnassignedFromYou";
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue: IssueWithDescriptionChildWebhookPayload;
}
/**
 * Payload for an issue webhook.
 *
 * @param data - L.IssueWebhookPayloadFragment response data
 */
export class IssueWebhookPayload {
  public constructor(data: L.IssueWebhookPayloadFragment) {
    this.addedToCycleAt = data.addedToCycleAt ?? undefined;
    this.addedToProjectAt = data.addedToProjectAt ?? undefined;
    this.addedToTeamAt = data.addedToTeamAt ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.assigneeId = data.assigneeId ?? undefined;
    this.autoArchivedAt = data.autoArchivedAt ?? undefined;
    this.autoClosedAt = data.autoClosedAt ?? undefined;
    this.botActor = data.botActor ?? undefined;
    this.canceledAt = data.canceledAt ?? undefined;
    this.completedAt = data.completedAt ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.cycleId = data.cycleId ?? undefined;
    this.description = data.description ?? undefined;
    this.descriptionData = data.descriptionData ?? undefined;
    this.dueDate = data.dueDate ?? undefined;
    this.estimate = data.estimate ?? undefined;
    this.externalUserCreatorId = data.externalUserCreatorId ?? undefined;
    this.id = data.id;
    this.identifier = data.identifier;
    this.integrationSourceType = data.integrationSourceType ?? undefined;
    this.labelIds = data.labelIds;
    this.lastAppliedTemplateId = data.lastAppliedTemplateId ?? undefined;
    this.number = data.number;
    this.parentId = data.parentId ?? undefined;
    this.previousIdentifiers = data.previousIdentifiers;
    this.priority = data.priority;
    this.priorityLabel = data.priorityLabel;
    this.prioritySortOrder = data.prioritySortOrder;
    this.projectId = data.projectId ?? undefined;
    this.projectMilestoneId = data.projectMilestoneId ?? undefined;
    this.reactionData = data.reactionData;
    this.recurringIssueTemplateId = data.recurringIssueTemplateId ?? undefined;
    this.slaBreachesAt = data.slaBreachesAt ?? undefined;
    this.slaHighRiskAt = data.slaHighRiskAt ?? undefined;
    this.slaMediumRiskAt = data.slaMediumRiskAt ?? undefined;
    this.slaStartedAt = data.slaStartedAt ?? undefined;
    this.slaType = data.slaType ?? undefined;
    this.snoozedUntilAt = data.snoozedUntilAt ?? undefined;
    this.sortOrder = data.sortOrder;
    this.sourceCommentId = data.sourceCommentId ?? undefined;
    this.startedAt = data.startedAt ?? undefined;
    this.startedTriageAt = data.startedTriageAt ?? undefined;
    this.stateId = data.stateId;
    this.subIssueSortOrder = data.subIssueSortOrder ?? undefined;
    this.subscriberIds = data.subscriberIds;
    this.syncedWith = data.syncedWith ?? undefined;
    this.teamId = data.teamId;
    this.title = data.title;
    this.trashed = data.trashed ?? undefined;
    this.triagedAt = data.triagedAt ?? undefined;
    this.updatedAt = data.updatedAt;
    this.url = data.url;
    this.assignee = data.assignee ? new UserChildWebhookPayload(data.assignee) : undefined;
    this.creator = data.creator ? new UserChildWebhookPayload(data.creator) : undefined;
    this.cycle = data.cycle ? new CycleChildWebhookPayload(data.cycle) : undefined;
    this.externalUserCreator = data.externalUserCreator
      ? new ExternalUserChildWebhookPayload(data.externalUserCreator)
      : undefined;
    this.project = data.project ? new ProjectChildWebhookPayload(data.project) : undefined;
    this.projectMilestone = data.projectMilestone
      ? new ProjectMilestoneChildWebhookPayload(data.projectMilestone)
      : undefined;
    this.state = new WorkflowStateChildWebhookPayload(data.state);
    this.team = data.team ? new TeamChildWebhookPayload(data.team) : undefined;
    this.labels = data.labels.map(node => new IssueLabelChildWebhookPayload(node));
  }

  /** The time at which the issue was added to a cycle. */
  public addedToCycleAt?: string;
  /** The time at which the issue was added to a project. */
  public addedToProjectAt?: string;
  /** The time at which the issue was added to a team. */
  public addedToTeamAt?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the user that is assigned to the issue. */
  public assigneeId?: string;
  /** The time at which the issue was auto-archived. */
  public autoArchivedAt?: string;
  /** The time at which the issue was auto-closed. */
  public autoClosedAt?: string;
  /** The bot actor data for this issue. */
  public botActor?: string;
  /** The time at which the issue was canceled. */
  public canceledAt?: string;
  /** The time at which the issue was completed. */
  public completedAt?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the user that created the issue. */
  public creatorId?: string;
  /** The ID of the cycle that the issue belongs to. */
  public cycleId?: string;
  /** The description of the issue. */
  public description?: string;
  /** The description data of the issue. */
  public descriptionData?: string;
  /** The due date of the issue. */
  public dueDate?: string;
  /** The estimate of the complexity of the issue.. */
  public estimate?: number;
  /** The ID of the external user that created the issue. */
  public externalUserCreatorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The identifier of the issue. */
  public identifier: string;
  /** Integration type that created this issue, if applicable. */
  public integrationSourceType?: string;
  /** Id of the labels associated with this issue. */
  public labelIds: string[];
  /** The ID of the last template that was applied to the issue. */
  public lastAppliedTemplateId?: string;
  /** The issue's unique number. */
  public number: number;
  /** The ID of the parent issue. */
  public parentId?: string;
  /** Previous identifiers of the issue if it has been moved between teams. */
  public previousIdentifiers: string[];
  /** The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
  public priority: number;
  /** The label of the issue's priority. */
  public priorityLabel: string;
  /** The order of the item in relation to other items in the organization, when ordered by priority. */
  public prioritySortOrder: number;
  /** The ID of the project that the issue belongs to. */
  public projectId?: string;
  /** The ID of the project milestone that the issue belongs to. */
  public projectMilestoneId?: string;
  /** The reaction data for this issue. */
  public reactionData: L.Scalars["JSONObject"];
  /** The ID of the recurring issue template that created the issue. */
  public recurringIssueTemplateId?: string;
  /** The time at which the issue would breach its SLA. */
  public slaBreachesAt?: string;
  /** The time at which the issue would enter SLA high risk. */
  public slaHighRiskAt?: string;
  /** The time at which the issue would enter SLA medium risk. */
  public slaMediumRiskAt?: string;
  /** The time at which the issue's SLA started. */
  public slaStartedAt?: string;
  /** The type of SLA the issue is under. */
  public slaType?: string;
  /** The time until an issue will be snoozed in Triage view. */
  public snoozedUntilAt?: string;
  /** The order of the item in relation to other items in the organization. */
  public sortOrder: number;
  /** The ID of the source comment that the issue was created from. */
  public sourceCommentId?: string;
  /** The time at which the issue was moved into started state. */
  public startedAt?: string;
  /** The time at which the issue entered triage. */
  public startedTriageAt?: string;
  /** The ID of the issue's current workflow state. */
  public stateId: string;
  /** The order of the item in the sub-issue list. Only set if the issue has a parent. */
  public subIssueSortOrder?: number;
  /** The IDs of the users that are subscribed to the issue. */
  public subscriberIds: string[];
  /** The entity this issue is synced with. */
  public syncedWith?: L.Scalars["JSONObject"];
  /** The ID of the team that the issue belongs to. */
  public teamId: string;
  /** The issue's title. */
  public title: string;
  /** A flag that indicates whether the issue is in the trash bin. */
  public trashed?: boolean;
  /** The time at which the issue was triaged. */
  public triagedAt?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the issue. */
  public url: string;
  /** The labels associated with this issue. */
  public labels: IssueLabelChildWebhookPayload[];
  /** The user that is assigned to the issue. */
  public assignee?: UserChildWebhookPayload;
  /** The user that created the issue. */
  public creator?: UserChildWebhookPayload;
  /** The cycle that the issue belongs to. */
  public cycle?: CycleChildWebhookPayload;
  /** The external user that created the issue. */
  public externalUserCreator?: ExternalUserChildWebhookPayload;
  /** The project that the issue belongs to. */
  public project?: ProjectChildWebhookPayload;
  /** The project milestone that the issue belongs to. */
  public projectMilestone?: ProjectMilestoneChildWebhookPayload;
  /** The issue's current workflow state. */
  public state: WorkflowStateChildWebhookPayload;
  /** The team that the issue belongs to. */
  public team?: TeamChildWebhookPayload;
}
/**
 * Certain properties of an issue, including its description.
 *
 * @param data - L.IssueWithDescriptionChildWebhookPayloadFragment response data
 */
export class IssueWithDescriptionChildWebhookPayload {
  public constructor(data: L.IssueWithDescriptionChildWebhookPayloadFragment) {
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.identifier = data.identifier;
    this.teamId = data.teamId;
    this.title = data.title;
    this.url = data.url;
    this.team = new TeamChildWebhookPayload(data.team);
  }

  /** The description of the issue. */
  public description?: string;
  /** The ID of the issue. */
  public id: string;
  /** The identifier of the issue. */
  public identifier: string;
  /** The ID of the team that the issue belongs to. */
  public teamId: string;
  /** The title of the issue. */
  public title: string;
  /** The URL of the issue. */
  public url: string;
  /** The ID of the team that the issue belongs to. */
  public team: TeamChildWebhookPayload;
}
/**
 * A label notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.LabelNotificationSubscriptionFragment response data
 */
export class LabelNotificationSubscription extends Request {
  private _customView?: L.LabelNotificationSubscriptionFragment["customView"];
  private _customer?: L.LabelNotificationSubscriptionFragment["customer"];
  private _cycle?: L.LabelNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.LabelNotificationSubscriptionFragment["initiative"];
  private _label: L.LabelNotificationSubscriptionFragment["label"];
  private _project?: L.LabelNotificationSubscriptionFragment["project"];
  private _subscriber: L.LabelNotificationSubscriptionFragment["subscriber"];
  private _team?: L.LabelNotificationSubscriptionFragment["team"];
  private _user?: L.LabelNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.LabelNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The label subscribed to. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return new IssueLabelQuery(this._request).fetch(this._label.id);
  }
  /** The ID of label subscribed to. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * LogoutResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.LogoutResponseFragment response data
 */
export class LogoutResponse extends Request {
  public constructor(request: LinearRequest, data: L.LogoutResponseFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Node model
 *
 * @param request - function to call the graphql client
 * @param data - L.NodeFragment response data
 */
export class Node extends Request {
  public constructor(request: LinearRequest, data: L.NodeFragment) {
    super(request);
    this.id = data.id;
  }

  /** The unique identifier of the entity. */
  public id: string;
}
/**
 * A notification sent to a user.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationFragment response data
 */
export class Notification extends Request {
  private _actor?: L.NotificationFragment["actor"];
  private _externalUserActor?: L.NotificationFragment["externalUserActor"];
  private _user: L.NotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.NotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Archives a notification. */
  public archive() {
    return new ArchiveNotificationMutation(this._request).fetch(this.id);
  }
  /** Unarchives a notification. */
  public unarchive() {
    return new UnarchiveNotificationMutation(this._request).fetch(this.id);
  }
  /** Updates a notification. */
  public update(input: L.NotificationUpdateInput) {
    return new UpdateNotificationMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationArchivePayloadFragment response data
 */
export class NotificationArchivePayload extends Request {
  public constructor(request: LinearRequest, data: L.NotificationArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * NotificationBatchActionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationBatchActionPayloadFragment response data
 */
export class NotificationBatchActionPayload extends Request {
  public constructor(request: LinearRequest, data: L.NotificationBatchActionPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.notifications = data.notifications.map(node => new Notification(request, node));
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The notifications that were updated. */
  public notifications: Notification[];
}
/**
 * A user's notification category preferences.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationCategoryPreferencesFragment response data
 */
export class NotificationCategoryPreferences extends Request {
  public constructor(request: LinearRequest, data: L.NotificationCategoryPreferencesFragment) {
    super(request);
    this.appsAndIntegrations = new NotificationChannelPreferences(request, data.appsAndIntegrations);
    this.assignments = new NotificationChannelPreferences(request, data.assignments);
    this.commentsAndReplies = new NotificationChannelPreferences(request, data.commentsAndReplies);
    this.customers = new NotificationChannelPreferences(request, data.customers);
    this.documentChanges = new NotificationChannelPreferences(request, data.documentChanges);
    this.feed = new NotificationChannelPreferences(request, data.feed);
    this.mentions = new NotificationChannelPreferences(request, data.mentions);
    this.postsAndUpdates = new NotificationChannelPreferences(request, data.postsAndUpdates);
    this.reactions = new NotificationChannelPreferences(request, data.reactions);
    this.reminders = new NotificationChannelPreferences(request, data.reminders);
    this.reviews = new NotificationChannelPreferences(request, data.reviews);
    this.statusChanges = new NotificationChannelPreferences(request, data.statusChanges);
    this.subscriptions = new NotificationChannelPreferences(request, data.subscriptions);
    this.system = new NotificationChannelPreferences(request, data.system);
    this.triage = new NotificationChannelPreferences(request, data.triage);
  }

  /** The preferences for notifications about apps and integrations. */
  public appsAndIntegrations: NotificationChannelPreferences;
  /** The preferences for notifications about assignments. */
  public assignments: NotificationChannelPreferences;
  /** The preferences for notifications about comments and replies. */
  public commentsAndReplies: NotificationChannelPreferences;
  /** The preferences for customer notifications. */
  public customers: NotificationChannelPreferences;
  /** The preferences for notifications about document changes. */
  public documentChanges: NotificationChannelPreferences;
  /** The preferences for feed summary notifications. */
  public feed: NotificationChannelPreferences;
  /** The preferences for notifications about mentions. */
  public mentions: NotificationChannelPreferences;
  /** The preferences for notifications about posts and updates. */
  public postsAndUpdates: NotificationChannelPreferences;
  /** The preferences for notifications about reactions. */
  public reactions: NotificationChannelPreferences;
  /** The preferences for notifications about reminders. */
  public reminders: NotificationChannelPreferences;
  /** The preferences for notifications about reviews. */
  public reviews: NotificationChannelPreferences;
  /** The preferences for notifications about status changes. */
  public statusChanges: NotificationChannelPreferences;
  /** The preferences for notifications about subscriptions. */
  public subscriptions: NotificationChannelPreferences;
  /** The preferences for system notifications. */
  public system: NotificationChannelPreferences;
  /** The preferences for triage notifications. */
  public triage: NotificationChannelPreferences;
}
/**
 * A user's notification channel preferences, indicating if a channel is enabled or not
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationChannelPreferencesFragment response data
 */
export class NotificationChannelPreferences extends Request {
  public constructor(request: LinearRequest, data: L.NotificationChannelPreferencesFragment) {
    super(request);
    this.desktop = data.desktop;
    this.email = data.email;
    this.mobile = data.mobile;
    this.slack = data.slack;
  }

  /** Whether notifications are currently enabled for desktop. */
  public desktop: boolean;
  /** Whether notifications are currently enabled for email. */
  public email: boolean;
  /** Whether notifications are currently enabled for mobile. */
  public mobile: boolean;
  /** Whether notifications are currently enabled for Slack. */
  public slack: boolean;
}
/**
 * NotificationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this NotificationConnection model
 * @param data - NotificationConnection response data
 */
export class NotificationConnection extends Connection<
  | CustomerNeedNotification
  | CustomerNotification
  | DocumentNotification
  | InitiativeNotification
  | IssueNotification
  | OauthClientApprovalNotification
  | PostNotification
  | ProjectNotification
  | PullRequestNotification
  | Notification
> {
  public constructor(
    request: LinearRequest,
    fetch: (
      connection?: LinearConnectionVariables
    ) => LinearFetch<
      | LinearConnection<
          | CustomerNeedNotification
          | CustomerNotification
          | DocumentNotification
          | InitiativeNotification
          | IssueNotification
          | OauthClientApprovalNotification
          | PostNotification
          | ProjectNotification
          | PullRequestNotification
          | Notification
        >
      | undefined
    >,
    data: L.NotificationConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => {
        switch (node.__typename) {
          case "CustomerNeedNotification":
            return new CustomerNeedNotification(request, node as L.CustomerNeedNotificationFragment);
          case "CustomerNotification":
            return new CustomerNotification(request, node as L.CustomerNotificationFragment);
          case "DocumentNotification":
            return new DocumentNotification(request, node as L.DocumentNotificationFragment);
          case "InitiativeNotification":
            return new InitiativeNotification(request, node as L.InitiativeNotificationFragment);
          case "IssueNotification":
            return new IssueNotification(request, node as L.IssueNotificationFragment);
          case "OauthClientApprovalNotification":
            return new OauthClientApprovalNotification(request, node as L.OauthClientApprovalNotificationFragment);
          case "PostNotification":
            return new PostNotification(request, node as L.PostNotificationFragment);
          case "ProjectNotification":
            return new ProjectNotification(request, node as L.ProjectNotificationFragment);
          case "PullRequestNotification":
            return new PullRequestNotification(request, node as L.PullRequestNotificationFragment);

          default:
            return new Notification(request, node);
        }
      }),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A user's notification delivery preferences.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationDeliveryPreferencesFragment response data
 */
export class NotificationDeliveryPreferences extends Request {
  public constructor(request: LinearRequest, data: L.NotificationDeliveryPreferencesFragment) {
    super(request);
    this.mobile = data.mobile ? new NotificationDeliveryPreferencesChannel(request, data.mobile) : undefined;
  }

  /** The delivery preferences for the mobile channel. */
  public mobile?: NotificationDeliveryPreferencesChannel;
}
/**
 * A user's notification delivery preferences.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationDeliveryPreferencesChannelFragment response data
 */
export class NotificationDeliveryPreferencesChannel extends Request {
  public constructor(request: LinearRequest, data: L.NotificationDeliveryPreferencesChannelFragment) {
    super(request);
    this.notificationsDisabled = data.notificationsDisabled ?? undefined;
    this.schedule = data.schedule ? new NotificationDeliveryPreferencesSchedule(request, data.schedule) : undefined;
  }

  /** [DEPRECATED] Whether notifications are enabled for this channel. Use notificationChannelPreferences instead. */
  public notificationsDisabled?: boolean;
  /** The schedule for notifications on this channel. */
  public schedule?: NotificationDeliveryPreferencesSchedule;
}
/**
 * A user's notification delivery schedule for a particular day.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationDeliveryPreferencesDayFragment response data
 */
export class NotificationDeliveryPreferencesDay extends Request {
  public constructor(request: LinearRequest, data: L.NotificationDeliveryPreferencesDayFragment) {
    super(request);
    this.end = data.end ?? undefined;
    this.start = data.start ?? undefined;
  }

  /** The time notifications end. */
  public end?: string;
  /** The time notifications start. */
  public start?: string;
}
/**
 * A user's notification delivery schedule for a particular day.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationDeliveryPreferencesScheduleFragment response data
 */
export class NotificationDeliveryPreferencesSchedule extends Request {
  public constructor(request: LinearRequest, data: L.NotificationDeliveryPreferencesScheduleFragment) {
    super(request);
    this.disabled = data.disabled ?? undefined;
    this.friday = new NotificationDeliveryPreferencesDay(request, data.friday);
    this.monday = new NotificationDeliveryPreferencesDay(request, data.monday);
    this.saturday = new NotificationDeliveryPreferencesDay(request, data.saturday);
    this.sunday = new NotificationDeliveryPreferencesDay(request, data.sunday);
    this.thursday = new NotificationDeliveryPreferencesDay(request, data.thursday);
    this.tuesday = new NotificationDeliveryPreferencesDay(request, data.tuesday);
    this.wednesday = new NotificationDeliveryPreferencesDay(request, data.wednesday);
  }

  /** Whether the schedule is disabled. */
  public disabled?: boolean;
  /** Delivery preferences for Friday. */
  public friday: NotificationDeliveryPreferencesDay;
  /** Delivery preferences for Monday. */
  public monday: NotificationDeliveryPreferencesDay;
  /** Delivery preferences for Saturday. */
  public saturday: NotificationDeliveryPreferencesDay;
  /** Delivery preferences for Sunday. */
  public sunday: NotificationDeliveryPreferencesDay;
  /** Delivery preferences for Thursday. */
  public thursday: NotificationDeliveryPreferencesDay;
  /** Delivery preferences for Tuesday. */
  public tuesday: NotificationDeliveryPreferencesDay;
  /** Delivery preferences for Wednesday. */
  public wednesday: NotificationDeliveryPreferencesDay;
}
/**
 * NotificationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationPayloadFragment response data
 */
export class NotificationPayload extends Request {
  public constructor(request: LinearRequest, data: L.NotificationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Notification subscriptions for models.
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationSubscriptionFragment response data
 */
export class NotificationSubscription extends Request {
  private _customView?: L.NotificationSubscriptionFragment["customView"];
  private _customer?: L.NotificationSubscriptionFragment["customer"];
  private _cycle?: L.NotificationSubscriptionFragment["cycle"];
  private _initiative?: L.NotificationSubscriptionFragment["initiative"];
  private _label?: L.NotificationSubscriptionFragment["label"];
  private _project?: L.NotificationSubscriptionFragment["project"];
  private _subscriber: L.NotificationSubscriptionFragment["subscriber"];
  private _team?: L.NotificationSubscriptionFragment["team"];
  private _user?: L.NotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.NotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Creates a new notification subscription for a cycle, custom view, label, project or team. */
  public create(input: L.NotificationSubscriptionCreateInput) {
    return new CreateNotificationSubscriptionMutation(this._request).fetch(input);
  }
  /** Deletes a notification subscription reference. */
  public delete() {
    return new DeleteNotificationSubscriptionMutation(this._request).fetch(this.id);
  }
  /** Updates a notification subscription. */
  public update(input: L.NotificationSubscriptionUpdateInput) {
    return new UpdateNotificationSubscriptionMutation(this._request).fetch(this.id, input);
  }
}
/**
 * NotificationSubscriptionConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this NotificationSubscriptionConnection model
 * @param data - NotificationSubscriptionConnection response data
 */
export class NotificationSubscriptionConnection extends Connection<
  | CustomViewNotificationSubscription
  | CustomerNotificationSubscription
  | CycleNotificationSubscription
  | InitiativeNotificationSubscription
  | LabelNotificationSubscription
  | ProjectNotificationSubscription
  | TeamNotificationSubscription
  | UserNotificationSubscription
  | NotificationSubscription
> {
  public constructor(
    request: LinearRequest,
    fetch: (
      connection?: LinearConnectionVariables
    ) => LinearFetch<
      | LinearConnection<
          | CustomViewNotificationSubscription
          | CustomerNotificationSubscription
          | CycleNotificationSubscription
          | InitiativeNotificationSubscription
          | LabelNotificationSubscription
          | ProjectNotificationSubscription
          | TeamNotificationSubscription
          | UserNotificationSubscription
          | NotificationSubscription
        >
      | undefined
    >,
    data: L.NotificationSubscriptionConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => {
        switch (node.__typename) {
          case "CustomViewNotificationSubscription":
            return new CustomViewNotificationSubscription(
              request,
              node as L.CustomViewNotificationSubscriptionFragment
            );
          case "CustomerNotificationSubscription":
            return new CustomerNotificationSubscription(request, node as L.CustomerNotificationSubscriptionFragment);
          case "CycleNotificationSubscription":
            return new CycleNotificationSubscription(request, node as L.CycleNotificationSubscriptionFragment);
          case "InitiativeNotificationSubscription":
            return new InitiativeNotificationSubscription(
              request,
              node as L.InitiativeNotificationSubscriptionFragment
            );
          case "LabelNotificationSubscription":
            return new LabelNotificationSubscription(request, node as L.LabelNotificationSubscriptionFragment);
          case "ProjectNotificationSubscription":
            return new ProjectNotificationSubscription(request, node as L.ProjectNotificationSubscriptionFragment);
          case "TeamNotificationSubscription":
            return new TeamNotificationSubscription(request, node as L.TeamNotificationSubscriptionFragment);
          case "UserNotificationSubscription":
            return new UserNotificationSubscription(request, node as L.UserNotificationSubscriptionFragment);

          default:
            return new NotificationSubscription(request, node);
        }
      }),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * NotificationSubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.NotificationSubscriptionPayloadFragment response data
 */
export class NotificationSubscriptionPayload extends Request {
  public constructor(request: LinearRequest, data: L.NotificationSubscriptionPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Payload for OAuth app webhook events.
 *
 * @param data - L.OAuthAppWebhookPayloadFragment response data
 */
export class OAuthAppWebhookPayload {
  public constructor(data: L.OAuthAppWebhookPayloadFragment) {
    this.action = data.action;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.oauthClientId = data.oauthClientId;
    this.organizationId = data.organizationId;
    this.type = data.type;
  }

  /** The type of action that triggered the webhook. */
  public action: string;
  /** The time the payload was created. */
  public createdAt: Date;
  /** Id of the OAuth client that was revoked. */
  public oauthClientId: string;
  /** ID of the organization for which the webhook belongs to. */
  public organizationId: string;
  /** The type of resource. */
  public type: string;
}
/**
 * Request to install OAuth clients on organizations and the response to the request.
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientApprovalFragment response data
 */
export class OauthClientApproval extends Request {
  public constructor(request: LinearRequest, data: L.OauthClientApprovalFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.denyReason = data.denyReason ?? undefined;
    this.id = data.id;
    this.oauthClientId = data.oauthClientId;
    this.requestReason = data.requestReason ?? undefined;
    this.requesterId = data.requesterId;
    this.responderId = data.responderId ?? undefined;
    this.scopes = data.scopes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.status = data.status;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The reason the request for the OAuth client approval was denied. */
  public denyReason?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The uuid of the OAuth client being requested for installation. */
  public oauthClientId: string;
  /** The reason the person wants to install this OAuth client. */
  public requestReason?: string;
  /** The person who requested installing the OAuth client. */
  public requesterId: string;
  /** The person who responded to the request to install the OAuth client. */
  public responderId?: string;
  /** The scopes the app has requested. */
  public scopes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The status for the OAuth client approval request. */
  public status: L.OAuthClientApprovalStatus;
}
/**
 * An oauth client approval related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.OauthClientApprovalNotificationFragment response data
 */
export class OauthClientApprovalNotification extends Request {
  private _actor?: L.OauthClientApprovalNotificationFragment["actor"];
  private _externalUserActor?: L.OauthClientApprovalNotificationFragment["externalUserActor"];
  private _user: L.OauthClientApprovalNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.OauthClientApprovalNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.oauthClientApprovalId = data.oauthClientApprovalId;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this.oauthClientApproval = new OauthClientApproval(request, data.oauthClientApproval);
    this._actor = data.actor ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related OAuth client approval request ID. */
  public oauthClientApprovalId: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The OAuth client approval request related to the notification. */
  public oauthClientApproval: OauthClientApproval;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * Certain properties of an OAuth client.
 *
 * @param data - L.OauthClientChildWebhookPayloadFragment response data
 */
export class OauthClientChildWebhookPayload {
  public constructor(data: L.OauthClientChildWebhookPayloadFragment) {
    this.id = data.id;
    this.name = data.name;
  }

  /** The ID of the OAuth client. */
  public id: string;
  /** The name of the OAuth client. */
  public name: string;
}
/**
 * An organization. Organizations are root-level objects that contain user accounts and teams.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationFragment response data
 */
export class Organization extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationFragment) {
    super(request);
    this.allowMembersToInvite = data.allowMembersToInvite ?? undefined;
    this.allowedAuthServices = data.allowedAuthServices;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.createdIssueCount = data.createdIssueCount;
    this.customerCount = data.customerCount;
    this.customersConfiguration = data.customersConfiguration;
    this.customersEnabled = data.customersEnabled;
    this.deletionRequestedAt = parseDate(data.deletionRequestedAt) ?? undefined;
    this.feedEnabled = data.feedEnabled;
    this.fiscalYearStartMonth = data.fiscalYearStartMonth;
    this.gitBranchFormat = data.gitBranchFormat ?? undefined;
    this.gitLinkbackMessagesEnabled = data.gitLinkbackMessagesEnabled;
    this.gitPublicLinkbackMessagesEnabled = data.gitPublicLinkbackMessagesEnabled;
    this.id = data.id;
    this.initiativeUpdateReminderFrequencyInWeeks = data.initiativeUpdateReminderFrequencyInWeeks ?? undefined;
    this.initiativeUpdateRemindersHour = data.initiativeUpdateRemindersHour;
    this.logoUrl = data.logoUrl ?? undefined;
    this.name = data.name;
    this.periodUploadVolume = data.periodUploadVolume;
    this.previousUrlKeys = data.previousUrlKeys;
    this.projectUpdateReminderFrequencyInWeeks = data.projectUpdateReminderFrequencyInWeeks ?? undefined;
    this.projectUpdateRemindersHour = data.projectUpdateRemindersHour;
    this.restrictLabelManagementToAdmins = data.restrictLabelManagementToAdmins ?? undefined;
    this.restrictTeamCreationToAdmins = data.restrictTeamCreationToAdmins ?? undefined;
    this.roadmapEnabled = data.roadmapEnabled;
    this.samlEnabled = data.samlEnabled;
    this.scimEnabled = data.scimEnabled;
    this.trialEndsAt = parseDate(data.trialEndsAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.urlKey = data.urlKey;
    this.userCount = data.userCount;
    this.subscription = data.subscription ? new PaidSubscription(request, data.subscription) : undefined;
    this.ipRestrictions = data.ipRestrictions
      ? data.ipRestrictions.map(node => new OrganizationIpRestriction(request, node))
      : undefined;
    this.projectStatuses = data.projectStatuses.map(node => new ProjectStatus(request, node));
    this.defaultFeedSummarySchedule = data.defaultFeedSummarySchedule ?? undefined;
    this.initiativeUpdateRemindersDay = data.initiativeUpdateRemindersDay;
    this.projectUpdateRemindersDay = data.projectUpdateRemindersDay;
    this.projectUpdatesReminderFrequency = data.projectUpdatesReminderFrequency;
    this.releaseChannel = data.releaseChannel;
    this.slaDayCount = data.slaDayCount;
  }

  /** Whether member users are allowed to send invites. */
  public allowMembersToInvite?: boolean;
  /** Allowed authentication providers, empty array means all are allowed. */
  public allowedAuthServices: string[];
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Number of issues in the organization. */
  public createdIssueCount: number;
  /** Number of customers in the organization. */
  public customerCount: number;
  /** Configuration settings for the Customers feature. */
  public customersConfiguration: L.Scalars["JSONObject"];
  /** Whether the organization is using Customers. */
  public customersEnabled: boolean;
  /** The time at which deletion of the organization was requested. */
  public deletionRequestedAt?: Date;
  /** Whether the organization has enabled the feed feature. */
  public feedEnabled: boolean;
  /** The month at which the fiscal year starts. Defaults to January (0). */
  public fiscalYearStartMonth: number;
  /** How git branches are formatted. If null, default formatting will be used. */
  public gitBranchFormat?: string;
  /** Whether the Git integration linkback messages should be sent to private repositories. */
  public gitLinkbackMessagesEnabled: boolean;
  /** Whether the Git integration linkback messages should be sent to public repositories. */
  public gitPublicLinkbackMessagesEnabled: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** The n-weekly frequency at which to prompt for initiative updates. When not set, reminders are off. */
  public initiativeUpdateReminderFrequencyInWeeks?: number;
  /** The hour at which to prompt for initiative updates. */
  public initiativeUpdateRemindersHour: number;
  /** The organization's logo URL. */
  public logoUrl?: string;
  /** The organization's name. */
  public name: string;
  /** Rolling 30-day total upload volume for the organization, in megabytes. */
  public periodUploadVolume: number;
  /** Previously used URL keys for the organization (last 3 are kept and redirected). */
  public previousUrlKeys: string[];
  /** The n-weekly frequency at which to prompt for project updates. When not set, reminders are off. */
  public projectUpdateReminderFrequencyInWeeks?: number;
  /** The hour at which to prompt for project updates. */
  public projectUpdateRemindersHour: number;
  /** Whether workspace label creation, update, and deletion is restricted to admins. */
  public restrictLabelManagementToAdmins?: boolean;
  /** Whether team creation is restricted to admins. */
  public restrictTeamCreationToAdmins?: boolean;
  /** Whether the organization is using a roadmap. */
  public roadmapEnabled: boolean;
  /** Whether SAML authentication is enabled for organization. */
  public samlEnabled: boolean;
  /** Whether SCIM provisioning is enabled for organization. */
  public scimEnabled: boolean;
  /** The time at which the trial will end. */
  public trialEndsAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The organization's unique URL key. */
  public urlKey: string;
  /** Number of active users in the organization. */
  public userCount: number;
  /** IP restriction configurations. */
  public ipRestrictions?: OrganizationIpRestriction[];
  /** The organization's project statuses. */
  public projectStatuses: ProjectStatus[];
  /** The organization's subscription to a paid plan. */
  public subscription?: PaidSubscription;
  /** Default schedule for how often feed summaries are generated. */
  public defaultFeedSummarySchedule?: L.FeedSummarySchedule;
  /** The day at which to prompt for initiative updates. */
  public initiativeUpdateRemindersDay: L.Day;
  /** The day at which to prompt for project updates. */
  public projectUpdateRemindersDay: L.Day;
  /** [DEPRECATED] The frequency at which to prompt for project updates. */
  public projectUpdatesReminderFrequency: L.ProjectUpdateReminderFrequency;
  /** The feature release channel the organization belongs to. */
  public releaseChannel: L.ReleaseChannel;
  /** [DEPRECATED] Which day count to use for SLA calculations. */
  public slaDayCount: L.SLADayCountType;

  /** Integrations associated with the organization. */
  public integrations(variables?: L.Organization_IntegrationsQueryVariables) {
    return new Organization_IntegrationsQuery(this._request, variables).fetch(variables);
  }
  /** Labels associated with the organization. */
  public labels(variables?: L.Organization_LabelsQueryVariables) {
    return new Organization_LabelsQuery(this._request, variables).fetch(variables);
  }
  /** Project labels associated with the organization. */
  public projectLabels(variables?: L.Organization_ProjectLabelsQueryVariables) {
    return new Organization_ProjectLabelsQuery(this._request, variables).fetch(variables);
  }
  /** Teams associated with the organization. */
  public teams(variables?: L.Organization_TeamsQueryVariables) {
    return new Organization_TeamsQuery(this._request, variables).fetch(variables);
  }
  /** Templates associated with the organization. */
  public templates(variables?: L.Organization_TemplatesQueryVariables) {
    return new Organization_TemplatesQuery(this._request, variables).fetch(variables);
  }
  /** Users associated with the organization. */
  public users(variables?: L.Organization_UsersQueryVariables) {
    return new Organization_UsersQuery(this._request, variables).fetch(variables);
  }
  /** Delete's an organization. Administrator privileges required. */
  public delete(input: L.DeleteOrganizationInput) {
    return new DeleteOrganizationMutation(this._request).fetch(input);
  }
  /** Updates the user's organization. */
  public update(input: L.OrganizationUpdateInput) {
    return new UpdateOrganizationMutation(this._request).fetch(input);
  }
}
/**
 * OrganizationAcceptedOrExpiredInviteDetailsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationAcceptedOrExpiredInviteDetailsPayloadFragment response data
 */
export class OrganizationAcceptedOrExpiredInviteDetailsPayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationAcceptedOrExpiredInviteDetailsPayloadFragment) {
    super(request);
    this.status = data.status;
  }

  /** The status of the invite. */
  public status: L.OrganizationInviteStatus;
}
/**
 * OrganizationCancelDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationCancelDeletePayloadFragment response data
 */
export class OrganizationCancelDeletePayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationCancelDeletePayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * OrganizationDeletePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDeletePayloadFragment response data
 */
export class OrganizationDeletePayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationDeletePayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Defines the use of a domain by an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationDomainFragment response data
 */
export class OrganizationDomain extends Request {
  private _creator?: L.OrganizationDomainFragment["creator"];

  public constructor(request: LinearRequest, data: L.OrganizationDomainFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.claimed = data.claimed ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.disableOrganizationCreation = data.disableOrganizationCreation ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.verificationEmail = data.verificationEmail ?? undefined;
    this.verified = data.verified;
    this.authType = data.authType;
    this._creator = data.creator ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Whether the domains was claimed by the organization through DNS verification. */
  public claimed?: boolean;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Prevent users with this domain to create new workspaces. */
  public disableOrganizationCreation?: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** Domain name. */
  public name: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** E-mail used to verify this domain. */
  public verificationEmail?: string;
  /** Is this domain verified. */
  public verified: boolean;
  /** What type of auth is the domain used for. */
  public authType: L.OrganizationDomainAuthType;
  /** The user who added the domain. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who added the domain. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }

  /** Deletes a domain. */
  public delete() {
    return new DeleteOrganizationDomainMutation(this._request).fetch(this.id);
  }
}
/**
 * OrganizationExistsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationExistsPayloadFragment response data
 */
export class OrganizationExistsPayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationExistsPayloadFragment) {
    super(request);
    this.exists = data.exists;
    this.success = data.success;
  }

  /** Whether the organization exists. */
  public exists: boolean;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * An invitation to the organization that has been sent via email.
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInviteFragment response data
 */
export class OrganizationInvite extends Request {
  private _invitee?: L.OrganizationInviteFragment["invitee"];
  private _inviter: L.OrganizationInviteFragment["inviter"];

  public constructor(request: LinearRequest, data: L.OrganizationInviteFragment) {
    super(request);
    this.acceptedAt = parseDate(data.acceptedAt) ?? undefined;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.email = data.email;
    this.expiresAt = parseDate(data.expiresAt) ?? undefined;
    this.external = data.external;
    this.id = data.id;
    this.metadata = data.metadata ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.role = data.role;
    this._invitee = data.invitee ?? undefined;
    this._inviter = data.inviter;
  }

  /** The time at which the invite was accepted. Null, if the invite hasn't been accepted. */
  public acceptedAt?: Date;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The invitees email address. */
  public email: string;
  /** The time at which the invite will be expiring. Null, if the invite shouldn't expire. */
  public expiresAt?: Date;
  /** The invite was sent to external address. */
  public external: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** Extra metadata associated with the organization invite. */
  public metadata?: L.Scalars["JSONObject"];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user role that the invitee will receive upon accepting the invite. */
  public role: L.UserRoleType;
  /** The user who has accepted the invite. Null, if the invite hasn't been accepted. */
  public get invitee(): LinearFetch<User> | undefined {
    return this._invitee?.id ? new UserQuery(this._request).fetch(this._invitee?.id) : undefined;
  }
  /** The ID of user who has accepted the invite. null, if the invite hasn't been accepted. */
  public get inviteeId(): string | undefined {
    return this._invitee?.id;
  }
  /** The user who created the invitation. */
  public get inviter(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._inviter.id);
  }
  /** The ID of user who created the invitation. */
  public get inviterId(): string | undefined {
    return this._inviter?.id;
  }
  /** The organization that the invite is associated with. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }

  /** Creates a new organization invite. */
  public create(input: L.OrganizationInviteCreateInput) {
    return new CreateOrganizationInviteMutation(this._request).fetch(input);
  }
  /** Deletes an organization invite. */
  public delete() {
    return new DeleteOrganizationInviteMutation(this._request).fetch(this.id);
  }
  /** Updates an organization invite. */
  public update(input: L.OrganizationInviteUpdateInput) {
    return new UpdateOrganizationInviteMutation(this._request).fetch(this.id, input);
  }
}
/**
 * OrganizationInviteConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this OrganizationInviteConnection model
 * @param data - OrganizationInviteConnection response data
 */
export class OrganizationInviteConnection extends Connection<OrganizationInvite> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<OrganizationInvite> | undefined>,
    data: L.OrganizationInviteConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new OrganizationInvite(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * OrganizationInviteFullDetailsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInviteFullDetailsPayloadFragment response data
 */
export class OrganizationInviteFullDetailsPayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationInviteFullDetailsPayloadFragment) {
    super(request);
    this.accepted = data.accepted;
    this.allowedAuthServices = data.allowedAuthServices;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.email = data.email;
    this.expired = data.expired;
    this.inviter = data.inviter;
    this.organizationId = data.organizationId;
    this.organizationLogoUrl = data.organizationLogoUrl ?? undefined;
    this.organizationName = data.organizationName;
    this.role = data.role;
    this.status = data.status;
  }

  /** Whether the invite has already been accepted. */
  public accepted: boolean;
  /** Allowed authentication providers, empty array means all are allowed. */
  public allowedAuthServices: string[];
  /** When the invite was created. */
  public createdAt: Date;
  /** The email of the invitee. */
  public email: string;
  /** Whether the invite has expired. */
  public expired: boolean;
  /** The name of the inviter. */
  public inviter: string;
  /** ID of the workspace the invite is for. */
  public organizationId: string;
  /** URL of the workspace logo the invite is for. */
  public organizationLogoUrl?: string;
  /** Name of the workspace the invite is for. */
  public organizationName: string;
  /** What user role the invite should grant. */
  public role: L.UserRoleType;
  /** The status of the invite. */
  public status: L.OrganizationInviteStatus;
}
/**
 * OrganizationInvitePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationInvitePayloadFragment response data
 */
export class OrganizationInvitePayload extends Request {
  private _organizationInvite: L.OrganizationInvitePayloadFragment["organizationInvite"];

  public constructor(request: LinearRequest, data: L.OrganizationInvitePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._organizationInvite = data.organizationInvite;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The organization invite that was created or updated. */
  public get organizationInvite(): LinearFetch<OrganizationInvite> | undefined {
    return new OrganizationInviteQuery(this._request).fetch(this._organizationInvite.id);
  }
  /** The ID of organization invite that was created or updated. */
  public get organizationInviteId(): string | undefined {
    return this._organizationInvite?.id;
  }
}
/**
 * OrganizationIpRestriction model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationIpRestrictionFragment response data
 */
export class OrganizationIpRestriction extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationIpRestrictionFragment) {
    super(request);
    this.description = data.description ?? undefined;
    this.enabled = data.enabled;
    this.range = data.range;
    this.type = data.type;
  }

  /** Optional restriction description. */
  public description?: string;
  /** Whether the restriction is enabled. */
  public enabled: boolean;
  /** IP range in CIDR format. */
  public range: string;
  /** Restriction type. */
  public type: string;
}
/**
 * OrganizationMeta model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationMetaFragment response data
 */
export class OrganizationMeta extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationMetaFragment) {
    super(request);
    this.allowedAuthServices = data.allowedAuthServices;
    this.region = data.region;
  }

  /** Allowed authentication providers, empty array means all are allowed. */
  public allowedAuthServices: string[];
  /** The region the organization is hosted in. */
  public region: string;
}
/**
 * OrganizationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationPayloadFragment response data
 */
export class OrganizationPayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The organization that was created or updated. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
}
/**
 * OrganizationStartTrialPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.OrganizationStartTrialPayloadFragment response data
 */
export class OrganizationStartTrialPayload extends Request {
  public constructor(request: LinearRequest, data: L.OrganizationStartTrialPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Generic notification payload.
 *
 * @param data - L.OtherNotificationWebhookPayloadFragment response data
 */
export class OtherNotificationWebhookPayload {
  public constructor(data: L.OtherNotificationWebhookPayloadFragment) {
    this.actorId = data.actorId ?? undefined;
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = data.createdAt;
    this.documentId = data.documentId ?? undefined;
    this.externalUserActorId = data.externalUserActorId ?? undefined;
    this.id = data.id;
    this.issueId = data.issueId ?? undefined;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.projectId = data.projectId ?? undefined;
    this.projectUpdateId = data.projectUpdateId ?? undefined;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId;
    this.actor = data.actor ? new UserChildWebhookPayload(data.actor) : undefined;
    this.comment = data.comment ? new CommentChildWebhookPayload(data.comment) : undefined;
    this.document = data.document ? new DocumentChildWebhookPayload(data.document) : undefined;
    this.issue = data.issue ? new IssueWithDescriptionChildWebhookPayload(data.issue) : undefined;
    this.parentComment = data.parentComment ? new CommentChildWebhookPayload(data.parentComment) : undefined;
    this.project = data.project ? new ProjectChildWebhookPayload(data.project) : undefined;
    this.projectUpdate = data.projectUpdate ? new ProjectUpdateChildWebhookPayload(data.projectUpdate) : undefined;
    this.type = data.type;
  }

  /** The ID of the actor who caused the notification. */
  public actorId?: string;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment this notification belongs to. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the document this notification belongs to. */
  public documentId?: string;
  /** The ID of the external user who caused the notification. */
  public externalUserActorId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the issue this notification belongs to. */
  public issueId?: string;
  /** The ID of the parent comment this notification belongs to. */
  public parentCommentId?: string;
  /** The ID of the project this notification belongs to. */
  public projectId?: string;
  /** The ID of the project update this notification belongs to. */
  public projectUpdateId?: string;
  /** The emoji of the reaction this notification is for. */
  public reactionEmoji?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user who received the notification. */
  public userId: string;
  /** The actor who caused the notification. */
  public actor?: UserChildWebhookPayload;
  /** The comment this notification belongs to. */
  public comment?: CommentChildWebhookPayload;
  /** The document this notification belongs to. */
  public document?: DocumentChildWebhookPayload;
  /** The issue this notification belongs to. */
  public issue?: IssueWithDescriptionChildWebhookPayload;
  /** The parent comment this notification belongs to. */
  public parentComment?: CommentChildWebhookPayload;
  /** The project this notification belongs to. */
  public project?: ProjectChildWebhookPayload;
  /** The project update this notification belongs to. */
  public projectUpdate?: ProjectUpdateChildWebhookPayload;
  /** The type of the notification. */
  public type: L.OtherNotificationType;
}
/**
 * PageInfo model
 *
 * @param request - function to call the graphql client
 * @param data - L.PageInfoFragment response data
 */
export class PageInfo extends Request {
  public constructor(request: LinearRequest, data: L.PageInfoFragment) {
    super(request);
    this.endCursor = data.endCursor ?? undefined;
    this.hasNextPage = data.hasNextPage;
    this.hasPreviousPage = data.hasPreviousPage;
    this.startCursor = data.startCursor ?? undefined;
  }

  /** Cursor representing the last result in the paginated results. */
  public endCursor?: string;
  /** Indicates if there are more results when paginating forward. */
  public hasNextPage: boolean;
  /** Indicates if there are more results when paginating backward. */
  public hasPreviousPage: boolean;
  /** Cursor representing the first result in the paginated results. */
  public startCursor?: string;
}
/**
 * The paid subscription of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.PaidSubscriptionFragment response data
 */
export class PaidSubscription extends Request {
  private _creator?: L.PaidSubscriptionFragment["creator"];

  public constructor(request: LinearRequest, data: L.PaidSubscriptionFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.cancelAt = parseDate(data.cancelAt) ?? undefined;
    this.canceledAt = parseDate(data.canceledAt) ?? undefined;
    this.collectionMethod = data.collectionMethod;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.nextBillingAt = parseDate(data.nextBillingAt) ?? undefined;
    this.pendingChangeType = data.pendingChangeType ?? undefined;
    this.seats = data.seats;
    this.seatsMaximum = data.seatsMaximum ?? undefined;
    this.seatsMinimum = data.seatsMinimum ?? undefined;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._creator = data.creator ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The date the subscription is scheduled to be canceled, if any. */
  public cancelAt?: Date;
  /** The date the subscription was canceled, if any. */
  public canceledAt?: Date;
  /** The collection method for this subscription, either automatically charged or invoiced. */
  public collectionMethod: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The date the subscription will be billed next. */
  public nextBillingAt?: Date;
  /** The subscription type of a pending change. Null if no change pending. */
  public pendingChangeType?: string;
  /** The number of seats in the subscription. */
  public seats: number;
  /** The maximum number of seats that will be billed in the subscription. */
  public seatsMaximum?: number;
  /** The minimum number of seats that will be billed in the subscription. */
  public seatsMinimum?: number;
  /** The subscription type. */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The creator of the subscription. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of creator of the subscription. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization that the subscription is associated with. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
}
/**
 * PasskeyLoginStartResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.PasskeyLoginStartResponseFragment response data
 */
export class PasskeyLoginStartResponse extends Request {
  public constructor(request: LinearRequest, data: L.PasskeyLoginStartResponseFragment) {
    super(request);
    this.options = data.options;
    this.success = data.success;
  }

  public options: L.Scalars["JSONObject"];
  public success: boolean;
}
/**
 * A post related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.PostNotificationFragment response data
 */
export class PostNotification extends Request {
  private _actor?: L.PostNotificationFragment["actor"];
  private _externalUserActor?: L.PostNotificationFragment["externalUserActor"];
  private _user: L.PostNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.PostNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.postId = data.postId;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Related comment ID. Null if the notification is not related to a comment. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related parent comment ID. Null if the notification is not related to a comment. */
  public parentCommentId?: string;
  /** Related post ID. */
  public postId: string;
  /** Name of the reaction emoji related to the notification. */
  public reactionEmoji?: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * A project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectFragment response data
 */
export class Project extends Request {
  private _convertedFromIssue?: L.ProjectFragment["convertedFromIssue"];
  private _creator?: L.ProjectFragment["creator"];
  private _favorite?: L.ProjectFragment["favorite"];
  private _integrationsSettings?: L.ProjectFragment["integrationsSettings"];
  private _lastAppliedTemplate?: L.ProjectFragment["lastAppliedTemplate"];
  private _lastUpdate?: L.ProjectFragment["lastUpdate"];
  private _lead?: L.ProjectFragment["lead"];
  private _status: L.ProjectFragment["status"];

  public constructor(request: LinearRequest, data: L.ProjectFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoArchivedAt = parseDate(data.autoArchivedAt) ?? undefined;
    this.canceledAt = parseDate(data.canceledAt) ?? undefined;
    this.color = data.color;
    this.completedAt = parseDate(data.completedAt) ?? undefined;
    this.completedIssueCountHistory = data.completedIssueCountHistory;
    this.completedScopeHistory = data.completedScopeHistory;
    this.content = data.content ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description;
    this.healthUpdatedAt = parseDate(data.healthUpdatedAt) ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.inProgressScopeHistory = data.inProgressScopeHistory;
    this.issueCountHistory = data.issueCountHistory;
    this.labelIds = data.labelIds;
    this.name = data.name;
    this.priority = data.priority;
    this.priorityLabel = data.priorityLabel;
    this.prioritySortOrder = data.prioritySortOrder;
    this.progress = data.progress;
    this.projectUpdateRemindersPausedUntilAt = parseDate(data.projectUpdateRemindersPausedUntilAt) ?? undefined;
    this.scope = data.scope;
    this.scopeHistory = data.scopeHistory;
    this.slackIssueComments = data.slackIssueComments;
    this.slackIssueStatuses = data.slackIssueStatuses;
    this.slackNewIssue = data.slackNewIssue;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.startDate = data.startDate ?? undefined;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.state = data.state;
    this.targetDate = data.targetDate ?? undefined;
    this.trashed = data.trashed ?? undefined;
    this.updateReminderFrequency = data.updateReminderFrequency ?? undefined;
    this.updateReminderFrequencyInWeeks = data.updateReminderFrequencyInWeeks ?? undefined;
    this.updateRemindersHour = data.updateRemindersHour ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.documentContent = data.documentContent ? new DocumentContent(request, data.documentContent) : undefined;
    this.frequencyResolution = data.frequencyResolution;
    this.health = data.health ?? undefined;
    this.startDateResolution = data.startDateResolution ?? undefined;
    this.targetDateResolution = data.targetDateResolution ?? undefined;
    this.updateRemindersDay = data.updateRemindersDay ?? undefined;
    this._convertedFromIssue = data.convertedFromIssue ?? undefined;
    this._creator = data.creator ?? undefined;
    this._favorite = data.favorite ?? undefined;
    this._integrationsSettings = data.integrationsSettings ?? undefined;
    this._lastAppliedTemplate = data.lastAppliedTemplate ?? undefined;
    this._lastUpdate = data.lastUpdate ?? undefined;
    this._lead = data.lead ?? undefined;
    this._status = data.status;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the project was automatically archived by the auto pruning process. */
  public autoArchivedAt?: Date;
  /** The time at which the project was moved into canceled state. */
  public canceledAt?: Date;
  /** The project's color. */
  public color: string;
  /** The time at which the project was moved into completed state. */
  public completedAt?: Date;
  /** The number of completed issues in the project after each week. */
  public completedIssueCountHistory: number[];
  /** The number of completed estimation points after each week. */
  public completedScopeHistory: number[];
  /** The project's content in markdown format. */
  public content?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The project's description. */
  public description: string;
  /** The time at which the project health was updated. */
  public healthUpdatedAt?: Date;
  /** The icon of the project. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The number of in progress estimation points after each week. */
  public inProgressScopeHistory: number[];
  /** The total number of issues in the project after each week. */
  public issueCountHistory: number[];
  /** Id of the labels associated with this project. */
  public labelIds: string[];
  /** The project's name. */
  public name: string;
  /** The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
  public priority: number;
  /** The priority of the project as a label. */
  public priorityLabel: string;
  /** The sort order for the project within the organization, when ordered by priority. */
  public prioritySortOrder: number;
  /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
  public progress: number;
  /** The time until which project update reminders are paused. */
  public projectUpdateRemindersPausedUntilAt?: Date;
  /** The overall scope (total estimate points) of the project. */
  public scope: number;
  /** The total number of estimation points after each week. */
  public scopeHistory: number[];
  /** Whether to send new issue comment notifications to Slack. */
  public slackIssueComments: boolean;
  /** Whether to send new issue status updates to Slack. */
  public slackIssueStatuses: boolean;
  /** Whether to send new issue notifications to Slack. */
  public slackNewIssue: boolean;
  /** The project's unique URL slug. */
  public slugId: string;
  /** The sort order for the project within the organization. */
  public sortOrder: number;
  /** The estimated start date of the project. */
  public startDate?: L.Scalars["TimelessDate"];
  /** The time at which the project was moved into started state. */
  public startedAt?: Date;
  /** [DEPRECATED] The type of the state. */
  public state: string;
  /** The estimated completion date of the project. */
  public targetDate?: L.Scalars["TimelessDate"];
  /** A flag that indicates whether the project is in the trash bin. */
  public trashed?: boolean;
  /** The frequency at which to prompt for updates. When not set, reminders are inherited from workspace. */
  public updateReminderFrequency?: number;
  /** The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace. */
  public updateReminderFrequencyInWeeks?: number;
  /** The hour at which to prompt for updates. */
  public updateRemindersHour?: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Project URL. */
  public url: string;
  /** The content of the project description. */
  public documentContent?: DocumentContent;
  /** The resolution of the reminder frequency. */
  public frequencyResolution: L.FrequencyResolutionType;
  /** The health of the project. */
  public health?: L.ProjectUpdateHealthType;
  /** The resolution of the project's start date. */
  public startDateResolution?: L.DateResolutionType;
  /** The resolution of the project's estimated completion date. */
  public targetDateResolution?: L.DateResolutionType;
  /** The day at which to prompt for updates. */
  public updateRemindersDay?: L.Day;
  /** The project was created based on this issue. */
  public get convertedFromIssue(): LinearFetch<Issue> | undefined {
    return this._convertedFromIssue?.id ? new IssueQuery(this._request).fetch(this._convertedFromIssue?.id) : undefined;
  }
  /** The ID of project was created based on this issue. */
  public get convertedFromIssueId(): string | undefined {
    return this._convertedFromIssue?.id;
  }
  /** The user who created the project. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the project. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The user's favorite associated with this project. */
  public get favorite(): LinearFetch<Favorite> | undefined {
    return this._favorite?.id ? new FavoriteQuery(this._request).fetch(this._favorite?.id) : undefined;
  }
  /** The ID of user's favorite associated with this project. */
  public get favoriteId(): string | undefined {
    return this._favorite?.id;
  }
  /** Settings for all integrations associated with that project. */
  public get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined {
    return this._integrationsSettings?.id
      ? new IntegrationsSettingsQuery(this._request).fetch(this._integrationsSettings?.id)
      : undefined;
  }
  /** The ID of settings for all integrations associated with that project. */
  public get integrationsSettingsId(): string | undefined {
    return this._integrationsSettings?.id;
  }
  /** The last template that was applied to this project. */
  public get lastAppliedTemplate(): LinearFetch<Template> | undefined {
    return this._lastAppliedTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._lastAppliedTemplate?.id)
      : undefined;
  }
  /** The ID of last template that was applied to this project. */
  public get lastAppliedTemplateId(): string | undefined {
    return this._lastAppliedTemplate?.id;
  }
  /** The last project update posted for this project. */
  public get lastUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return this._lastUpdate?.id ? new ProjectUpdateQuery(this._request).fetch(this._lastUpdate?.id) : undefined;
  }
  /** The ID of last project update posted for this project. */
  public get lastUpdateId(): string | undefined {
    return this._lastUpdate?.id;
  }
  /** The project lead. */
  public get lead(): LinearFetch<User> | undefined {
    return this._lead?.id ? new UserQuery(this._request).fetch(this._lead?.id) : undefined;
  }
  /** The ID of project lead. */
  public get leadId(): string | undefined {
    return this._lead?.id;
  }
  /** The status that the project is associated with. */
  public get status(): LinearFetch<ProjectStatus> | undefined {
    return new ProjectStatusQuery(this._request).fetch(this._status.id);
  }
  /** The ID of status that the project is associated with. */
  public get statusId(): string | undefined {
    return this._status?.id;
  }
  /** Comments associated with the project overview. */
  public comments(variables?: Omit<L.Project_CommentsQueryVariables, "id">) {
    return new Project_CommentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Documents associated with the project. */
  public documents(variables?: Omit<L.Project_DocumentsQueryVariables, "id">) {
    return new Project_DocumentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** External links associated with the project. */
  public externalLinks(variables?: Omit<L.Project_ExternalLinksQueryVariables, "id">) {
    return new Project_ExternalLinksQuery(this._request, this.id, variables).fetch(variables);
  }
  /** History entries associated with the project. */
  public history(variables?: Omit<L.Project_HistoryQueryVariables, "id">) {
    return new Project_HistoryQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Initiatives that this project belongs to. */
  public initiatives(variables?: Omit<L.Project_InitiativesQueryVariables, "id">) {
    return new Project_InitiativesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Inverse relations associated with this project. */
  public inverseRelations(variables?: Omit<L.Project_InverseRelationsQueryVariables, "id">) {
    return new Project_InverseRelationsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Issues associated with the project. */
  public issues(variables?: Omit<L.Project_IssuesQueryVariables, "id">) {
    return new Project_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Labels associated with this project. */
  public labels(variables?: Omit<L.Project_LabelsQueryVariables, "id">) {
    return new Project_LabelsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Users that are members of the project. */
  public members(variables?: Omit<L.Project_MembersQueryVariables, "id">) {
    return new Project_MembersQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Customer needs associated with the project. */
  public needs(variables?: Omit<L.Project_NeedsQueryVariables, "id">) {
    return new Project_NeedsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Milestones associated with the project. */
  public projectMilestones(variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">) {
    return new Project_ProjectMilestonesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Project updates associated with the project. */
  public projectUpdates(variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">) {
    return new Project_ProjectUpdatesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Relations associated with this project. */
  public relations(variables?: Omit<L.Project_RelationsQueryVariables, "id">) {
    return new Project_RelationsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Teams associated with this project. */
  public teams(variables?: Omit<L.Project_TeamsQueryVariables, "id">) {
    return new Project_TeamsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives a project. */
  public archive(variables?: Omit<L.ArchiveProjectMutationVariables, "id">) {
    return new ArchiveProjectMutation(this._request).fetch(this.id, variables);
  }
  /** Creates a new project. */
  public create(input: L.ProjectCreateInput, variables?: Omit<L.CreateProjectMutationVariables, "input">) {
    return new CreateProjectMutation(this._request).fetch(input, variables);
  }
  /** Deletes (trashes) a project. */
  public delete() {
    return new DeleteProjectMutation(this._request).fetch(this.id);
  }
  /** Unarchives a project. */
  public unarchive() {
    return new UnarchiveProjectMutation(this._request).fetch(this.id);
  }
  /** Updates a project. */
  public update() {
    return new ProjectUpdateQuery(this._request).fetch(this.id);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectArchivePayloadFragment response data
 */
export class ProjectArchivePayload extends Request {
  private _entity?: L.ProjectArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.ProjectArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Project> | undefined {
    return this._entity?.id ? new ProjectQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a project.
 *
 * @param data - L.ProjectChildWebhookPayloadFragment response data
 */
export class ProjectChildWebhookPayload {
  public constructor(data: L.ProjectChildWebhookPayloadFragment) {
    this.id = data.id;
    this.name = data.name;
    this.url = data.url;
  }

  /** The ID of the project. */
  public id: string;
  /** The name of the project. */
  public name: string;
  /** The URL of the project. */
  public url: string;
}
/**
 * ProjectConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectConnection model
 * @param data - ProjectConnection response data
 */
export class ProjectConnection extends Connection<Project> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Project> | undefined>,
    data: L.ProjectConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Project(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ProjectFilterSuggestionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectFilterSuggestionPayloadFragment response data
 */
export class ProjectFilterSuggestionPayload extends Request {
  public constructor(request: LinearRequest, data: L.ProjectFilterSuggestionPayloadFragment) {
    super(request);
    this.filter = data.filter ?? undefined;
    this.logId = data.logId ?? undefined;
  }

  /** The json filter that is suggested. */
  public filter?: L.Scalars["JSONObject"];
  /** The log id of the prompt, that created this filter. */
  public logId?: string;
}
/**
 * An history associated with a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectHistoryFragment response data
 */
export class ProjectHistory extends Request {
  private _project: L.ProjectHistoryFragment["project"];

  public constructor(request: LinearRequest, data: L.ProjectHistoryFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.entries = data.entries;
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._project = data.project;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The events that happened while recording that history. */
  public entries: L.Scalars["JSONObject"];
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The project that the history is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project that the history is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
}
/**
 * ProjectHistoryConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectHistoryConnection model
 * @param data - ProjectHistoryConnection response data
 */
export class ProjectHistoryConnection extends Connection<ProjectHistory> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectHistory> | undefined>,
    data: L.ProjectHistoryConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ProjectHistory(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Labels that can be associated with projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectLabelFragment response data
 */
export class ProjectLabel extends Request {
  private _creator?: L.ProjectLabelFragment["creator"];
  private _parent?: L.ProjectLabelFragment["parent"];

  public constructor(request: LinearRequest, data: L.ProjectLabelFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.isGroup = data.isGroup;
    this.lastAppliedAt = parseDate(data.lastAppliedAt) ?? undefined;
    this.name = data.name;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._creator = data.creator ?? undefined;
    this._parent = data.parent ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The label's color as a HEX string. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The label's description. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the label is a group. */
  public isGroup: boolean;
  /** The date when the label was last applied to an issue or project. */
  public lastAppliedAt?: Date;
  /** The label's name. */
  public name: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user who created the label. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the label. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The parent label. */
  public get parent(): LinearFetch<ProjectLabel> | undefined {
    return this._parent?.id ? new ProjectLabelQuery(this._request).fetch(this._parent?.id) : undefined;
  }
  /** The ID of parent label. */
  public get parentId(): string | undefined {
    return this._parent?.id;
  }
  /** Children of the label. */
  public children(variables?: Omit<L.ProjectLabel_ChildrenQueryVariables, "id">) {
    return new ProjectLabel_ChildrenQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Projects associated with the label. */
  public projects(variables?: Omit<L.ProjectLabel_ProjectsQueryVariables, "id">) {
    return new ProjectLabel_ProjectsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new project label. */
  public create(input: L.ProjectLabelCreateInput) {
    return new CreateProjectLabelMutation(this._request).fetch(input);
  }
  /** Deletes a project label. */
  public delete() {
    return new DeleteProjectLabelMutation(this._request).fetch(this.id);
  }
  /** Updates a project label. */
  public update(input: L.ProjectLabelUpdateInput) {
    return new UpdateProjectLabelMutation(this._request).fetch(this.id, input);
  }
}
/**
 * ProjectLabelConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectLabelConnection model
 * @param data - ProjectLabelConnection response data
 */
export class ProjectLabelConnection extends Connection<ProjectLabel> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectLabel> | undefined>,
    data: L.ProjectLabelConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ProjectLabel(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ProjectLabelPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectLabelPayloadFragment response data
 */
export class ProjectLabelPayload extends Request {
  private _projectLabel: L.ProjectLabelPayloadFragment["projectLabel"];

  public constructor(request: LinearRequest, data: L.ProjectLabelPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._projectLabel = data.projectLabel;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The label that was created or updated. */
  public get projectLabel(): LinearFetch<ProjectLabel> | undefined {
    return new ProjectLabelQuery(this._request).fetch(this._projectLabel.id);
  }
  /** The ID of label that was created or updated. */
  public get projectLabelId(): string | undefined {
    return this._projectLabel?.id;
  }
}
/**
 * A milestone for a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestoneFragment response data
 */
export class ProjectMilestone extends Request {
  private _project: L.ProjectMilestoneFragment["project"];

  public constructor(request: LinearRequest, data: L.ProjectMilestoneFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.progress = data.progress;
    this.sortOrder = data.sortOrder;
    this.targetDate = data.targetDate ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.documentContent = data.documentContent ? new DocumentContent(request, data.documentContent) : undefined;
    this.status = data.status;
    this._project = data.project;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The project milestone's description in markdown format. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the project milestone. */
  public name: string;
  /** The progress % of the project milestone. */
  public progress: number;
  /** The order of the milestone in relation to other milestones within a project. */
  public sortOrder: number;
  /** The planned completion date of the milestone. */
  public targetDate?: L.Scalars["TimelessDate"];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The content of the project milestone description. */
  public documentContent?: DocumentContent;
  /** The status of the project milestone. */
  public status: L.ProjectMilestoneStatus;
  /** The project of the milestone. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project of the milestone. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** Issues associated with the project milestone. */
  public issues(variables?: Omit<L.ProjectMilestone_IssuesQueryVariables, "id">) {
    return new ProjectMilestone_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new project milestone. */
  public create(input: L.ProjectMilestoneCreateInput) {
    return new CreateProjectMilestoneMutation(this._request).fetch(input);
  }
  /** Deletes a project milestone. */
  public delete() {
    return new DeleteProjectMilestoneMutation(this._request).fetch(this.id);
  }
  /** Updates a project milestone. */
  public update(input: L.ProjectMilestoneUpdateInput) {
    return new UpdateProjectMilestoneMutation(this._request).fetch(this.id, input);
  }
}
/**
 * Certain properties of a project milestone.
 *
 * @param data - L.ProjectMilestoneChildWebhookPayloadFragment response data
 */
export class ProjectMilestoneChildWebhookPayload {
  public constructor(data: L.ProjectMilestoneChildWebhookPayloadFragment) {
    this.id = data.id;
    this.name = data.name;
    this.targetDate = data.targetDate;
  }

  /** The ID of the project milestone. */
  public id: string;
  /** The name of the project milestone. */
  public name: string;
  /** The target date of the project milestone. */
  public targetDate: string;
}
/**
 * ProjectMilestoneConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectMilestoneConnection model
 * @param data - ProjectMilestoneConnection response data
 */
export class ProjectMilestoneConnection extends Connection<ProjectMilestone> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectMilestone> | undefined>,
    data: L.ProjectMilestoneConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ProjectMilestone(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ProjectMilestoneMoveIssueToTeam model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestoneMoveIssueToTeamFragment response data
 */
export class ProjectMilestoneMoveIssueToTeam extends Request {
  public constructor(request: LinearRequest, data: L.ProjectMilestoneMoveIssueToTeamFragment) {
    super(request);
    this.issueId = data.issueId;
    this.teamId = data.teamId;
  }

  /** The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team */
  public issueId: string;
  /** The team id in this relationship */
  public teamId: string;
}
/**
 * ProjectMilestoneMovePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestoneMovePayloadFragment response data
 */
export class ProjectMilestoneMovePayload extends Request {
  private _projectMilestone: L.ProjectMilestoneMovePayloadFragment["projectMilestone"];

  public constructor(request: LinearRequest, data: L.ProjectMilestoneMovePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.previousProjectTeamIds = data.previousProjectTeamIds
      ? new ProjectMilestoneMoveProjectTeams(request, data.previousProjectTeamIds)
      : undefined;
    this.previousIssueTeamIds = data.previousIssueTeamIds
      ? data.previousIssueTeamIds.map(node => new ProjectMilestoneMoveIssueToTeam(request, node))
      : undefined;
    this._projectMilestone = data.projectMilestone;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** A snapshot of the issues that were moved to new teams, if the user selected to do it, containing an array of mappings between an issue and its previous team. Store on the client to use for undoing a previous milestone move. */
  public previousIssueTeamIds?: ProjectMilestoneMoveIssueToTeam[];
  /** A snapshot of the project that had new teams added to it, if the user selected to do it, containing an array of mappings between a project and its previous teams. Store on the client to use for undoing a previous milestone move. */
  public previousProjectTeamIds?: ProjectMilestoneMoveProjectTeams;
  /** The project milestone that was created or updated. */
  public get projectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return new ProjectMilestoneQuery(this._request).fetch(this._projectMilestone.id);
  }
  /** The ID of project milestone that was created or updated. */
  public get projectMilestoneId(): string | undefined {
    return this._projectMilestone?.id;
  }
}
/**
 * ProjectMilestoneMoveProjectTeams model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestoneMoveProjectTeamsFragment response data
 */
export class ProjectMilestoneMoveProjectTeams extends Request {
  public constructor(request: LinearRequest, data: L.ProjectMilestoneMoveProjectTeamsFragment) {
    super(request);
    this.projectId = data.projectId;
    this.teamIds = data.teamIds;
  }

  /** The project id */
  public projectId: string;
  /** The team ids for the project */
  public teamIds: string[];
}
/**
 * ProjectMilestonePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectMilestonePayloadFragment response data
 */
export class ProjectMilestonePayload extends Request {
  private _projectMilestone: L.ProjectMilestonePayloadFragment["projectMilestone"];

  public constructor(request: LinearRequest, data: L.ProjectMilestonePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._projectMilestone = data.projectMilestone;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The project milestone that was created or updated. */
  public get projectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return new ProjectMilestoneQuery(this._request).fetch(this._projectMilestone.id);
  }
  /** The ID of project milestone that was created or updated. */
  public get projectMilestoneId(): string | undefined {
    return this._projectMilestone?.id;
  }
}
/**
 * A project related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectNotificationFragment response data
 */
export class ProjectNotification extends Request {
  private _actor?: L.ProjectNotificationFragment["actor"];
  private _comment?: L.ProjectNotificationFragment["comment"];
  private _document?: L.ProjectNotificationFragment["document"];
  private _externalUserActor?: L.ProjectNotificationFragment["externalUserActor"];
  private _parentComment?: L.ProjectNotificationFragment["parentComment"];
  private _project: L.ProjectNotificationFragment["project"];
  private _projectUpdate?: L.ProjectNotificationFragment["projectUpdate"];
  private _user: L.ProjectNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.ProjectNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.projectId = data.projectId;
    this.projectMilestoneId = data.projectMilestoneId ?? undefined;
    this.projectUpdateId = data.projectUpdateId ?? undefined;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._comment = data.comment ?? undefined;
    this._document = data.document ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._parentComment = data.parentComment ?? undefined;
    this._project = data.project;
    this._projectUpdate = data.projectUpdate ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Related comment ID. Null if the notification is not related to a comment. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related parent comment ID. Null if the notification is not related to a comment. */
  public parentCommentId?: string;
  /** Related project ID. */
  public projectId: string;
  /** Related project milestone ID. */
  public projectMilestoneId?: string;
  /** Related project update ID. */
  public projectUpdateId?: string;
  /** Name of the reaction emoji related to the notification. */
  public reactionEmoji?: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The comment related to the notification. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The document related to the notification. */
  public get document(): LinearFetch<Document> | undefined {
    return this._document?.id ? new DocumentQuery(this._request).fetch(this._document?.id) : undefined;
  }
  /** The ID of document related to the notification. */
  public get documentId(): string | undefined {
    return this._document?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The parent comment related to the notification, if a notification is a reply comment notification. */
  public get parentComment(): LinearFetch<Comment> | undefined {
    return this._parentComment?.id ? new CommentQuery(this._request).fetch({ id: this._parentComment?.id }) : undefined;
  }
  /** The project related to the notification. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The project update related to the notification. */
  public get projectUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return this._projectUpdate?.id ? new ProjectUpdateQuery(this._request).fetch(this._projectUpdate?.id) : undefined;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * A project notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectNotificationSubscriptionFragment response data
 */
export class ProjectNotificationSubscription extends Request {
  private _customView?: L.ProjectNotificationSubscriptionFragment["customView"];
  private _customer?: L.ProjectNotificationSubscriptionFragment["customer"];
  private _cycle?: L.ProjectNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.ProjectNotificationSubscriptionFragment["initiative"];
  private _label?: L.ProjectNotificationSubscriptionFragment["label"];
  private _project: L.ProjectNotificationSubscriptionFragment["project"];
  private _subscriber: L.ProjectNotificationSubscriptionFragment["subscriber"];
  private _team?: L.ProjectNotificationSubscriptionFragment["team"];
  private _user?: L.ProjectNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.ProjectNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The project subscribed to. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project subscribed to. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * ProjectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectPayloadFragment response data
 */
export class ProjectPayload extends Request {
  private _project?: L.ProjectPayloadFragment["project"];

  public constructor(request: LinearRequest, data: L.ProjectPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._project = data.project ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The project that was created or updated. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of project that was created or updated. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
}
/**
 * A relation between two projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectRelationFragment response data
 */
export class ProjectRelation extends Request {
  private _project: L.ProjectRelationFragment["project"];
  private _projectMilestone?: L.ProjectRelationFragment["projectMilestone"];
  private _relatedProject: L.ProjectRelationFragment["relatedProject"];
  private _relatedProjectMilestone?: L.ProjectRelationFragment["relatedProjectMilestone"];
  private _user?: L.ProjectRelationFragment["user"];

  public constructor(request: LinearRequest, data: L.ProjectRelationFragment) {
    super(request);
    this.anchorType = data.anchorType;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.relatedAnchorType = data.relatedAnchorType;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._project = data.project;
    this._projectMilestone = data.projectMilestone ?? undefined;
    this._relatedProject = data.relatedProject;
    this._relatedProjectMilestone = data.relatedProjectMilestone ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** The type of anchor on the project end of the relation. */
  public anchorType: string;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of anchor on the relatedProject end of the relation. */
  public relatedAnchorType: string;
  /** The relationship of the project with the related project. */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The project whose relationship is being described. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project whose relationship is being described. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The milestone within the project whose relationship is being described. */
  public get projectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return this._projectMilestone?.id
      ? new ProjectMilestoneQuery(this._request).fetch(this._projectMilestone?.id)
      : undefined;
  }
  /** The ID of milestone within the project whose relationship is being described. */
  public get projectMilestoneId(): string | undefined {
    return this._projectMilestone?.id;
  }
  /** The related project. */
  public get relatedProject(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._relatedProject.id);
  }
  /** The ID of related project. */
  public get relatedProjectId(): string | undefined {
    return this._relatedProject?.id;
  }
  /** The milestone within the related project whose relationship is being described. */
  public get relatedProjectMilestone(): LinearFetch<ProjectMilestone> | undefined {
    return this._relatedProjectMilestone?.id
      ? new ProjectMilestoneQuery(this._request).fetch(this._relatedProjectMilestone?.id)
      : undefined;
  }
  /** The ID of milestone within the related project whose relationship is being described. */
  public get relatedProjectMilestoneId(): string | undefined {
    return this._relatedProjectMilestone?.id;
  }
  /** The last user who created or modified the relation. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of last user who created or modified the relation. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Creates a new project relation. */
  public create(input: L.ProjectRelationCreateInput) {
    return new CreateProjectRelationMutation(this._request).fetch(input);
  }
  /** Deletes a project relation. */
  public delete() {
    return new DeleteProjectRelationMutation(this._request).fetch(this.id);
  }
  /** Updates a project relation. */
  public update(input: L.ProjectRelationUpdateInput) {
    return new UpdateProjectRelationMutation(this._request).fetch(this.id, input);
  }
}
/**
 * ProjectRelationConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectRelationConnection model
 * @param data - ProjectRelationConnection response data
 */
export class ProjectRelationConnection extends Connection<ProjectRelation> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectRelation> | undefined>,
    data: L.ProjectRelationConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ProjectRelation(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ProjectRelationPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectRelationPayloadFragment response data
 */
export class ProjectRelationPayload extends Request {
  private _projectRelation: L.ProjectRelationPayloadFragment["projectRelation"];

  public constructor(request: LinearRequest, data: L.ProjectRelationPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._projectRelation = data.projectRelation;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The project relation that was created or updated. */
  public get projectRelation(): LinearFetch<ProjectRelation> | undefined {
    return new ProjectRelationQuery(this._request).fetch(this._projectRelation.id);
  }
  /** The ID of project relation that was created or updated. */
  public get projectRelationId(): string | undefined {
    return this._projectRelation?.id;
  }
}
/**
 * ProjectSearchPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectSearchPayloadFragment response data
 */
export class ProjectSearchPayload extends Request {
  public constructor(request: LinearRequest, data: L.ProjectSearchPayloadFragment) {
    super(request);
    this.totalCount = data.totalCount;
    this.archivePayload = new ArchiveResponse(request, data.archivePayload);
    this.pageInfo = new PageInfo(request, data.pageInfo);
    this.nodes = data.nodes.map(node => new ProjectSearchResult(request, node));
  }

  /** Total number of results for query without filters applied. */
  public totalCount: number;
  public nodes: ProjectSearchResult[];
  /** Archived entities matching the search term along with all their dependencies. */
  public archivePayload: ArchiveResponse;
  public pageInfo: PageInfo;
}
/**
 * ProjectSearchResult model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectSearchResultFragment response data
 */
export class ProjectSearchResult extends Request {
  private _convertedFromIssue?: L.ProjectSearchResultFragment["convertedFromIssue"];
  private _creator?: L.ProjectSearchResultFragment["creator"];
  private _favorite?: L.ProjectSearchResultFragment["favorite"];
  private _integrationsSettings?: L.ProjectSearchResultFragment["integrationsSettings"];
  private _lastAppliedTemplate?: L.ProjectSearchResultFragment["lastAppliedTemplate"];
  private _lastUpdate?: L.ProjectSearchResultFragment["lastUpdate"];
  private _lead?: L.ProjectSearchResultFragment["lead"];
  private _status: L.ProjectSearchResultFragment["status"];

  public constructor(request: LinearRequest, data: L.ProjectSearchResultFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoArchivedAt = parseDate(data.autoArchivedAt) ?? undefined;
    this.canceledAt = parseDate(data.canceledAt) ?? undefined;
    this.color = data.color;
    this.completedAt = parseDate(data.completedAt) ?? undefined;
    this.completedIssueCountHistory = data.completedIssueCountHistory;
    this.completedScopeHistory = data.completedScopeHistory;
    this.content = data.content ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description;
    this.healthUpdatedAt = parseDate(data.healthUpdatedAt) ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.inProgressScopeHistory = data.inProgressScopeHistory;
    this.issueCountHistory = data.issueCountHistory;
    this.labelIds = data.labelIds;
    this.metadata = data.metadata;
    this.name = data.name;
    this.priority = data.priority;
    this.priorityLabel = data.priorityLabel;
    this.prioritySortOrder = data.prioritySortOrder;
    this.progress = data.progress;
    this.projectUpdateRemindersPausedUntilAt = parseDate(data.projectUpdateRemindersPausedUntilAt) ?? undefined;
    this.scope = data.scope;
    this.scopeHistory = data.scopeHistory;
    this.slackIssueComments = data.slackIssueComments;
    this.slackIssueStatuses = data.slackIssueStatuses;
    this.slackNewIssue = data.slackNewIssue;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.startDate = data.startDate ?? undefined;
    this.startedAt = parseDate(data.startedAt) ?? undefined;
    this.state = data.state;
    this.targetDate = data.targetDate ?? undefined;
    this.trashed = data.trashed ?? undefined;
    this.updateReminderFrequency = data.updateReminderFrequency ?? undefined;
    this.updateReminderFrequencyInWeeks = data.updateReminderFrequencyInWeeks ?? undefined;
    this.updateRemindersHour = data.updateRemindersHour ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.documentContent = data.documentContent ? new DocumentContent(request, data.documentContent) : undefined;
    this.frequencyResolution = data.frequencyResolution;
    this.health = data.health ?? undefined;
    this.startDateResolution = data.startDateResolution ?? undefined;
    this.targetDateResolution = data.targetDateResolution ?? undefined;
    this.updateRemindersDay = data.updateRemindersDay ?? undefined;
    this._convertedFromIssue = data.convertedFromIssue ?? undefined;
    this._creator = data.creator ?? undefined;
    this._favorite = data.favorite ?? undefined;
    this._integrationsSettings = data.integrationsSettings ?? undefined;
    this._lastAppliedTemplate = data.lastAppliedTemplate ?? undefined;
    this._lastUpdate = data.lastUpdate ?? undefined;
    this._lead = data.lead ?? undefined;
    this._status = data.status;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the project was automatically archived by the auto pruning process. */
  public autoArchivedAt?: Date;
  /** The time at which the project was moved into canceled state. */
  public canceledAt?: Date;
  /** The project's color. */
  public color: string;
  /** The time at which the project was moved into completed state. */
  public completedAt?: Date;
  /** The number of completed issues in the project after each week. */
  public completedIssueCountHistory: number[];
  /** The number of completed estimation points after each week. */
  public completedScopeHistory: number[];
  /** The project's content in markdown format. */
  public content?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The project's description. */
  public description: string;
  /** The time at which the project health was updated. */
  public healthUpdatedAt?: Date;
  /** The icon of the project. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The number of in progress estimation points after each week. */
  public inProgressScopeHistory: number[];
  /** The total number of issues in the project after each week. */
  public issueCountHistory: number[];
  /** Id of the labels associated with this project. */
  public labelIds: string[];
  /** Metadata related to search result. */
  public metadata: L.Scalars["JSONObject"];
  /** The project's name. */
  public name: string;
  /** The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
  public priority: number;
  /** The priority of the project as a label. */
  public priorityLabel: string;
  /** The sort order for the project within the organization, when ordered by priority. */
  public prioritySortOrder: number;
  /** The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points. */
  public progress: number;
  /** The time until which project update reminders are paused. */
  public projectUpdateRemindersPausedUntilAt?: Date;
  /** The overall scope (total estimate points) of the project. */
  public scope: number;
  /** The total number of estimation points after each week. */
  public scopeHistory: number[];
  /** Whether to send new issue comment notifications to Slack. */
  public slackIssueComments: boolean;
  /** Whether to send new issue status updates to Slack. */
  public slackIssueStatuses: boolean;
  /** Whether to send new issue notifications to Slack. */
  public slackNewIssue: boolean;
  /** The project's unique URL slug. */
  public slugId: string;
  /** The sort order for the project within the organization. */
  public sortOrder: number;
  /** The estimated start date of the project. */
  public startDate?: L.Scalars["TimelessDate"];
  /** The time at which the project was moved into started state. */
  public startedAt?: Date;
  /** [DEPRECATED] The type of the state. */
  public state: string;
  /** The estimated completion date of the project. */
  public targetDate?: L.Scalars["TimelessDate"];
  /** A flag that indicates whether the project is in the trash bin. */
  public trashed?: boolean;
  /** The frequency at which to prompt for updates. When not set, reminders are inherited from workspace. */
  public updateReminderFrequency?: number;
  /** The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace. */
  public updateReminderFrequencyInWeeks?: number;
  /** The hour at which to prompt for updates. */
  public updateRemindersHour?: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Project URL. */
  public url: string;
  /** The content of the project description. */
  public documentContent?: DocumentContent;
  /** The resolution of the reminder frequency. */
  public frequencyResolution: L.FrequencyResolutionType;
  /** The health of the project. */
  public health?: L.ProjectUpdateHealthType;
  /** The resolution of the project's start date. */
  public startDateResolution?: L.DateResolutionType;
  /** The resolution of the project's estimated completion date. */
  public targetDateResolution?: L.DateResolutionType;
  /** The day at which to prompt for updates. */
  public updateRemindersDay?: L.Day;
  /** The project was created based on this issue. */
  public get convertedFromIssue(): LinearFetch<Issue> | undefined {
    return this._convertedFromIssue?.id ? new IssueQuery(this._request).fetch(this._convertedFromIssue?.id) : undefined;
  }
  /** The ID of project was created based on this issue. */
  public get convertedFromIssueId(): string | undefined {
    return this._convertedFromIssue?.id;
  }
  /** The user who created the project. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the project. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The user's favorite associated with this project. */
  public get favorite(): LinearFetch<Favorite> | undefined {
    return this._favorite?.id ? new FavoriteQuery(this._request).fetch(this._favorite?.id) : undefined;
  }
  /** The ID of user's favorite associated with this project. */
  public get favoriteId(): string | undefined {
    return this._favorite?.id;
  }
  /** Settings for all integrations associated with that project. */
  public get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined {
    return this._integrationsSettings?.id
      ? new IntegrationsSettingsQuery(this._request).fetch(this._integrationsSettings?.id)
      : undefined;
  }
  /** The ID of settings for all integrations associated with that project. */
  public get integrationsSettingsId(): string | undefined {
    return this._integrationsSettings?.id;
  }
  /** The last template that was applied to this project. */
  public get lastAppliedTemplate(): LinearFetch<Template> | undefined {
    return this._lastAppliedTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._lastAppliedTemplate?.id)
      : undefined;
  }
  /** The ID of last template that was applied to this project. */
  public get lastAppliedTemplateId(): string | undefined {
    return this._lastAppliedTemplate?.id;
  }
  /** The last project update posted for this project. */
  public get lastUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return this._lastUpdate?.id ? new ProjectUpdateQuery(this._request).fetch(this._lastUpdate?.id) : undefined;
  }
  /** The ID of last project update posted for this project. */
  public get lastUpdateId(): string | undefined {
    return this._lastUpdate?.id;
  }
  /** The project lead. */
  public get lead(): LinearFetch<User> | undefined {
    return this._lead?.id ? new UserQuery(this._request).fetch(this._lead?.id) : undefined;
  }
  /** The ID of project lead. */
  public get leadId(): string | undefined {
    return this._lead?.id;
  }
  /** The status that the project is associated with. */
  public get status(): LinearFetch<ProjectStatus> | undefined {
    return new ProjectStatusQuery(this._request).fetch(this._status.id);
  }
  /** The ID of status that the project is associated with. */
  public get statusId(): string | undefined {
    return this._status?.id;
  }
}
/**
 * A project status.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectStatusFragment response data
 */
export class ProjectStatus extends Request {
  public constructor(request: LinearRequest, data: L.ProjectStatusFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.indefinite = data.indefinite;
    this.name = data.name;
    this.position = data.position;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.type = data.type;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The UI color of the status as a HEX string. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Description of the status. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether or not a project can be in this status indefinitely. */
  public indefinite: boolean;
  /** The name of the status. */
  public name: string;
  /** The position of the status in the workspace's project flow. */
  public position: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of the project status. */
  public type: L.ProjectStatusType;

  /** Archives a project status. */
  public archive() {
    return new ArchiveProjectStatusMutation(this._request).fetch(this.id);
  }
  /** Creates a new project status. */
  public create(input: L.ProjectStatusCreateInput) {
    return new CreateProjectStatusMutation(this._request).fetch(input);
  }
  /** Unarchives a project status. */
  public unarchive() {
    return new UnarchiveProjectStatusMutation(this._request).fetch(this.id);
  }
  /** Updates a project status. */
  public update(input: L.ProjectStatusUpdateInput) {
    return new UpdateProjectStatusMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectStatusArchivePayloadFragment response data
 */
export class ProjectStatusArchivePayload extends Request {
  private _entity?: L.ProjectStatusArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.ProjectStatusArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<ProjectStatus> | undefined {
    return this._entity?.id ? new ProjectStatusQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a project status.
 *
 * @param data - L.ProjectStatusChildWebhookPayloadFragment response data
 */
export class ProjectStatusChildWebhookPayload {
  public constructor(data: L.ProjectStatusChildWebhookPayloadFragment) {
    this.color = data.color;
    this.id = data.id;
    this.name = data.name;
    this.type = data.type;
  }

  /** The color of the project status. */
  public color: string;
  /** The ID of the project status. */
  public id: string;
  /** The name of the project status. */
  public name: string;
  /** The type of the project status. */
  public type: string;
}
/**
 * ProjectStatusConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectStatusConnection model
 * @param data - ProjectStatusConnection response data
 */
export class ProjectStatusConnection extends Connection<ProjectStatus> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectStatus> | undefined>,
    data: L.ProjectStatusConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ProjectStatus(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ProjectStatusCountPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectStatusCountPayloadFragment response data
 */
export class ProjectStatusCountPayload extends Request {
  public constructor(request: LinearRequest, data: L.ProjectStatusCountPayloadFragment) {
    super(request);
    this.archivedTeamCount = data.archivedTeamCount;
    this.count = data.count;
    this.privateCount = data.privateCount;
  }

  /** Total number of projects using this project status that are not visible to the user because they are in an archived team. */
  public archivedTeamCount: number;
  /** Total number of projects using this project status. */
  public count: number;
  /** Total number of projects using this project status that are not visible to the user because they are in a private team. */
  public privateCount: number;
}
/**
 * ProjectStatusPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectStatusPayloadFragment response data
 */
export class ProjectStatusPayload extends Request {
  private _status: L.ProjectStatusPayloadFragment["status"];

  public constructor(request: LinearRequest, data: L.ProjectStatusPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._status = data.status;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The project status that was created or updated. */
  public get status(): LinearFetch<ProjectStatus> | undefined {
    return new ProjectStatusQuery(this._request).fetch(this._status.id);
  }
  /** The ID of project status that was created or updated. */
  public get statusId(): string | undefined {
    return this._status?.id;
  }
}
/**
 * An update associated with a project.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateFragment response data
 */
export class ProjectUpdate extends Request {
  private _project: L.ProjectUpdateFragment["project"];
  private _user: L.ProjectUpdateFragment["user"];

  public constructor(request: LinearRequest, data: L.ProjectUpdateFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.body = data.body;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.diff = data.diff ?? undefined;
    this.diffMarkdown = data.diffMarkdown ?? undefined;
    this.editedAt = parseDate(data.editedAt) ?? undefined;
    this.id = data.id;
    this.isDiffHidden = data.isDiffHidden;
    this.isStale = data.isStale;
    this.reactionData = data.reactionData;
    this.slugId = data.slugId;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this.reactions = data.reactions.map(node => new Reaction(request, node));
    this.health = data.health;
    this._project = data.project;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The update content in markdown format. */
  public body: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The diff between the current update and the previous one. */
  public diff?: L.Scalars["JSONObject"];
  /** The diff between the current update and the previous one, formatted as markdown. */
  public diffMarkdown?: string;
  /** The time the update was edited. */
  public editedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether project update diff should be hidden. */
  public isDiffHidden: boolean;
  /** Whether the project update is stale. */
  public isStale: boolean;
  /** Emoji reaction summary, grouped by emoji type. */
  public reactionData: L.Scalars["JSONObject"];
  /** The update's unique URL slug. */
  public slugId: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The URL to the project update. */
  public url: string;
  /** Reactions associated with the project update. */
  public reactions: Reaction[];
  /** The health of the project at the time of the update. */
  public health: L.ProjectUpdateHealthType;
  /** The project that the update is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project that the update is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user who wrote the update. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user who wrote the update. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
  /** Comments associated with the project update. */
  public comments(variables?: Omit<L.ProjectUpdate_CommentsQueryVariables, "id">) {
    return new ProjectUpdate_CommentsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives a project update. */
  public archive() {
    return new ArchiveProjectUpdateMutation(this._request).fetch(this.id);
  }
  /** Creates a new project update. */
  public create(input: L.ProjectUpdateCreateInput) {
    return new CreateProjectUpdateMutation(this._request).fetch(input);
  }
  /** Deletes a project update. */
  public delete() {
    return new DeleteProjectUpdateMutation(this._request).fetch(this.id);
  }
  /** Unarchives a project update. */
  public unarchive() {
    return new UnarchiveProjectUpdateMutation(this._request).fetch(this.id);
  }
  /** Updates a project update. */
  public update(input: L.ProjectUpdateUpdateInput) {
    return new UpdateProjectUpdateMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateArchivePayloadFragment response data
 */
export class ProjectUpdateArchivePayload extends Request {
  private _entity?: L.ProjectUpdateArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.ProjectUpdateArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<ProjectUpdate> | undefined {
    return this._entity?.id ? new ProjectUpdateQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a project update.
 *
 * @param data - L.ProjectUpdateChildWebhookPayloadFragment response data
 */
export class ProjectUpdateChildWebhookPayload {
  public constructor(data: L.ProjectUpdateChildWebhookPayloadFragment) {
    this.body = data.body;
    this.id = data.id;
    this.userId = data.userId;
    this.project = new ProjectChildWebhookPayload(data.project);
  }

  /** The body of the project update. */
  public body: string;
  /** The ID of the project update. */
  public id: string;
  /** The ID of the user who wrote the project update. */
  public userId: string;
  /** The project that the project update belongs to. */
  public project: ProjectChildWebhookPayload;
}
/**
 * ProjectUpdateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this ProjectUpdateConnection model
 * @param data - ProjectUpdateConnection response data
 */
export class ProjectUpdateConnection extends Connection<ProjectUpdate> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<ProjectUpdate> | undefined>,
    data: L.ProjectUpdateConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new ProjectUpdate(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * ProjectUpdatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdatePayloadFragment response data
 */
export class ProjectUpdatePayload extends Request {
  private _projectUpdate: L.ProjectUpdatePayloadFragment["projectUpdate"];

  public constructor(request: LinearRequest, data: L.ProjectUpdatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._projectUpdate = data.projectUpdate;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The project update that was created or updated. */
  public get projectUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return new ProjectUpdateQuery(this._request).fetch(this._projectUpdate.id);
  }
  /** The ID of project update that was created or updated. */
  public get projectUpdateId(): string | undefined {
    return this._projectUpdate?.id;
  }
}
/**
 * ProjectUpdateReminderPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ProjectUpdateReminderPayloadFragment response data
 */
export class ProjectUpdateReminderPayload extends Request {
  public constructor(request: LinearRequest, data: L.ProjectUpdateReminderPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Payload for a project update webhook.
 *
 * @param data - L.ProjectUpdateWebhookPayloadFragment response data
 */
export class ProjectUpdateWebhookPayload {
  public constructor(data: L.ProjectUpdateWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.body = data.body;
    this.bodyData = data.bodyData;
    this.createdAt = data.createdAt;
    this.editedAt = data.editedAt;
    this.health = data.health;
    this.id = data.id;
    this.projectId = data.projectId;
    this.reactionData = data.reactionData;
    this.slugId = data.slugId;
    this.updatedAt = data.updatedAt;
    this.url = data.url ?? undefined;
    this.userId = data.userId;
    this.project = new ProjectChildWebhookPayload(data.project);
    this.user = new UserChildWebhookPayload(data.user);
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The body of the project update. */
  public body: string;
  /** The body data of the project update. */
  public bodyData: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The edited at timestamp of the project update. */
  public editedAt: string;
  /** The health of the project update. */
  public health: string;
  /** The ID of the entity. */
  public id: string;
  /** The project id of the project update. */
  public projectId: string;
  /** The reaction data for this project update. */
  public reactionData: L.Scalars["JSONObject"];
  /** The slug id of the project update. */
  public slugId: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the project update. */
  public url?: string;
  /** The user id of the project update. */
  public userId: string;
  /** The project that the project update belongs to. */
  public project: ProjectChildWebhookPayload;
  /** The user who wrote the project update. */
  public user: UserChildWebhookPayload;
}
/**
 * Payload for a project webhook.
 *
 * @param data - L.ProjectWebhookPayloadFragment response data
 */
export class ProjectWebhookPayload {
  public constructor(data: L.ProjectWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.autoArchivedAt = data.autoArchivedAt ?? undefined;
    this.canceledAt = data.canceledAt ?? undefined;
    this.color = data.color;
    this.completedAt = data.completedAt ?? undefined;
    this.completedIssueCountHistory = data.completedIssueCountHistory;
    this.completedScopeHistory = data.completedScopeHistory;
    this.content = data.content ?? undefined;
    this.convertedFromIssueId = data.convertedFromIssueId ?? undefined;
    this.createdAt = data.createdAt;
    this.creatorId = data.creatorId ?? undefined;
    this.description = data.description;
    this.documentContentId = data.documentContentId ?? undefined;
    this.health = data.health ?? undefined;
    this.healthUpdatedAt = data.healthUpdatedAt ?? undefined;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.inProgressScopeHistory = data.inProgressScopeHistory;
    this.issueCountHistory = data.issueCountHistory;
    this.labelIds = data.labelIds;
    this.lastAppliedTemplateId = data.lastAppliedTemplateId ?? undefined;
    this.lastUpdateId = data.lastUpdateId ?? undefined;
    this.leadId = data.leadId ?? undefined;
    this.memberIds = data.memberIds;
    this.name = data.name;
    this.priority = data.priority;
    this.prioritySortOrder = data.prioritySortOrder;
    this.projectUpdateRemindersPausedUntilAt = data.projectUpdateRemindersPausedUntilAt ?? undefined;
    this.scopeHistory = data.scopeHistory;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.startDate = data.startDate ?? undefined;
    this.startDateResolution = data.startDateResolution ?? undefined;
    this.startedAt = data.startedAt ?? undefined;
    this.statusId = data.statusId;
    this.targetDate = data.targetDate ?? undefined;
    this.targetDateResolution = data.targetDateResolution ?? undefined;
    this.teamIds = data.teamIds;
    this.trashed = data.trashed ?? undefined;
    this.updatedAt = data.updatedAt;
    this.url = data.url;
    this.lead = data.lead ? new UserChildWebhookPayload(data.lead) : undefined;
    this.status = data.status ? new ProjectStatusChildWebhookPayload(data.status) : undefined;
    this.initiatives = data.initiatives
      ? data.initiatives.map(node => new InitiativeChildWebhookPayload(node))
      : undefined;
    this.milestones = data.milestones
      ? data.milestones.map(node => new ProjectMilestoneChildWebhookPayload(node))
      : undefined;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The auto archived at timestamp of the project. */
  public autoArchivedAt?: string;
  /** The canceled at timestamp of the project. */
  public canceledAt?: string;
  /** The project's color. */
  public color: string;
  /** The completed at timestamp of the project. */
  public completedAt?: string;
  /** The number of completed issues in the project after each week. */
  public completedIssueCountHistory: number[];
  /** The number of completed estimation points after each week. */
  public completedScopeHistory: number[];
  /** The content of the project. */
  public content?: string;
  /** The ID of the issue that was converted to the project. */
  public convertedFromIssueId?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The ID of the user who created the project. */
  public creatorId?: string;
  /** The project's description. */
  public description: string;
  /** The document content ID of the project. */
  public documentContentId?: string;
  /** The health of the project. */
  public health?: string;
  /** The time at which the project health was updated. */
  public healthUpdatedAt?: string;
  /** The icon of the project. */
  public icon?: string;
  /** The ID of the entity. */
  public id: string;
  /** The number of in progress estimation points after each week. */
  public inProgressScopeHistory: number[];
  /** The total number of issues in the project after each week. */
  public issueCountHistory: number[];
  /** IDs of the labels associated with this project. */
  public labelIds: string[];
  /** The ID of the last template that was applied to the project. */
  public lastAppliedTemplateId?: string;
  /** The ID of the last update posted for this project. */
  public lastUpdateId?: string;
  /** The ID of the project lead. */
  public leadId?: string;
  /** IDs of the members of the project. */
  public memberIds: string[];
  /** The project's name. */
  public name: string;
  /** The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low. */
  public priority: number;
  /** The sort order for the project within the organization, when ordered by priority. */
  public prioritySortOrder: number;
  /** The time at which the project update reminders were paused until. */
  public projectUpdateRemindersPausedUntilAt?: string;
  /** The total number of estimation points after each week. */
  public scopeHistory: number[];
  /** The project's unique URL slug. */
  public slugId: string;
  /** The sort order for the project within the organization. */
  public sortOrder: number;
  /** The estimated start date of the project. */
  public startDate?: string;
  /** The resolution of the project's estimated start date. */
  public startDateResolution?: string;
  /** The time at which the project was moved into started state. */
  public startedAt?: string;
  /** The ID of the project status. */
  public statusId: string;
  /** The target date of the project. */
  public targetDate?: string;
  /** The resolution of the project's target date. */
  public targetDateResolution?: string;
  /** IDs of the teams associated with this project. */
  public teamIds: string[];
  /** The trashed status of the project. */
  public trashed?: boolean;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the project. */
  public url: string;
  /** The initiatives associated with the project. */
  public initiatives?: InitiativeChildWebhookPayload[];
  /** The milestones associated with the project. */
  public milestones?: ProjectMilestoneChildWebhookPayload[];
  /** The project lead. */
  public lead?: UserChildWebhookPayload;
  /** The project status. */
  public status?: ProjectStatusChildWebhookPayload;
}
/**
 * A pull request related notification.
 *
 * @param request - function to call the graphql client
 * @param data - L.PullRequestNotificationFragment response data
 */
export class PullRequestNotification extends Request {
  private _actor?: L.PullRequestNotificationFragment["actor"];
  private _externalUserActor?: L.PullRequestNotificationFragment["externalUserActor"];
  private _user: L.PullRequestNotificationFragment["user"];

  public constructor(request: LinearRequest, data: L.PullRequestNotificationFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emailedAt = parseDate(data.emailedAt) ?? undefined;
    this.id = data.id;
    this.parentCommentId = data.parentCommentId ?? undefined;
    this.pullRequestId = data.pullRequestId;
    this.reactionEmoji = data.reactionEmoji ?? undefined;
    this.readAt = parseDate(data.readAt) ?? undefined;
    this.snoozedUntilAt = parseDate(data.snoozedUntilAt) ?? undefined;
    this.type = data.type;
    this.unsnoozedAt = parseDate(data.unsnoozedAt) ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.botActor = data.botActor ? new ActorBot(request, data.botActor) : undefined;
    this._actor = data.actor ?? undefined;
    this._externalUserActor = data.externalUserActor ?? undefined;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Related comment ID. Null if the notification is not related to a comment. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /**
   * The time at when an email reminder for this notification was sent to the user. Null, if no email
   *     reminder has been sent.
   */
  public emailedAt?: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Related parent comment ID. Null if the notification is not related to a comment. */
  public parentCommentId?: string;
  /** Related pull request. */
  public pullRequestId: string;
  /** Name of the reaction emoji related to the notification. */
  public reactionEmoji?: string;
  /** The time at when the user marked the notification as read. Null, if the the user hasn't read the notification */
  public readAt?: Date;
  /** The time until a notification will be snoozed. After that it will appear in the inbox again. */
  public snoozedUntilAt?: Date;
  /** Notification type. */
  public type: string;
  /** The time at which a notification was unsnoozed.. */
  public unsnoozedAt?: Date;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The bot that caused the notification. */
  public botActor?: ActorBot;
  /** The user that caused the notification. */
  public get actor(): LinearFetch<User> | undefined {
    return this._actor?.id ? new UserQuery(this._request).fetch(this._actor?.id) : undefined;
  }
  /** The ID of user that caused the notification. */
  public get actorId(): string | undefined {
    return this._actor?.id;
  }
  /** The external user that caused the notification. */
  public get externalUserActor(): LinearFetch<ExternalUser> | undefined {
    return this._externalUserActor?.id
      ? new ExternalUserQuery(this._request).fetch(this._externalUserActor?.id)
      : undefined;
  }
  /** The ID of external user that caused the notification. */
  public get externalUserActorId(): string | undefined {
    return this._externalUserActor?.id;
  }
  /** The user that received the notification. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that received the notification. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * A user's web or mobile push notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionFragment response data
 */
export class PushSubscription extends Request {
  public constructor(request: LinearRequest, data: L.PushSubscriptionFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;

  /** Creates a push subscription. */
  public create(input: L.PushSubscriptionCreateInput) {
    return new CreatePushSubscriptionMutation(this._request).fetch(input);
  }
  /** Deletes a push subscription. */
  public delete() {
    return new DeletePushSubscriptionMutation(this._request).fetch(this.id);
  }
}
/**
 * PushSubscriptionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionPayloadFragment response data
 */
export class PushSubscriptionPayload extends Request {
  public constructor(request: LinearRequest, data: L.PushSubscriptionPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.entity = new PushSubscription(request, data.entity);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The push subscription that was created or updated. */
  public entity: PushSubscription;
}
/**
 * PushSubscriptionTestPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.PushSubscriptionTestPayloadFragment response data
 */
export class PushSubscriptionTestPayload extends Request {
  public constructor(request: LinearRequest, data: L.PushSubscriptionTestPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * RateLimitPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RateLimitPayloadFragment response data
 */
export class RateLimitPayload extends Request {
  public constructor(request: LinearRequest, data: L.RateLimitPayloadFragment) {
    super(request);
    this.identifier = data.identifier ?? undefined;
    this.kind = data.kind;
    this.limits = data.limits.map(node => new RateLimitResultPayload(request, node));
  }

  /** The identifier we rate limit on. */
  public identifier?: string;
  /** The kind of rate limit selected for this request. */
  public kind: string;
  /** The state of the rate limit. */
  public limits: RateLimitResultPayload[];
}
/**
 * RateLimitResultPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RateLimitResultPayloadFragment response data
 */
export class RateLimitResultPayload extends Request {
  public constructor(request: LinearRequest, data: L.RateLimitResultPayloadFragment) {
    super(request);
    this.allowedAmount = data.allowedAmount;
    this.period = data.period;
    this.remainingAmount = data.remainingAmount;
    this.requestedAmount = data.requestedAmount;
    this.reset = data.reset;
    this.type = data.type;
  }

  /** The total allowed quantity for this type of limit. */
  public allowedAmount: number;
  /** The period in which the rate limit is fully replenished in ms. */
  public period: number;
  /** The remaining quantity for this type of limit after this request. */
  public remainingAmount: number;
  /** The requested quantity for this type of limit. */
  public requestedAmount: number;
  /** The timestamp after the rate limit is fully replenished as a UNIX timestamp. */
  public reset: number;
  /** What is being rate limited. */
  public type: string;
}
/**
 * A reaction associated with a comment or a project update.
 *
 * @param request - function to call the graphql client
 * @param data - L.ReactionFragment response data
 */
export class Reaction extends Request {
  private _comment?: L.ReactionFragment["comment"];
  private _externalUser?: L.ReactionFragment["externalUser"];
  private _initiativeUpdate?: L.ReactionFragment["initiativeUpdate"];
  private _issue?: L.ReactionFragment["issue"];
  private _projectUpdate?: L.ReactionFragment["projectUpdate"];
  private _user?: L.ReactionFragment["user"];

  public constructor(request: LinearRequest, data: L.ReactionFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.emoji = data.emoji;
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._comment = data.comment ?? undefined;
    this._externalUser = data.externalUser ?? undefined;
    this._initiativeUpdate = data.initiativeUpdate ?? undefined;
    this._issue = data.issue ?? undefined;
    this._projectUpdate = data.projectUpdate ?? undefined;
    this._user = data.user ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Name of the reaction's emoji. */
  public emoji: string;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The comment that the reaction is associated with. */
  public get comment(): LinearFetch<Comment> | undefined {
    return this._comment?.id ? new CommentQuery(this._request).fetch({ id: this._comment?.id }) : undefined;
  }
  /** The ID of comment that the reaction is associated with. */
  public get commentId(): string | undefined {
    return this._comment?.id;
  }
  /** The external user that created the reaction. */
  public get externalUser(): LinearFetch<ExternalUser> | undefined {
    return this._externalUser?.id ? new ExternalUserQuery(this._request).fetch(this._externalUser?.id) : undefined;
  }
  /** The ID of external user that created the reaction. */
  public get externalUserId(): string | undefined {
    return this._externalUser?.id;
  }
  /** The initiative update that the reaction is associated with. */
  public get initiativeUpdate(): LinearFetch<InitiativeUpdate> | undefined {
    return this._initiativeUpdate?.id
      ? new InitiativeUpdateQuery(this._request).fetch(this._initiativeUpdate?.id)
      : undefined;
  }
  /** The ID of initiative update that the reaction is associated with. */
  public get initiativeUpdateId(): string | undefined {
    return this._initiativeUpdate?.id;
  }
  /** The issue that the reaction is associated with. */
  public get issue(): LinearFetch<Issue> | undefined {
    return this._issue?.id ? new IssueQuery(this._request).fetch(this._issue?.id) : undefined;
  }
  /** The ID of issue that the reaction is associated with. */
  public get issueId(): string | undefined {
    return this._issue?.id;
  }
  /** The project update that the reaction is associated with. */
  public get projectUpdate(): LinearFetch<ProjectUpdate> | undefined {
    return this._projectUpdate?.id ? new ProjectUpdateQuery(this._request).fetch(this._projectUpdate?.id) : undefined;
  }
  /** The ID of project update that the reaction is associated with. */
  public get projectUpdateId(): string | undefined {
    return this._projectUpdate?.id;
  }
  /** The user that created the reaction. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user that created the reaction. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Creates a new reaction. */
  public create(input: L.ReactionCreateInput) {
    return new CreateReactionMutation(this._request).fetch(input);
  }
  /** Deletes a reaction. */
  public delete() {
    return new DeleteReactionMutation(this._request).fetch(this.id);
  }
}
/**
 * ReactionPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ReactionPayloadFragment response data
 */
export class ReactionPayload extends Request {
  public constructor(request: LinearRequest, data: L.ReactionPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.reaction = new Reaction(request, data.reaction);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  public success: boolean;
  public reaction: Reaction;
}
/**
 * Payload for a reaction webhook.
 *
 * @param data - L.ReactionWebhookPayloadFragment response data
 */
export class ReactionWebhookPayload {
  public constructor(data: L.ReactionWebhookPayloadFragment) {
    this.archivedAt = data.archivedAt ?? undefined;
    this.commentId = data.commentId ?? undefined;
    this.createdAt = data.createdAt;
    this.emoji = data.emoji;
    this.externalUserId = data.externalUserId ?? undefined;
    this.id = data.id;
    this.initiativeUpdateId = data.initiativeUpdateId ?? undefined;
    this.issueId = data.issueId ?? undefined;
    this.postId = data.postId ?? undefined;
    this.projectUpdateId = data.projectUpdateId ?? undefined;
    this.updatedAt = data.updatedAt;
    this.userId = data.userId ?? undefined;
    this.comment = data.comment ? new CommentChildWebhookPayload(data.comment) : undefined;
    this.issue = data.issue ? new IssueChildWebhookPayload(data.issue) : undefined;
    this.projectUpdate = data.projectUpdate ? new ProjectUpdateChildWebhookPayload(data.projectUpdate) : undefined;
    this.user = data.user ? new UserChildWebhookPayload(data.user) : undefined;
  }

  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The ID of the comment that the reaction is associated with. */
  public commentId?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** Name of the reaction's emoji. */
  public emoji: string;
  /** The ID of the external user that created the reaction. */
  public externalUserId?: string;
  /** The ID of the entity. */
  public id: string;
  /** The ID of the initiative update that the reaction is associated with. */
  public initiativeUpdateId?: string;
  /** The ID of the issue that the reaction is associated with. */
  public issueId?: string;
  /** The ID of the post that the reaction is associated with. */
  public postId?: string;
  /** The ID of the project update that the reaction is associated with. */
  public projectUpdateId?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The ID of the user that created the reaction. */
  public userId?: string;
  /** The comment the reaction is associated with. */
  public comment?: CommentChildWebhookPayload;
  /** The issue the reaction is associated with. */
  public issue?: IssueChildWebhookPayload;
  /** The project update the reaction is associated with. */
  public projectUpdate?: ProjectUpdateChildWebhookPayload;
  /** The user that created the reaction. */
  public user?: UserChildWebhookPayload;
}
/**
 * A roadmap for projects.
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapFragment response data
 */
export class Roadmap extends Request {
  private _creator: L.RoadmapFragment["creator"];
  private _owner?: L.RoadmapFragment["owner"];

  public constructor(request: LinearRequest, data: L.RoadmapFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.slugId = data.slugId;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
    this._creator = data.creator;
    this._owner = data.owner ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The roadmap's color. */
  public color?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The description of the roadmap. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the roadmap. */
  public name: string;
  /** The roadmap's unique URL slug. */
  public slugId: string;
  /** The sort order of the roadmap within the organization. */
  public sortOrder: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The canonical url for the roadmap. */
  public url: string;
  /** The user who created the roadmap. */
  public get creator(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._creator.id);
  }
  /** The ID of user who created the roadmap. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization of the roadmap. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The user who owns the roadmap. */
  public get owner(): LinearFetch<User> | undefined {
    return this._owner?.id ? new UserQuery(this._request).fetch(this._owner?.id) : undefined;
  }
  /** The ID of user who owns the roadmap. */
  public get ownerId(): string | undefined {
    return this._owner?.id;
  }
  /** Projects associated with the roadmap. */
  public projects(variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">) {
    return new Roadmap_ProjectsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives a roadmap. */
  public archive() {
    return new ArchiveRoadmapMutation(this._request).fetch(this.id);
  }
  /** Creates a new roadmap. */
  public create(input: L.RoadmapCreateInput) {
    return new CreateRoadmapMutation(this._request).fetch(input);
  }
  /** Deletes a roadmap. */
  public delete() {
    return new DeleteRoadmapMutation(this._request).fetch(this.id);
  }
  /** Unarchives a roadmap. */
  public unarchive() {
    return new UnarchiveRoadmapMutation(this._request).fetch(this.id);
  }
  /** Updates a roadmap. */
  public update(input: L.RoadmapUpdateInput) {
    return new UpdateRoadmapMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapArchivePayloadFragment response data
 */
export class RoadmapArchivePayload extends Request {
  private _entity?: L.RoadmapArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.RoadmapArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Roadmap> | undefined {
    return this._entity?.id ? new RoadmapQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * RoadmapConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this RoadmapConnection model
 * @param data - RoadmapConnection response data
 */
export class RoadmapConnection extends Connection<Roadmap> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Roadmap> | undefined>,
    data: L.RoadmapConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Roadmap(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * RoadmapPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapPayloadFragment response data
 */
export class RoadmapPayload extends Request {
  private _roadmap: L.RoadmapPayloadFragment["roadmap"];

  public constructor(request: LinearRequest, data: L.RoadmapPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._roadmap = data.roadmap;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The roadmap that was created or updated. */
  public get roadmap(): LinearFetch<Roadmap> | undefined {
    return new RoadmapQuery(this._request).fetch(this._roadmap.id);
  }
  /** The ID of roadmap that was created or updated. */
  public get roadmapId(): string | undefined {
    return this._roadmap?.id;
  }
}
/**
 * Join table between projects and roadmaps.
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapToProjectFragment response data
 */
export class RoadmapToProject extends Request {
  private _project: L.RoadmapToProjectFragment["project"];
  private _roadmap: L.RoadmapToProjectFragment["roadmap"];

  public constructor(request: LinearRequest, data: L.RoadmapToProjectFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._project = data.project;
    this._roadmap = data.roadmap;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The sort order of the project within the roadmap. */
  public sortOrder: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The project that the roadmap is associated with. */
  public get project(): LinearFetch<Project> | undefined {
    return new ProjectQuery(this._request).fetch(this._project.id);
  }
  /** The ID of project that the roadmap is associated with. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The roadmap that the project is associated with. */
  public get roadmap(): LinearFetch<Roadmap> | undefined {
    return new RoadmapQuery(this._request).fetch(this._roadmap.id);
  }
  /** The ID of roadmap that the project is associated with. */
  public get roadmapId(): string | undefined {
    return this._roadmap?.id;
  }

  /** Creates a new roadmapToProject join. */
  public create(input: L.RoadmapToProjectCreateInput) {
    return new CreateRoadmapToProjectMutation(this._request).fetch(input);
  }
  /** Deletes a roadmapToProject. */
  public delete() {
    return new DeleteRoadmapToProjectMutation(this._request).fetch(this.id);
  }
  /** Updates a roadmapToProject. */
  public update(input: L.RoadmapToProjectUpdateInput) {
    return new UpdateRoadmapToProjectMutation(this._request).fetch(this.id, input);
  }
}
/**
 * RoadmapToProjectConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this RoadmapToProjectConnection model
 * @param data - RoadmapToProjectConnection response data
 */
export class RoadmapToProjectConnection extends Connection<RoadmapToProject> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<RoadmapToProject> | undefined>,
    data: L.RoadmapToProjectConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new RoadmapToProject(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * RoadmapToProjectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.RoadmapToProjectPayloadFragment response data
 */
export class RoadmapToProjectPayload extends Request {
  private _roadmapToProject: L.RoadmapToProjectPayloadFragment["roadmapToProject"];

  public constructor(request: LinearRequest, data: L.RoadmapToProjectPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._roadmapToProject = data.roadmapToProject;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The roadmapToProject that was created or updated. */
  public get roadmapToProject(): LinearFetch<RoadmapToProject> | undefined {
    return new RoadmapToProjectQuery(this._request).fetch(this._roadmapToProject.id);
  }
  /** The ID of roadmaptoproject that was created or updated. */
  public get roadmapToProjectId(): string | undefined {
    return this._roadmapToProject?.id;
  }
}
/**
 * SES domain identity used for sending emails from a custom domain.
 *
 * @param request - function to call the graphql client
 * @param data - L.SesDomainIdentityFragment response data
 */
export class SesDomainIdentity extends Request {
  private _creator?: L.SesDomainIdentityFragment["creator"];

  public constructor(request: LinearRequest, data: L.SesDomainIdentityFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.canSendFromCustomDomain = data.canSendFromCustomDomain;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.domain = data.domain;
    this.id = data.id;
    this.region = data.region;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.dnsRecords = data.dnsRecords.map(node => new SesDomainIdentityDnsRecord(request, node));
    this._creator = data.creator ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Whether the domain is fully verified and can be used for sending emails. */
  public canSendFromCustomDomain: boolean;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The domain of the SES domain identity. */
  public domain: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The AWS region of the SES domain identity. */
  public region: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The DNS records for the SES domain identity. */
  public dnsRecords: SesDomainIdentityDnsRecord[];
  /** The user who created the SES domain identity. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the ses domain identity. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The organization of the SES domain identity. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
}
/**
 * A DNS record for a SES domain identity.
 *
 * @param request - function to call the graphql client
 * @param data - L.SesDomainIdentityDnsRecordFragment response data
 */
export class SesDomainIdentityDnsRecord extends Request {
  public constructor(request: LinearRequest, data: L.SesDomainIdentityDnsRecordFragment) {
    super(request);
    this.content = data.content;
    this.isVerified = data.isVerified;
    this.name = data.name;
    this.type = data.type;
  }

  /** The content of the DNS record. */
  public content: string;
  /** Whether the DNS record is verified in the domain's DNS configuration. */
  public isVerified: boolean;
  /** The name of the DNS record. */
  public name: string;
  /** The type of the DNS record. */
  public type: string;
}
/**
 * Tuple for mapping Slack channel IDs to names.
 *
 * @param request - function to call the graphql client
 * @param data - L.SlackAsksTeamSettingsFragment response data
 */
export class SlackAsksTeamSettings extends Request {
  public constructor(request: LinearRequest, data: L.SlackAsksTeamSettingsFragment) {
    super(request);
    this.hasDefaultAsk = data.hasDefaultAsk;
    this.id = data.id;
  }

  /** Whether the default Asks template is enabled in the given channel for this team. */
  public hasDefaultAsk: boolean;
  /** The Linear team ID. */
  public id: string;
}
/**
 * SlackChannelConnectPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SlackChannelConnectPayloadFragment response data
 */
export class SlackChannelConnectPayload extends Request {
  private _integration?: L.SlackChannelConnectPayloadFragment["integration"];

  public constructor(request: LinearRequest, data: L.SlackChannelConnectPayloadFragment) {
    super(request);
    this.addBot = data.addBot;
    this.lastSyncId = data.lastSyncId;
    this.nudgeToConnectMainSlackIntegration = data.nudgeToConnectMainSlackIntegration ?? undefined;
    this.nudgeToUpdateMainSlackIntegration = data.nudgeToUpdateMainSlackIntegration ?? undefined;
    this.success = data.success;
    this._integration = data.integration ?? undefined;
  }

  /** Whether the bot needs to be manually added to the channel. */
  public addBot: boolean;
  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether it's recommended to connect main Slack integration. */
  public nudgeToConnectMainSlackIntegration?: boolean;
  /** Whether it's recommended to update main Slack integration. */
  public nudgeToUpdateMainSlackIntegration?: boolean;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The integration that was created or updated. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of integration that was created or updated. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
}
/**
 * Object for mapping Slack channel IDs to names and other settings.
 *
 * @param request - function to call the graphql client
 * @param data - L.SlackChannelNameMappingFragment response data
 */
export class SlackChannelNameMapping extends Request {
  public constructor(request: LinearRequest, data: L.SlackChannelNameMappingFragment) {
    super(request);
    this.aiTitles = data.aiTitles ?? undefined;
    this.autoCreateOnBotMention = data.autoCreateOnBotMention ?? undefined;
    this.autoCreateOnEmoji = data.autoCreateOnEmoji ?? undefined;
    this.autoCreateOnMessage = data.autoCreateOnMessage ?? undefined;
    this.autoCreateTemplateId = data.autoCreateTemplateId ?? undefined;
    this.botAdded = data.botAdded ?? undefined;
    this.id = data.id;
    this.isPrivate = data.isPrivate ?? undefined;
    this.isShared = data.isShared ?? undefined;
    this.name = data.name;
    this.postAcceptedFromTriageUpdates = data.postAcceptedFromTriageUpdates ?? undefined;
    this.postCancellationUpdates = data.postCancellationUpdates ?? undefined;
    this.postCompletionUpdates = data.postCompletionUpdates ?? undefined;
    this.teams = data.teams.map(node => new SlackAsksTeamSettings(request, node));
  }

  /** Whether or not to use AI to generate titles for Asks created in this channel. */
  public aiTitles?: boolean;
  /** Whether or not @-mentioning the bot should automatically create an Ask with the message. */
  public autoCreateOnBotMention?: boolean;
  /** Whether or not using the :ticket: emoji in this channel should automatically create Asks. */
  public autoCreateOnEmoji?: boolean;
  /** Whether or not top-level messages in this channel should automatically create Asks. */
  public autoCreateOnMessage?: boolean;
  /** The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template. */
  public autoCreateTemplateId?: string;
  /** Whether or not the Linear Asks bot has been added to this Slack channel. */
  public botAdded?: boolean;
  /** The Slack channel ID. */
  public id: string;
  /** Whether or not the Slack channel is private. */
  public isPrivate?: boolean;
  /** Whether or not the Slack channel is shared with an external org. */
  public isShared?: boolean;
  /** The Slack channel name. */
  public name: string;
  /** Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage. */
  public postAcceptedFromTriageUpdates?: boolean;
  /** Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled. */
  public postCancellationUpdates?: boolean;
  /** Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed. */
  public postCompletionUpdates?: boolean;
  /** Which teams are connected to the channel and settings for those teams. */
  public teams: SlackAsksTeamSettings[];
}
/**
 * SsoUrlFromEmailResponse model
 *
 * @param request - function to call the graphql client
 * @param data - L.SsoUrlFromEmailResponseFragment response data
 */
export class SsoUrlFromEmailResponse extends Request {
  public constructor(request: LinearRequest, data: L.SsoUrlFromEmailResponseFragment) {
    super(request);
    this.samlSsoUrl = data.samlSsoUrl;
    this.success = data.success;
  }

  /** SAML SSO sign-in URL. */
  public samlSsoUrl: string;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * SuccessPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SuccessPayloadFragment response data
 */
export class SuccessPayload extends Request {
  public constructor(request: LinearRequest, data: L.SuccessPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * SummaryPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.SummaryPayloadFragment response data
 */
export class SummaryPayload extends Request {
  public constructor(request: LinearRequest, data: L.SummaryPayloadFragment) {
    super(request);
    this.summary = data.summary;
  }

  /** Summary for project updates. */
  public summary: string;
}
/**
 * A comment thread that is synced with an external source.
 *
 * @param request - function to call the graphql client
 * @param data - L.SyncedExternalThreadFragment response data
 */
export class SyncedExternalThread extends Request {
  public constructor(request: LinearRequest, data: L.SyncedExternalThreadFragment) {
    super(request);
    this.displayName = data.displayName ?? undefined;
    this.id = data.id ?? undefined;
    this.isConnected = data.isConnected;
    this.isPersonalIntegrationConnected = data.isPersonalIntegrationConnected;
    this.isPersonalIntegrationRequired = data.isPersonalIntegrationRequired;
    this.name = data.name ?? undefined;
    this.subType = data.subType ?? undefined;
    this.type = data.type;
    this.url = data.url ?? undefined;
  }

  /** The display name of the thread. */
  public displayName?: string;
  public id?: string;
  /** Whether this thread is syncing with the external service. */
  public isConnected: boolean;
  /** Whether the current user has the corresponding personal integration connected for the external service. */
  public isPersonalIntegrationConnected: boolean;
  /** Whether a connected personal integration is required to comment in this thread. */
  public isPersonalIntegrationRequired: boolean;
  /** The display name of the source. */
  public name?: string;
  /** The sub type of the external source. */
  public subType?: string;
  /** The type of the external source. */
  public type: string;
  /** The external url of the thread. */
  public url?: string;
}
/**
 * An organizational unit that contains issues.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamFragment response data
 */
export class Team extends Request {
  private _activeCycle?: L.TeamFragment["activeCycle"];
  private _defaultIssueState?: L.TeamFragment["defaultIssueState"];
  private _defaultProjectTemplate?: L.TeamFragment["defaultProjectTemplate"];
  private _defaultTemplateForMembers?: L.TeamFragment["defaultTemplateForMembers"];
  private _defaultTemplateForNonMembers?: L.TeamFragment["defaultTemplateForNonMembers"];
  private _draftWorkflowState?: L.TeamFragment["draftWorkflowState"];
  private _integrationsSettings?: L.TeamFragment["integrationsSettings"];
  private _markedAsDuplicateWorkflowState?: L.TeamFragment["markedAsDuplicateWorkflowState"];
  private _mergeWorkflowState?: L.TeamFragment["mergeWorkflowState"];
  private _mergeableWorkflowState?: L.TeamFragment["mergeableWorkflowState"];
  private _reviewWorkflowState?: L.TeamFragment["reviewWorkflowState"];
  private _startWorkflowState?: L.TeamFragment["startWorkflowState"];
  private _triageIssueState?: L.TeamFragment["triageIssueState"];
  private _triageResponsibility?: L.TeamFragment["triageResponsibility"];

  public constructor(request: LinearRequest, data: L.TeamFragment) {
    super(request);
    this.aiThreadSummariesEnabled = data.aiThreadSummariesEnabled;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoArchivePeriod = data.autoArchivePeriod;
    this.autoCloseChildIssues = data.autoCloseChildIssues ?? undefined;
    this.autoCloseParentIssues = data.autoCloseParentIssues ?? undefined;
    this.autoClosePeriod = data.autoClosePeriod ?? undefined;
    this.autoCloseStateId = data.autoCloseStateId ?? undefined;
    this.color = data.color ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.cycleCalenderUrl = data.cycleCalenderUrl;
    this.cycleCooldownTime = data.cycleCooldownTime;
    this.cycleDuration = data.cycleDuration;
    this.cycleIssueAutoAssignCompleted = data.cycleIssueAutoAssignCompleted;
    this.cycleIssueAutoAssignStarted = data.cycleIssueAutoAssignStarted;
    this.cycleLockToActive = data.cycleLockToActive;
    this.cycleStartDay = data.cycleStartDay;
    this.cyclesEnabled = data.cyclesEnabled;
    this.defaultIssueEstimate = data.defaultIssueEstimate;
    this.defaultTemplateForMembersId = data.defaultTemplateForMembersId ?? undefined;
    this.defaultTemplateForNonMembersId = data.defaultTemplateForNonMembersId ?? undefined;
    this.description = data.description ?? undefined;
    this.displayName = data.displayName;
    this.groupIssueHistory = data.groupIssueHistory;
    this.icon = data.icon ?? undefined;
    this.id = data.id;
    this.inheritIssueEstimation = data.inheritIssueEstimation;
    this.inheritWorkflowStatuses = data.inheritWorkflowStatuses;
    this.inviteHash = data.inviteHash;
    this.issueCount = data.issueCount;
    this.issueEstimationAllowZero = data.issueEstimationAllowZero;
    this.issueEstimationExtended = data.issueEstimationExtended;
    this.issueEstimationType = data.issueEstimationType;
    this.issueOrderingNoPriorityFirst = data.issueOrderingNoPriorityFirst;
    this.issueSortOrderDefaultToBottom = data.issueSortOrderDefaultToBottom;
    this.key = data.key;
    this.name = data.name;
    this.private = data.private;
    this.requirePriorityToLeaveTriage = data.requirePriorityToLeaveTriage;
    this.scimGroupName = data.scimGroupName ?? undefined;
    this.scimManaged = data.scimManaged;
    this.setIssueSortOrderOnStateChange = data.setIssueSortOrderOnStateChange;
    this.slackIssueComments = data.slackIssueComments;
    this.slackIssueStatuses = data.slackIssueStatuses;
    this.slackNewIssue = data.slackNewIssue;
    this.timezone = data.timezone;
    this.triageEnabled = data.triageEnabled;
    this.upcomingCycleCount = data.upcomingCycleCount;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._activeCycle = data.activeCycle ?? undefined;
    this._defaultIssueState = data.defaultIssueState ?? undefined;
    this._defaultProjectTemplate = data.defaultProjectTemplate ?? undefined;
    this._defaultTemplateForMembers = data.defaultTemplateForMembers ?? undefined;
    this._defaultTemplateForNonMembers = data.defaultTemplateForNonMembers ?? undefined;
    this._draftWorkflowState = data.draftWorkflowState ?? undefined;
    this._integrationsSettings = data.integrationsSettings ?? undefined;
    this._markedAsDuplicateWorkflowState = data.markedAsDuplicateWorkflowState ?? undefined;
    this._mergeWorkflowState = data.mergeWorkflowState ?? undefined;
    this._mergeableWorkflowState = data.mergeableWorkflowState ?? undefined;
    this._reviewWorkflowState = data.reviewWorkflowState ?? undefined;
    this._startWorkflowState = data.startWorkflowState ?? undefined;
    this._triageIssueState = data.triageIssueState ?? undefined;
    this._triageResponsibility = data.triageResponsibility ?? undefined;
  }

  /** Whether to enable resolved thread AI summaries. */
  public aiThreadSummariesEnabled: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Period after which automatically closed and completed issues are automatically archived in months. */
  public autoArchivePeriod: number;
  /** Whether child issues should automatically close when their parent issue is closed */
  public autoCloseChildIssues?: boolean;
  /** Whether parent issues should automatically close when all child issues are closed */
  public autoCloseParentIssues?: boolean;
  /** Period after which issues are automatically closed in months. Null/undefined means disabled. */
  public autoClosePeriod?: number;
  /** The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state. */
  public autoCloseStateId?: string;
  /** The team's color. */
  public color?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Calendar feed URL (iCal) for cycles. */
  public cycleCalenderUrl: string;
  /** The cooldown time after each cycle in weeks. */
  public cycleCooldownTime: number;
  /** The duration of a cycle in weeks. */
  public cycleDuration: number;
  /** Auto assign completed issues to current cycle. */
  public cycleIssueAutoAssignCompleted: boolean;
  /** Auto assign started issues to current cycle. */
  public cycleIssueAutoAssignStarted: boolean;
  /** Auto assign issues to current cycle if in active status. */
  public cycleLockToActive: boolean;
  /** The day of the week that a new cycle starts. */
  public cycleStartDay: number;
  /** Whether the team uses cycles. */
  public cyclesEnabled: boolean;
  /** What to use as a default estimate for unestimated issues. */
  public defaultIssueEstimate: number;
  /** The id of the default template to use for new issues created by members of the team. */
  public defaultTemplateForMembersId?: string;
  /** The id of the default template to use for new issues created by non-members of the team. */
  public defaultTemplateForNonMembersId?: string;
  /** The team's description. */
  public description?: string;
  /** The name of the team including it's parent team name if it has one. */
  public displayName: string;
  /** Whether to group recent issue history entries. */
  public groupIssueHistory: boolean;
  /** The icon of the team. */
  public icon?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the team should inherit its estimation settings from its parent. Only applies to sub-teams. */
  public inheritIssueEstimation: boolean;
  /** Whether the team should inherit its workflow statuses from its parent. Only applies to sub-teams. */
  public inheritWorkflowStatuses: boolean;
  /** Unique hash for the team to be used in invite URLs. */
  public inviteHash: string;
  /** Number of issues in the team. */
  public issueCount: number;
  /** Whether to allow zeros in issues estimates. */
  public issueEstimationAllowZero: boolean;
  /** Whether to add additional points to the estimate scale. */
  public issueEstimationExtended: boolean;
  /** The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt". */
  public issueEstimationType: string;
  /** [DEPRECATED] Whether issues without priority should be sorted first. */
  public issueOrderingNoPriorityFirst: boolean;
  /** [DEPRECATED] Whether to move issues to bottom of the column when changing state. */
  public issueSortOrderDefaultToBottom: boolean;
  /** The team's unique key. The key is used in URLs. */
  public key: string;
  /** The team's name. */
  public name: string;
  /** Whether the team is private or not. */
  public private: boolean;
  /** Whether an issue needs to have a priority set before leaving triage. */
  public requirePriorityToLeaveTriage: boolean;
  /** The SCIM group name for the team. */
  public scimGroupName?: string;
  /** Whether the team is managed by SCIM integration. */
  public scimManaged: boolean;
  /** Where to move issues when changing state. */
  public setIssueSortOrderOnStateChange: string;
  /** Whether to send new issue comment notifications to Slack. */
  public slackIssueComments: boolean;
  /** Whether to send new issue status updates to Slack. */
  public slackIssueStatuses: boolean;
  /** Whether to send new issue notifications to Slack. */
  public slackNewIssue: boolean;
  /** The timezone of the team. Defaults to "America/Los_Angeles" */
  public timezone: string;
  /** Whether triage mode is enabled for the team or not. */
  public triageEnabled: boolean;
  /** How many upcoming cycles to create. */
  public upcomingCycleCount: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Team's currently active cycle. */
  public get activeCycle(): LinearFetch<Cycle> | undefined {
    return this._activeCycle?.id ? new CycleQuery(this._request).fetch(this._activeCycle?.id) : undefined;
  }
  /** The ID of team's currently active cycle. */
  public get activeCycleId(): string | undefined {
    return this._activeCycle?.id;
  }
  /** The default workflow state into which issues are set when they are opened by team members. */
  public get defaultIssueState(): LinearFetch<WorkflowState> | undefined {
    return this._defaultIssueState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._defaultIssueState?.id)
      : undefined;
  }
  /** The ID of default workflow state into which issues are set when they are opened by team members. */
  public get defaultIssueStateId(): string | undefined {
    return this._defaultIssueState?.id;
  }
  /** The default template to use for new projects created for the team. */
  public get defaultProjectTemplate(): LinearFetch<Template> | undefined {
    return this._defaultProjectTemplate?.id
      ? new TemplateQuery(this._request).fetch(this._defaultProjectTemplate?.id)
      : undefined;
  }
  /** The ID of default template to use for new projects created for the team. */
  public get defaultProjectTemplateId(): string | undefined {
    return this._defaultProjectTemplate?.id;
  }
  /** The default template to use for new issues created by members of the team. */
  public get defaultTemplateForMembers(): LinearFetch<Template> | undefined {
    return this._defaultTemplateForMembers?.id
      ? new TemplateQuery(this._request).fetch(this._defaultTemplateForMembers?.id)
      : undefined;
  }
  /** The default template to use for new issues created by non-members of the team. */
  public get defaultTemplateForNonMembers(): LinearFetch<Template> | undefined {
    return this._defaultTemplateForNonMembers?.id
      ? new TemplateQuery(this._request).fetch(this._defaultTemplateForNonMembers?.id)
      : undefined;
  }
  /** The workflow state into which issues are moved when a PR has been opened as draft. */
  public get draftWorkflowState(): LinearFetch<WorkflowState> | undefined {
    return this._draftWorkflowState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._draftWorkflowState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are moved when a pr has been opened as draft. */
  public get draftWorkflowStateId(): string | undefined {
    return this._draftWorkflowState?.id;
  }
  /** Settings for all integrations associated with that team. */
  public get integrationsSettings(): LinearFetch<IntegrationsSettings> | undefined {
    return this._integrationsSettings?.id
      ? new IntegrationsSettingsQuery(this._request).fetch(this._integrationsSettings?.id)
      : undefined;
  }
  /** The ID of settings for all integrations associated with that team. */
  public get integrationsSettingsId(): string | undefined {
    return this._integrationsSettings?.id;
  }
  /** The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state. */
  public get markedAsDuplicateWorkflowState(): LinearFetch<WorkflowState> | undefined {
    return this._markedAsDuplicateWorkflowState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._markedAsDuplicateWorkflowState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are moved when they are marked as a duplicate of another issue. defaults to the first canceled state. */
  public get markedAsDuplicateWorkflowStateId(): string | undefined {
    return this._markedAsDuplicateWorkflowState?.id;
  }
  /** The workflow state into which issues are moved when a PR has been merged. */
  public get mergeWorkflowState(): LinearFetch<WorkflowState> | undefined {
    return this._mergeWorkflowState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._mergeWorkflowState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are moved when a pr has been merged. */
  public get mergeWorkflowStateId(): string | undefined {
    return this._mergeWorkflowState?.id;
  }
  /** The workflow state into which issues are moved when a PR is ready to be merged. */
  public get mergeableWorkflowState(): LinearFetch<WorkflowState> | undefined {
    return this._mergeableWorkflowState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._mergeableWorkflowState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are moved when a pr is ready to be merged. */
  public get mergeableWorkflowStateId(): string | undefined {
    return this._mergeableWorkflowState?.id;
  }
  /** The organization that the team is associated with. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The workflow state into which issues are moved when a review has been requested for the PR. */
  public get reviewWorkflowState(): LinearFetch<WorkflowState> | undefined {
    return this._reviewWorkflowState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._reviewWorkflowState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are moved when a review has been requested for the pr. */
  public get reviewWorkflowStateId(): string | undefined {
    return this._reviewWorkflowState?.id;
  }
  /** The workflow state into which issues are moved when a PR has been opened. */
  public get startWorkflowState(): LinearFetch<WorkflowState> | undefined {
    return this._startWorkflowState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._startWorkflowState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are moved when a pr has been opened. */
  public get startWorkflowStateId(): string | undefined {
    return this._startWorkflowState?.id;
  }
  /** The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled. */
  public get triageIssueState(): LinearFetch<WorkflowState> | undefined {
    return this._triageIssueState?.id
      ? new WorkflowStateQuery(this._request).fetch(this._triageIssueState?.id)
      : undefined;
  }
  /** The ID of workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled. */
  public get triageIssueStateId(): string | undefined {
    return this._triageIssueState?.id;
  }
  /** Team's triage responsibility. */
  public get triageResponsibility(): LinearFetch<TriageResponsibility> | undefined {
    return this._triageResponsibility?.id
      ? new TriageResponsibilityQuery(this._request).fetch(this._triageResponsibility?.id)
      : undefined;
  }
  /** The ID of team's triage responsibility. */
  public get triageResponsibilityId(): string | undefined {
    return this._triageResponsibility?.id;
  }
  /** Cycles associated with the team. */
  public cycles(variables?: Omit<L.Team_CyclesQueryVariables, "id">) {
    return new Team_CyclesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** The Git automation states for the team. */
  public gitAutomationStates(variables?: Omit<L.Team_GitAutomationStatesQueryVariables, "id">) {
    return new Team_GitAutomationStatesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Issues associated with the team. */
  public issues(variables?: Omit<L.Team_IssuesQueryVariables, "id">) {
    return new Team_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Labels associated with the team. */
  public labels(variables?: Omit<L.Team_LabelsQueryVariables, "id">) {
    return new Team_LabelsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Users who are members of this team. */
  public members(variables?: Omit<L.Team_MembersQueryVariables, "id">) {
    return new Team_MembersQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Memberships associated with the team. For easier access of the same data, use `members` query. */
  public memberships(variables?: Omit<L.Team_MembershipsQueryVariables, "id">) {
    return new Team_MembershipsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Projects associated with the team. */
  public projects(variables?: Omit<L.Team_ProjectsQueryVariables, "id">) {
    return new Team_ProjectsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** The states that define the workflow associated with the team. */
  public states(variables?: Omit<L.Team_StatesQueryVariables, "id">) {
    return new Team_StatesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Templates associated with the team. */
  public templates(variables?: Omit<L.Team_TemplatesQueryVariables, "id">) {
    return new Team_TemplatesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Webhooks associated with the team. */
  public webhooks(variables?: Omit<L.Team_WebhooksQueryVariables, "id">) {
    return new Team_WebhooksQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Creates a new team. The user who creates the team will automatically be added as a member to the newly created team. */
  public create(input: L.TeamCreateInput, variables?: Omit<L.CreateTeamMutationVariables, "input">) {
    return new CreateTeamMutation(this._request).fetch(input, variables);
  }
  /** Deletes a team. */
  public delete() {
    return new DeleteTeamMutation(this._request).fetch(this.id);
  }
  /** Unarchives a team and cancels deletion. */
  public unarchive() {
    return new UnarchiveTeamMutation(this._request).fetch(this.id);
  }
  /** Updates a team. */
  public update(input: L.TeamUpdateInput, variables?: Omit<L.UpdateTeamMutationVariables, "id" | "input">) {
    return new UpdateTeamMutation(this._request).fetch(this.id, input, variables);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamArchivePayloadFragment response data
 */
export class TeamArchivePayload extends Request {
  private _entity?: L.TeamArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.TeamArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<Team> | undefined {
    return this._entity?.id ? new TeamQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a team.
 *
 * @param data - L.TeamChildWebhookPayloadFragment response data
 */
export class TeamChildWebhookPayload {
  public constructor(data: L.TeamChildWebhookPayloadFragment) {
    this.id = data.id;
    this.key = data.key;
    this.name = data.name;
  }

  /** The ID of the team. */
  public id: string;
  /** The key of the team. */
  public key: string;
  /** The name of the team. */
  public name: string;
}
/**
 * TeamConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TeamConnection model
 * @param data - TeamConnection response data
 */
export class TeamConnection extends Connection<Team> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Team> | undefined>,
    data: L.TeamConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Team(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Defines the membership of a user to a team.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamMembershipFragment response data
 */
export class TeamMembership extends Request {
  private _team: L.TeamMembershipFragment["team"];
  private _user: L.TeamMembershipFragment["user"];

  public constructor(request: LinearRequest, data: L.TeamMembershipFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.owner = data.owner;
    this.sortOrder = data.sortOrder;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._team = data.team;
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether the user is the owner of the team. */
  public owner: boolean;
  /** The order of the item in the users team list. */
  public sortOrder: number;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The team that the membership is associated with. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team that the membership is associated with. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user that the membership is associated with. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user that the membership is associated with. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Creates a new team membership. */
  public create(input: L.TeamMembershipCreateInput) {
    return new CreateTeamMembershipMutation(this._request).fetch(input);
  }
  /** Deletes a team membership. */
  public delete(variables?: Omit<L.DeleteTeamMembershipMutationVariables, "id">) {
    return new DeleteTeamMembershipMutation(this._request).fetch(this.id, variables);
  }
  /** Updates a team membership. */
  public update(input: L.TeamMembershipUpdateInput) {
    return new UpdateTeamMembershipMutation(this._request).fetch(this.id, input);
  }
}
/**
 * TeamMembershipConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TeamMembershipConnection model
 * @param data - TeamMembershipConnection response data
 */
export class TeamMembershipConnection extends Connection<TeamMembership> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<TeamMembership> | undefined>,
    data: L.TeamMembershipConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new TeamMembership(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * TeamMembershipPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamMembershipPayloadFragment response data
 */
export class TeamMembershipPayload extends Request {
  private _teamMembership?: L.TeamMembershipPayloadFragment["teamMembership"];

  public constructor(request: LinearRequest, data: L.TeamMembershipPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._teamMembership = data.teamMembership ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The team membership that was created or updated. */
  public get teamMembership(): LinearFetch<TeamMembership> | undefined {
    return this._teamMembership?.id
      ? new TeamMembershipQuery(this._request).fetch(this._teamMembership?.id)
      : undefined;
  }
  /** The ID of team membership that was created or updated. */
  public get teamMembershipId(): string | undefined {
    return this._teamMembership?.id;
  }
}
/**
 * A team notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamNotificationSubscriptionFragment response data
 */
export class TeamNotificationSubscription extends Request {
  private _customView?: L.TeamNotificationSubscriptionFragment["customView"];
  private _customer?: L.TeamNotificationSubscriptionFragment["customer"];
  private _cycle?: L.TeamNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.TeamNotificationSubscriptionFragment["initiative"];
  private _label?: L.TeamNotificationSubscriptionFragment["label"];
  private _project?: L.TeamNotificationSubscriptionFragment["project"];
  private _subscriber: L.TeamNotificationSubscriptionFragment["subscriber"];
  private _team: L.TeamNotificationSubscriptionFragment["team"];
  private _user?: L.TeamNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.TeamNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team;
    this._user = data.user ?? undefined;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team subscribed to. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team subscribed to. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user view associated with the notification subscription. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user view associated with the notification subscription. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * TeamPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TeamPayloadFragment response data
 */
export class TeamPayload extends Request {
  private _team?: L.TeamPayloadFragment["team"];

  public constructor(request: LinearRequest, data: L.TeamPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._team = data.team ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The team that was created or updated. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team that was created or updated. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
}
/**
 * A template object used for creating entities faster.
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplateFragment response data
 */
export class Template extends Request {
  private _creator?: L.TemplateFragment["creator"];
  private _inheritedFrom?: L.TemplateFragment["inheritedFrom"];
  private _lastUpdatedBy?: L.TemplateFragment["lastUpdatedBy"];
  private _team?: L.TemplateFragment["team"];

  public constructor(request: LinearRequest, data: L.TemplateFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.sortOrder = data.sortOrder;
    this.templateData = parseJson(data.templateData) ?? {};
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._creator = data.creator ?? undefined;
    this._inheritedFrom = data.inheritedFrom ?? undefined;
    this._lastUpdatedBy = data.lastUpdatedBy ?? undefined;
    this._team = data.team ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Template description. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the template. */
  public name: string;
  /** The sort order of the template. */
  public sortOrder: number;
  /** Template data. */
  public templateData: Record<string, unknown>;
  /** The entity type this template is for. */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user who created the template. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the template. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The original template inherited from. */
  public get inheritedFrom(): LinearFetch<Template> | undefined {
    return this._inheritedFrom?.id ? new TemplateQuery(this._request).fetch(this._inheritedFrom?.id) : undefined;
  }
  /** The ID of original template inherited from. */
  public get inheritedFromId(): string | undefined {
    return this._inheritedFrom?.id;
  }
  /** The user who last updated the template. */
  public get lastUpdatedBy(): LinearFetch<User> | undefined {
    return this._lastUpdatedBy?.id ? new UserQuery(this._request).fetch(this._lastUpdatedBy?.id) : undefined;
  }
  /** The ID of user who last updated the template. */
  public get lastUpdatedById(): string | undefined {
    return this._lastUpdatedBy?.id;
  }
  /** The organization that the template is associated with. If null, the template is associated with a particular team. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** The team that the template is associated with. If null, the template is global to the workspace. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team that the template is associated with. if null, the template is global to the workspace. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }

  /** Creates a new template. */
  public create(input: L.TemplateCreateInput) {
    return new CreateTemplateMutation(this._request).fetch(input);
  }
  /** Deletes a template. */
  public delete() {
    return new DeleteTemplateMutation(this._request).fetch(this.id);
  }
  /** Updates an existing template. */
  public update(input: L.TemplateUpdateInput) {
    return new UpdateTemplateMutation(this._request).fetch(this.id, input);
  }
}
/**
 * TemplateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TemplateConnection model
 * @param data - TemplateConnection response data
 */
export class TemplateConnection extends Connection<Template> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Template> | undefined>,
    data: L.TemplateConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Template(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * TemplatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TemplatePayloadFragment response data
 */
export class TemplatePayload extends Request {
  private _template: L.TemplatePayloadFragment["template"];

  public constructor(request: LinearRequest, data: L.TemplatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._template = data.template;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The template that was created or updated. */
  public get template(): LinearFetch<Template> | undefined {
    return new TemplateQuery(this._request).fetch(this._template.id);
  }
  /** The ID of template that was created or updated. */
  public get templateId(): string | undefined {
    return this._template?.id;
  }
}
/**
 * A time schedule.
 *
 * @param request - function to call the graphql client
 * @param data - L.TimeScheduleFragment response data
 */
export class TimeSchedule extends Request {
  private _integration?: L.TimeScheduleFragment["integration"];

  public constructor(request: LinearRequest, data: L.TimeScheduleFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.externalId = data.externalId ?? undefined;
    this.externalUrl = data.externalUrl ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.entries = data.entries ? data.entries.map(node => new TimeScheduleEntry(request, node)) : undefined;
    this._integration = data.integration ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The identifier of the external schedule. */
  public externalId?: string;
  /** The URL to the external schedule. */
  public externalUrl?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The name of the schedule. */
  public name: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The schedule entries. */
  public entries?: TimeScheduleEntry[];
  /** The identifier of the Linear integration populating the schedule. */
  public get integration(): LinearFetch<Integration> | undefined {
    return this._integration?.id ? new IntegrationQuery(this._request).fetch(this._integration?.id) : undefined;
  }
  /** The ID of identifier of the linear integration populating the schedule. */
  public get integrationId(): string | undefined {
    return this._integration?.id;
  }
  /** The organization of the schedule. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }

  /** Creates a new time schedule. */
  public create(input: L.TimeScheduleCreateInput) {
    return new CreateTimeScheduleMutation(this._request).fetch(input);
  }
  /** Deletes a time schedule. */
  public delete() {
    return new DeleteTimeScheduleMutation(this._request).fetch(this.id);
  }
  /** Updates a time schedule. */
  public update(input: L.TimeScheduleUpdateInput) {
    return new UpdateTimeScheduleMutation(this._request).fetch(this.id, input);
  }
}
/**
 * TimeScheduleConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TimeScheduleConnection model
 * @param data - TimeScheduleConnection response data
 */
export class TimeScheduleConnection extends Connection<TimeSchedule> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<TimeSchedule> | undefined>,
    data: L.TimeScheduleConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new TimeSchedule(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * TimeScheduleEntry model
 *
 * @param request - function to call the graphql client
 * @param data - L.TimeScheduleEntryFragment response data
 */
export class TimeScheduleEntry extends Request {
  public constructor(request: LinearRequest, data: L.TimeScheduleEntryFragment) {
    super(request);
    this.endsAt = parseDate(data.endsAt) ?? new Date();
    this.startsAt = parseDate(data.startsAt) ?? new Date();
    this.userEmail = data.userEmail ?? undefined;
    this.userId = data.userId ?? undefined;
  }

  /** The end date of the schedule in ISO 8601 date-time format. */
  public endsAt: Date;
  /** The start date of the schedule in ISO 8601 date-time format. */
  public startsAt: Date;
  /** The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id. */
  public userEmail?: string;
  /** The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference. */
  public userId?: string;
}
/**
 * TimeSchedulePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TimeSchedulePayloadFragment response data
 */
export class TimeSchedulePayload extends Request {
  private _timeSchedule: L.TimeSchedulePayloadFragment["timeSchedule"];

  public constructor(request: LinearRequest, data: L.TimeSchedulePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._timeSchedule = data.timeSchedule;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  public get timeSchedule(): LinearFetch<TimeSchedule> | undefined {
    return new TimeScheduleQuery(this._request).fetch(this._timeSchedule.id);
  }
  /** The ID of timeSchedule */
  public get timeScheduleId(): string | undefined {
    return this._timeSchedule?.id;
  }
}
/**
 * A team's triage responsibility.
 *
 * @param request - function to call the graphql client
 * @param data - L.TriageResponsibilityFragment response data
 */
export class TriageResponsibility extends Request {
  private _currentUser?: L.TriageResponsibilityFragment["currentUser"];
  private _team: L.TriageResponsibilityFragment["team"];
  private _timeSchedule?: L.TriageResponsibilityFragment["timeSchedule"];

  public constructor(request: LinearRequest, data: L.TriageResponsibilityFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.manualSelection = data.manualSelection
      ? new TriageResponsibilityManualSelection(request, data.manualSelection)
      : undefined;
    this.action = data.action;
    this._currentUser = data.currentUser ?? undefined;
    this._team = data.team;
    this._timeSchedule = data.timeSchedule ?? undefined;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Set of users used for triage responsibility. */
  public manualSelection?: TriageResponsibilityManualSelection;
  /** The action to take when an issue is added to triage. */
  public action: L.TriageResponsibilityAction;
  /** The user currently responsible for triage. */
  public get currentUser(): LinearFetch<User> | undefined {
    return this._currentUser?.id ? new UserQuery(this._request).fetch(this._currentUser?.id) : undefined;
  }
  /** The ID of user currently responsible for triage. */
  public get currentUserId(): string | undefined {
    return this._currentUser?.id;
  }
  /** The team to which the triage responsibility belongs to. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team to which the triage responsibility belongs to. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The time schedule used for scheduling. */
  public get timeSchedule(): LinearFetch<TimeSchedule> | undefined {
    return this._timeSchedule?.id ? new TimeScheduleQuery(this._request).fetch(this._timeSchedule?.id) : undefined;
  }
  /** The ID of time schedule used for scheduling. */
  public get timeScheduleId(): string | undefined {
    return this._timeSchedule?.id;
  }

  /** Creates a new triage responsibility. */
  public create(input: L.TriageResponsibilityCreateInput) {
    return new CreateTriageResponsibilityMutation(this._request).fetch(input);
  }
  /** Deletes a triage responsibility. */
  public delete() {
    return new DeleteTriageResponsibilityMutation(this._request).fetch(this.id);
  }
  /** Updates an existing triage responsibility. */
  public update(input: L.TriageResponsibilityUpdateInput) {
    return new UpdateTriageResponsibilityMutation(this._request).fetch(this.id, input);
  }
}
/**
 * TriageResponsibilityConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this TriageResponsibilityConnection model
 * @param data - TriageResponsibilityConnection response data
 */
export class TriageResponsibilityConnection extends Connection<TriageResponsibility> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<TriageResponsibility> | undefined>,
    data: L.TriageResponsibilityConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new TriageResponsibility(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * TriageResponsibilityManualSelection model
 *
 * @param request - function to call the graphql client
 * @param data - L.TriageResponsibilityManualSelectionFragment response data
 */
export class TriageResponsibilityManualSelection extends Request {
  public constructor(request: LinearRequest, data: L.TriageResponsibilityManualSelectionFragment) {
    super(request);
    this.userIds = data.userIds;
  }

  /** The set of users responsible for triage. */
  public userIds: string[];
}
/**
 * TriageResponsibilityPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.TriageResponsibilityPayloadFragment response data
 */
export class TriageResponsibilityPayload extends Request {
  private _triageResponsibility: L.TriageResponsibilityPayloadFragment["triageResponsibility"];

  public constructor(request: LinearRequest, data: L.TriageResponsibilityPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._triageResponsibility = data.triageResponsibility;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  public get triageResponsibility(): LinearFetch<TriageResponsibility> | undefined {
    return new TriageResponsibilityQuery(this._request).fetch(this._triageResponsibility.id);
  }
  /** The ID of triageResponsibility */
  public get triageResponsibilityId(): string | undefined {
    return this._triageResponsibility?.id;
  }
}
/**
 * Object representing Google Cloud upload policy, plus additional data.
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadFileFragment response data
 */
export class UploadFile extends Request {
  public constructor(request: LinearRequest, data: L.UploadFileFragment) {
    super(request);
    this.assetUrl = data.assetUrl;
    this.contentType = data.contentType;
    this.filename = data.filename;
    this.metaData = data.metaData ?? undefined;
    this.size = data.size;
    this.uploadUrl = data.uploadUrl;
    this.headers = data.headers.map(node => new UploadFileHeader(request, node));
  }

  /** The asset URL for the uploaded file. (assigned automatically). */
  public assetUrl: string;
  /** The content type. */
  public contentType: string;
  /** The filename. */
  public filename: string;
  public metaData?: L.Scalars["JSONObject"];
  /** The size of the uploaded file. */
  public size: number;
  /** The signed URL the for the uploaded file. (assigned automatically). */
  public uploadUrl: string;
  public headers: UploadFileHeader[];
}
/**
 * UploadFileHeader model
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadFileHeaderFragment response data
 */
export class UploadFileHeader extends Request {
  public constructor(request: LinearRequest, data: L.UploadFileHeaderFragment) {
    super(request);
    this.key = data.key;
    this.value = data.value;
  }

  /** Upload file header key. */
  public key: string;
  /** Upload file header value. */
  public value: string;
}
/**
 * UploadPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UploadPayloadFragment response data
 */
export class UploadPayload extends Request {
  public constructor(request: LinearRequest, data: L.UploadPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.uploadFile = data.uploadFile ? new UploadFile(request, data.uploadFile) : undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** Object describing the file to be uploaded. */
  public uploadFile?: UploadFile;
}
/**
 * A user that has access to the the resources of an organization.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserFragment response data
 */
export class User extends Request {
  public constructor(request: LinearRequest, data: L.UserFragment) {
    super(request);
    this.active = data.active;
    this.admin = data.admin;
    this.app = data.app;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.avatarBackgroundColor = data.avatarBackgroundColor;
    this.avatarUrl = data.avatarUrl ?? undefined;
    this.calendarHash = data.calendarHash ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.createdIssueCount = data.createdIssueCount;
    this.description = data.description ?? undefined;
    this.disableReason = data.disableReason ?? undefined;
    this.displayName = data.displayName;
    this.email = data.email;
    this.gitHubUserId = data.gitHubUserId ?? undefined;
    this.guest = data.guest;
    this.id = data.id;
    this.initials = data.initials;
    this.inviteHash = data.inviteHash;
    this.isMe = data.isMe;
    this.lastSeen = parseDate(data.lastSeen) ?? undefined;
    this.name = data.name;
    this.statusEmoji = data.statusEmoji ?? undefined;
    this.statusLabel = data.statusLabel ?? undefined;
    this.statusUntilAt = parseDate(data.statusUntilAt) ?? undefined;
    this.timezone = data.timezone ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url;
  }

  /** Whether the user account is active or disabled (suspended). */
  public active: boolean;
  /** Whether the user is an organization administrator. */
  public admin: boolean;
  /** Whether the user is an app. */
  public app: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The background color of the avatar for users without set avatar. */
  public avatarBackgroundColor: string;
  /** An URL to the user's avatar image. */
  public avatarUrl?: string;
  /** [DEPRECATED] Hash for the user to be used in calendar URLs. */
  public calendarHash?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Number of issues created. */
  public createdIssueCount: number;
  /** A short description of the user, either its title or bio. */
  public description?: string;
  /** Reason why is the account disabled. */
  public disableReason?: string;
  /** The user's display (nick) name. Unique within each organization. */
  public displayName: string;
  /** The user's email address. */
  public email: string;
  /** The user's GitHub user ID. */
  public gitHubUserId?: string;
  /** Whether the user is a guest in the workspace and limited to accessing a subset of teams. */
  public guest: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** The initials of the user. */
  public initials: string;
  /** [DEPRECATED] Unique hash for the user to be used in invite URLs. */
  public inviteHash: string;
  /** Whether the user is the currently authenticated user. */
  public isMe: boolean;
  /** The last time the user was seen online. */
  public lastSeen?: Date;
  /** The user's full name. */
  public name: string;
  /** The emoji to represent the user current status. */
  public statusEmoji?: string;
  /** The label of the user current status. */
  public statusLabel?: string;
  /** A date at which the user current status should be cleared. */
  public statusUntilAt?: Date;
  /** The local timezone of the user. */
  public timezone?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** User's profile URL. */
  public url: string;
  /** Organization the user belongs to. */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /** Issues assigned to the user. */
  public assignedIssues(variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">) {
    return new User_AssignedIssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Issues created by the user. */
  public createdIssues(variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">) {
    return new User_CreatedIssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Issues delegated to this user. */
  public delegatedIssues(variables?: Omit<L.User_DelegatedIssuesQueryVariables, "id">) {
    return new User_DelegatedIssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** The user's drafts */
  public drafts(variables?: Omit<L.User_DraftsQueryVariables, "id">) {
    return new User_DraftsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Memberships associated with the user. For easier access of the same data, use `teams` query. */
  public teamMemberships(variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">) {
    return new User_TeamMembershipsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Teams the user is part of. */
  public teams(variables?: Omit<L.User_TeamsQueryVariables, "id">) {
    return new User_TeamsQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Suspends a user. Can only be called by an admin. */
  public suspend() {
    return new SuspendUserMutation(this._request).fetch(this.id);
  }
  /** Un-suspends a user. Can only be called by an admin. */
  public unsuspend() {
    return new UnsuspendUserMutation(this._request).fetch(this.id);
  }
  /** Updates a user. Only available to organization admins and the user themselves. */
  public update(input: L.UserUpdateInput) {
    return new UpdateUserMutation(this._request).fetch(this.id, input);
  }
}
/**
 * UserAdminPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAdminPayloadFragment response data
 */
export class UserAdminPayload extends Request {
  public constructor(request: LinearRequest, data: L.UserAdminPayloadFragment) {
    super(request);
    this.success = data.success;
  }

  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * Public information of the OAuth application, plus whether the application has been authorized for the given scopes.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserAuthorizedApplicationFragment response data
 */
export class UserAuthorizedApplication extends Request {
  public constructor(request: LinearRequest, data: L.UserAuthorizedApplicationFragment) {
    super(request);
    this.approvalErrorCode = data.approvalErrorCode ?? undefined;
    this.clientId = data.clientId;
    this.createdByLinear = data.createdByLinear;
    this.description = data.description ?? undefined;
    this.developer = data.developer;
    this.developerUrl = data.developerUrl;
    this.id = data.id;
    this.imageUrl = data.imageUrl ?? undefined;
    this.isAuthorized = data.isAuthorized;
    this.name = data.name;
    this.webhooksEnabled = data.webhooksEnabled;
  }

  /** Error associated with the application needing to be requested for approval in the workspace. */
  public approvalErrorCode?: string;
  /** OAuth application's client ID. */
  public clientId: string;
  /** Whether the application was created by Linear. */
  public createdByLinear: boolean;
  /** Information about the application. */
  public description?: string;
  /** Name of the developer. */
  public developer: string;
  /** Url of the developer (homepage or docs). */
  public developerUrl: string;
  /** OAuth application's ID. */
  public id: string;
  /** Image of the application. */
  public imageUrl?: string;
  /** Whether the user has authorized the application for the given scopes. */
  public isAuthorized: boolean;
  /** Application name. */
  public name: string;
  /** Whether or not webhooks are enabled for the application. */
  public webhooksEnabled: boolean;
}
/**
 * Certain properties of a user.
 *
 * @param data - L.UserChildWebhookPayloadFragment response data
 */
export class UserChildWebhookPayload {
  public constructor(data: L.UserChildWebhookPayloadFragment) {
    this.avatarUrl = data.avatarUrl ?? undefined;
    this.email = data.email;
    this.id = data.id;
    this.name = data.name;
    this.url = data.url;
  }

  /** The avatar URL of the user. */
  public avatarUrl?: string;
  /** The email of the user. */
  public email: string;
  /** The ID of the user. */
  public id: string;
  /** The name of the user. */
  public name: string;
  /** The URL of the user. */
  public url: string;
}
/**
 * UserConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this UserConnection model
 * @param data - UserConnection response data
 */
export class UserConnection extends Connection<User> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<User> | undefined>,
    data: L.UserConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new User(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * A user notification subscription.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserNotificationSubscriptionFragment response data
 */
export class UserNotificationSubscription extends Request {
  private _customView?: L.UserNotificationSubscriptionFragment["customView"];
  private _customer?: L.UserNotificationSubscriptionFragment["customer"];
  private _cycle?: L.UserNotificationSubscriptionFragment["cycle"];
  private _initiative?: L.UserNotificationSubscriptionFragment["initiative"];
  private _label?: L.UserNotificationSubscriptionFragment["label"];
  private _project?: L.UserNotificationSubscriptionFragment["project"];
  private _subscriber: L.UserNotificationSubscriptionFragment["subscriber"];
  private _team?: L.UserNotificationSubscriptionFragment["team"];
  private _user: L.UserNotificationSubscriptionFragment["user"];

  public constructor(request: LinearRequest, data: L.UserNotificationSubscriptionFragment) {
    super(request);
    this.active = data.active;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.notificationSubscriptionTypes = data.notificationSubscriptionTypes;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.contextViewType = data.contextViewType ?? undefined;
    this.userContextViewType = data.userContextViewType ?? undefined;
    this._customView = data.customView ?? undefined;
    this._customer = data.customer ?? undefined;
    this._cycle = data.cycle ?? undefined;
    this._initiative = data.initiative ?? undefined;
    this._label = data.label ?? undefined;
    this._project = data.project ?? undefined;
    this._subscriber = data.subscriber;
    this._team = data.team ?? undefined;
    this._user = data.user;
  }

  /** Whether the subscription is active or not. */
  public active: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The type of subscription. */
  public notificationSubscriptionTypes: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The type of view to which the notification subscription context is associated with. */
  public contextViewType?: L.ContextViewType;
  /** The type of user view to which the notification subscription context is associated with. */
  public userContextViewType?: L.UserContextViewType;
  /** The contextual custom view associated with the notification subscription. */
  public get customView(): LinearFetch<CustomView> | undefined {
    return this._customView?.id ? new CustomViewQuery(this._request).fetch(this._customView?.id) : undefined;
  }
  /** The ID of contextual custom view associated with the notification subscription. */
  public get customViewId(): string | undefined {
    return this._customView?.id;
  }
  /** The customer associated with the notification subscription. */
  public get customer(): LinearFetch<Customer> | undefined {
    return this._customer?.id ? new CustomerQuery(this._request).fetch(this._customer?.id) : undefined;
  }
  /** The ID of customer associated with the notification subscription. */
  public get customerId(): string | undefined {
    return this._customer?.id;
  }
  /** The contextual cycle view associated with the notification subscription. */
  public get cycle(): LinearFetch<Cycle> | undefined {
    return this._cycle?.id ? new CycleQuery(this._request).fetch(this._cycle?.id) : undefined;
  }
  /** The ID of contextual cycle view associated with the notification subscription. */
  public get cycleId(): string | undefined {
    return this._cycle?.id;
  }
  /** The contextual initiative view associated with the notification subscription. */
  public get initiative(): LinearFetch<Initiative> | undefined {
    return this._initiative?.id ? new InitiativeQuery(this._request).fetch(this._initiative?.id) : undefined;
  }
  /** The ID of contextual initiative view associated with the notification subscription. */
  public get initiativeId(): string | undefined {
    return this._initiative?.id;
  }
  /** The contextual label view associated with the notification subscription. */
  public get label(): LinearFetch<IssueLabel> | undefined {
    return this._label?.id ? new IssueLabelQuery(this._request).fetch(this._label?.id) : undefined;
  }
  /** The ID of contextual label view associated with the notification subscription. */
  public get labelId(): string | undefined {
    return this._label?.id;
  }
  /** The contextual project view associated with the notification subscription. */
  public get project(): LinearFetch<Project> | undefined {
    return this._project?.id ? new ProjectQuery(this._request).fetch(this._project?.id) : undefined;
  }
  /** The ID of contextual project view associated with the notification subscription. */
  public get projectId(): string | undefined {
    return this._project?.id;
  }
  /** The user that subscribed to receive notifications. */
  public get subscriber(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._subscriber.id);
  }
  /** The ID of user that subscribed to receive notifications. */
  public get subscriberId(): string | undefined {
    return this._subscriber?.id;
  }
  /** The team associated with the notification subscription. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team associated with the notification subscription. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** The user subscribed to. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user subscribed to. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * UserPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserPayloadFragment response data
 */
export class UserPayload extends Request {
  private _user?: L.UserPayloadFragment["user"];

  public constructor(request: LinearRequest, data: L.UserPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._user = data.user ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The user that was created or updated. */
  public get user(): LinearFetch<User> | undefined {
    return this._user?.id ? new UserQuery(this._request).fetch(this._user?.id) : undefined;
  }
  /** The ID of user that was created or updated. */
  public get userId(): string | undefined {
    return this._user?.id;
  }
}
/**
 * The settings of a user as a JSON object.
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFragment response data
 */
export class UserSettings extends Request {
  private _user: L.UserSettingsFragment["user"];

  public constructor(request: LinearRequest, data: L.UserSettingsFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.autoAssignToSelf = data.autoAssignToSelf;
    this.calendarHash = data.calendarHash ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.showFullUserNames = data.showFullUserNames;
    this.subscribedToChangelog = data.subscribedToChangelog;
    this.subscribedToDPA = data.subscribedToDPA;
    this.subscribedToInviteAccepted = data.subscribedToInviteAccepted;
    this.subscribedToPrivacyLegalUpdates = data.subscribedToPrivacyLegalUpdates;
    this.unsubscribedFrom = data.unsubscribedFrom;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.notificationCategoryPreferences = new NotificationCategoryPreferences(
      request,
      data.notificationCategoryPreferences
    );
    this.notificationChannelPreferences = new NotificationChannelPreferences(
      request,
      data.notificationChannelPreferences
    );
    this.notificationDeliveryPreferences = new NotificationDeliveryPreferences(
      request,
      data.notificationDeliveryPreferences
    );
    this._user = data.user;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** Whether to auto-assign newly created issues to the current user by default. */
  public autoAssignToSelf: boolean;
  /** Hash for the user to be used in calendar URLs. */
  public calendarHash?: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** Whether to show full user names instead of display names. */
  public showFullUserNames: boolean;
  /** Whether this user is subscribed to changelog email or not. */
  public subscribedToChangelog: boolean;
  /** Whether this user is subscribed to DPA emails or not. */
  public subscribedToDPA: boolean;
  /** Whether this user is subscribed to invite accepted emails or not. */
  public subscribedToInviteAccepted: boolean;
  /** Whether this user is subscribed to privacy and legal update emails or not. */
  public subscribedToPrivacyLegalUpdates: boolean;
  /** The email types the user has unsubscribed from. */
  public unsubscribedFrom: string[];
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The user's notification category preferences. */
  public notificationCategoryPreferences: NotificationCategoryPreferences;
  /** The user's notification channel preferences. */
  public notificationChannelPreferences: NotificationChannelPreferences;
  /** The notification delivery preferences for the user. Note: notificationDisabled field is deprecated in favor of notificationChannelPreferences. */
  public notificationDeliveryPreferences: NotificationDeliveryPreferences;
  /** The user associated with these settings. */
  public get user(): LinearFetch<User> | undefined {
    return new UserQuery(this._request).fetch(this._user.id);
  }
  /** The ID of user associated with these settings. */
  public get userId(): string | undefined {
    return this._user?.id;
  }

  /** Updates the user's settings. */
  public update(input: L.UserSettingsUpdateInput) {
    return new UpdateUserSettingsMutation(this._request).fetch(this.id, input);
  }
}
/**
 * UserSettingsFlagPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFlagPayloadFragment response data
 */
export class UserSettingsFlagPayload extends Request {
  public constructor(request: LinearRequest, data: L.UserSettingsFlagPayloadFragment) {
    super(request);
    this.flag = data.flag ?? undefined;
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.value = data.value ?? undefined;
  }

  /** The flag key which was updated. */
  public flag?: string;
  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The flag value after update. */
  public value?: number;
}
/**
 * UserSettingsFlagsResetPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsFlagsResetPayloadFragment response data
 */
export class UserSettingsFlagsResetPayload extends Request {
  public constructor(request: LinearRequest, data: L.UserSettingsFlagsResetPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
}
/**
 * UserSettingsPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.UserSettingsPayloadFragment response data
 */
export class UserSettingsPayload extends Request {
  public constructor(request: LinearRequest, data: L.UserSettingsPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The user's settings. */
  public get userSettings(): LinearFetch<UserSettings> {
    return new UserSettingsQuery(this._request).fetch();
  }
}
/**
 * Payload for a user webhook.
 *
 * @param data - L.UserWebhookPayloadFragment response data
 */
export class UserWebhookPayload {
  public constructor(data: L.UserWebhookPayloadFragment) {
    this.active = data.active;
    this.admin = data.admin;
    this.app = data.app;
    this.archivedAt = data.archivedAt ?? undefined;
    this.avatarUrl = data.avatarUrl ?? undefined;
    this.createdAt = data.createdAt;
    this.description = data.description ?? undefined;
    this.disableReason = data.disableReason ?? undefined;
    this.displayName = data.displayName;
    this.email = data.email;
    this.guest = data.guest;
    this.id = data.id;
    this.name = data.name;
    this.timezone = data.timezone ?? undefined;
    this.updatedAt = data.updatedAt;
    this.url = data.url;
  }

  /** Whether the user is active. */
  public active: boolean;
  /** Whether the user is an admin. */
  public admin: boolean;
  /** Whether the user is an app. */
  public app: boolean;
  /** The time at which the entity was archived. */
  public archivedAt?: string;
  /** The avatar URL of the user. */
  public avatarUrl?: string;
  /** The time at which the entity was created. */
  public createdAt: string;
  /** The description of the user. */
  public description?: string;
  /** The reason the user is disabled. */
  public disableReason?: string;
  /** The display name of the user. */
  public displayName: string;
  /** The email of the user. */
  public email: string;
  /** Whether the user is a guest. */
  public guest: boolean;
  /** The ID of the entity. */
  public id: string;
  /** The name of the user. */
  public name: string;
  /** The local timezone of the user. */
  public timezone?: string;
  /** The time at which the entity was updated. */
  public updatedAt: string;
  /** The URL of the user. */
  public url: string;
}
/**
 * View preferences.
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesFragment response data
 */
export class ViewPreferences extends Request {
  public constructor(request: LinearRequest, data: L.ViewPreferencesFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.id = data.id;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.viewType = data.viewType;
    this.preferences = new ViewPreferencesValues(request, data.preferences);
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique identifier of the entity. */
  public id: string;
  /** The view preference type. */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The view type. */
  public viewType: string;
  /** The view preferences */
  public preferences: ViewPreferencesValues;

  /** Creates a new ViewPreferences object. */
  public create(input: L.ViewPreferencesCreateInput) {
    return new CreateViewPreferencesMutation(this._request).fetch(input);
  }
  /** Deletes a ViewPreferences. */
  public delete() {
    return new DeleteViewPreferencesMutation(this._request).fetch(this.id);
  }
  /** Updates an existing ViewPreferences object. */
  public update(input: L.ViewPreferencesUpdateInput) {
    return new UpdateViewPreferencesMutation(this._request).fetch(this.id, input);
  }
}
/**
 * ViewPreferencesPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesPayloadFragment response data
 */
export class ViewPreferencesPayload extends Request {
  public constructor(request: LinearRequest, data: L.ViewPreferencesPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this.viewPreferences = new ViewPreferences(request, data.viewPreferences);
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The view preferences entity being mutated. */
  public viewPreferences: ViewPreferences;
}
/**
 * ViewPreferencesValues model
 *
 * @param request - function to call the graphql client
 * @param data - L.ViewPreferencesValuesFragment response data
 */
export class ViewPreferencesValues extends Request {
  public constructor(request: LinearRequest, data: L.ViewPreferencesValuesFragment) {
    super(request);
    this.issueGrouping = data.issueGrouping ?? undefined;
    this.showCompletedIssues = data.showCompletedIssues ?? undefined;
    this.viewOrdering = data.viewOrdering ?? undefined;
  }

  /** The issue grouping. */
  public issueGrouping?: string;
  /** Whether to show completed issues. */
  public showCompletedIssues?: string;
  /** The issue ordering. */
  public viewOrdering?: string;
}
/**
 * A webhook used to send HTTP notifications over data updates.
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookFragment response data
 */
export class Webhook extends Request {
  private _creator?: L.WebhookFragment["creator"];
  private _team?: L.WebhookFragment["team"];

  public constructor(request: LinearRequest, data: L.WebhookFragment) {
    super(request);
    this.allPublicTeams = data.allPublicTeams;
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.enabled = data.enabled;
    this.id = data.id;
    this.label = data.label ?? undefined;
    this.resourceTypes = data.resourceTypes;
    this.secret = data.secret ?? undefined;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this.url = data.url ?? undefined;
    this._creator = data.creator ?? undefined;
    this._team = data.team ?? undefined;
  }

  /** Whether the Webhook is enabled for all public teams, including teams created after the webhook was created. */
  public allPublicTeams: boolean;
  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Whether the Webhook is enabled. */
  public enabled: boolean;
  /** The unique identifier of the entity. */
  public id: string;
  /** Webhook label. */
  public label?: string;
  /** The resource types this webhook is subscribed to. */
  public resourceTypes: string[];
  /** Secret token for verifying the origin on the recipient side. */
  public secret?: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** Webhook URL. */
  public url?: string;
  /** The user who created the webhook. */
  public get creator(): LinearFetch<User> | undefined {
    return this._creator?.id ? new UserQuery(this._request).fetch(this._creator?.id) : undefined;
  }
  /** The ID of user who created the webhook. */
  public get creatorId(): string | undefined {
    return this._creator?.id;
  }
  /** The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization or multiple teams. */
  public get team(): LinearFetch<Team> | undefined {
    return this._team?.id ? new TeamQuery(this._request).fetch(this._team?.id) : undefined;
  }
  /** The ID of team that the webhook is associated with. if null, the webhook is associated with all public teams of the organization or multiple teams. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }

  /** Creates a new webhook. */
  public create(input: L.WebhookCreateInput) {
    return new CreateWebhookMutation(this._request).fetch(input);
  }
  /** Deletes a Webhook. */
  public delete() {
    return new DeleteWebhookMutation(this._request).fetch(this.id);
  }
  /** Updates an existing Webhook. */
  public update(input: L.WebhookUpdateInput) {
    return new UpdateWebhookMutation(this._request).fetch(this.id, input);
  }
}
/**
 * WebhookConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WebhookConnection model
 * @param data - WebhookConnection response data
 */
export class WebhookConnection extends Connection<Webhook> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<Webhook> | undefined>,
    data: L.WebhookConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new Webhook(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * Entity representing a webhook execution failure.
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookFailureEventFragment response data
 */
export class WebhookFailureEvent extends Request {
  private _webhook: L.WebhookFailureEventFragment["webhook"];

  public constructor(request: LinearRequest, data: L.WebhookFailureEventFragment) {
    super(request);
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.executionId = data.executionId;
    this.httpStatus = data.httpStatus ?? undefined;
    this.id = data.id;
    this.responseOrError = data.responseOrError ?? undefined;
    this.url = data.url;
    this._webhook = data.webhook;
  }

  /** The time at which the entity was created. */
  public createdAt: Date;
  /** The unique execution ID of the webhook push. This is retained between retries of the same push. */
  public executionId: string;
  /** The HTTP status code returned by the recipient. */
  public httpStatus?: number;
  /** The unique identifier of the entity. */
  public id: string;
  /** The HTTP response body returned by the recipient or error occured. */
  public responseOrError?: string;
  /** The URL that the webhook was trying to push to. */
  public url: string;
  /** The webhook that this failure event is associated with. */
  public get webhook(): LinearFetch<Webhook> | undefined {
    return new WebhookQuery(this._request).fetch(this._webhook.id);
  }
  /** The ID of webhook that this failure event is associated with. */
  public get webhookId(): string | undefined {
    return this._webhook?.id;
  }
}
/**
 * WebhookPayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.WebhookPayloadFragment response data
 */
export class WebhookPayload extends Request {
  private _webhook: L.WebhookPayloadFragment["webhook"];

  public constructor(request: LinearRequest, data: L.WebhookPayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._webhook = data.webhook;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The webhook entity being mutated. */
  public get webhook(): LinearFetch<Webhook> | undefined {
    return new WebhookQuery(this._request).fetch(this._webhook.id);
  }
  /** The ID of webhook entity being mutated. */
  public get webhookId(): string | undefined {
    return this._webhook?.id;
  }
}
/**
 * A state in a team workflow.
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStateFragment response data
 */
export class WorkflowState extends Request {
  private _inheritedFrom?: L.WorkflowStateFragment["inheritedFrom"];
  private _team: L.WorkflowStateFragment["team"];

  public constructor(request: LinearRequest, data: L.WorkflowStateFragment) {
    super(request);
    this.archivedAt = parseDate(data.archivedAt) ?? undefined;
    this.color = data.color;
    this.createdAt = parseDate(data.createdAt) ?? new Date();
    this.description = data.description ?? undefined;
    this.id = data.id;
    this.name = data.name;
    this.position = data.position;
    this.type = data.type;
    this.updatedAt = parseDate(data.updatedAt) ?? new Date();
    this._inheritedFrom = data.inheritedFrom ?? undefined;
    this._team = data.team;
  }

  /** The time at which the entity was archived. Null if the entity has not been archived. */
  public archivedAt?: Date;
  /** The state's UI color as a HEX string. */
  public color: string;
  /** The time at which the entity was created. */
  public createdAt: Date;
  /** Description of the state. */
  public description?: string;
  /** The unique identifier of the entity. */
  public id: string;
  /** The state's name. */
  public name: string;
  /** The position of the state in the team flow. */
  public position: number;
  /** The type of the state. One of "triage", "backlog", "unstarted", "started", "completed", "canceled". */
  public type: string;
  /**
   * The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
   *     been updated after creation.
   */
  public updatedAt: Date;
  /** The state inherited from */
  public get inheritedFrom(): LinearFetch<WorkflowState> | undefined {
    return this._inheritedFrom?.id ? new WorkflowStateQuery(this._request).fetch(this._inheritedFrom?.id) : undefined;
  }
  /** The ID of state inherited from */
  public get inheritedFromId(): string | undefined {
    return this._inheritedFrom?.id;
  }
  /** The team to which this state belongs to. */
  public get team(): LinearFetch<Team> | undefined {
    return new TeamQuery(this._request).fetch(this._team.id);
  }
  /** The ID of team to which this state belongs to. */
  public get teamId(): string | undefined {
    return this._team?.id;
  }
  /** Issues belonging in this state. */
  public issues(variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">) {
    return new WorkflowState_IssuesQuery(this._request, this.id, variables).fetch(variables);
  }
  /** Archives a state. Only states with issues that have all been archived can be archived. */
  public archive() {
    return new ArchiveWorkflowStateMutation(this._request).fetch(this.id);
  }
  /** Creates a new state, adding it to the workflow of a team. */
  public create(input: L.WorkflowStateCreateInput) {
    return new CreateWorkflowStateMutation(this._request).fetch(input);
  }
  /** Updates a state. */
  public update(input: L.WorkflowStateUpdateInput) {
    return new UpdateWorkflowStateMutation(this._request).fetch(this.id, input);
  }
}
/**
 * A generic payload return from entity archive mutations.
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStateArchivePayloadFragment response data
 */
export class WorkflowStateArchivePayload extends Request {
  private _entity?: L.WorkflowStateArchivePayloadFragment["entity"];

  public constructor(request: LinearRequest, data: L.WorkflowStateArchivePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._entity = data.entity ?? undefined;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The archived/unarchived entity. Null if entity was deleted. */
  public get entity(): LinearFetch<WorkflowState> | undefined {
    return this._entity?.id ? new WorkflowStateQuery(this._request).fetch(this._entity?.id) : undefined;
  }
  /** The ID of archived/unarchived entity. null if entity was deleted. */
  public get entityId(): string | undefined {
    return this._entity?.id;
  }
}
/**
 * Certain properties of a workflow state.
 *
 * @param data - L.WorkflowStateChildWebhookPayloadFragment response data
 */
export class WorkflowStateChildWebhookPayload {
  public constructor(data: L.WorkflowStateChildWebhookPayloadFragment) {
    this.color = data.color;
    this.id = data.id;
    this.name = data.name;
    this.type = data.type;
  }

  /** The color of the workflow state. */
  public color: string;
  /** The ID of the workflow state. */
  public id: string;
  /** The name of the workflow state. */
  public name: string;
  /** The type of the workflow state. */
  public type: string;
}
/**
 * WorkflowStateConnection model
 *
 * @param request - function to call the graphql client
 * @param fetch - function to trigger a refetch of this WorkflowStateConnection model
 * @param data - WorkflowStateConnection response data
 */
export class WorkflowStateConnection extends Connection<WorkflowState> {
  public constructor(
    request: LinearRequest,
    fetch: (connection?: LinearConnectionVariables) => LinearFetch<LinearConnection<WorkflowState> | undefined>,
    data: L.WorkflowStateConnectionFragment
  ) {
    super(
      request,
      fetch,
      data.nodes.map(node => new WorkflowState(request, node)),
      new PageInfo(request, data.pageInfo)
    );
  }
}
/**
 * WorkflowStatePayload model
 *
 * @param request - function to call the graphql client
 * @param data - L.WorkflowStatePayloadFragment response data
 */
export class WorkflowStatePayload extends Request {
  private _workflowState: L.WorkflowStatePayloadFragment["workflowState"];

  public constructor(request: LinearRequest, data: L.WorkflowStatePayloadFragment) {
    super(request);
    this.lastSyncId = data.lastSyncId;
    this.success = data.success;
    this._workflowState = data.workflowState;
  }

  /** The identifier of the last sync operation. */
  public lastSyncId: number;
  /** Whether the operation was successful. */
  public success: boolean;
  /** The state that was created or updated. */
  public get workflowState(): LinearFetch<WorkflowState> | undefined {
    return new WorkflowStateQuery(this._request).fetch(this._workflowState.id);
  }
  /** The ID of state that was created or updated. */
  public get workflowStateId(): string | undefined {
    return this._workflowState?.id;
  }
}
/**
 * A fetchable AdministrableTeams Query
 *
 * @param request - function to call the graphql client
 */
export class AdministrableTeamsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AdministrableTeams query and return a TeamConnection
   *
   * @param variables - variables to pass into the AdministrableTeamsQuery
   * @returns parsed response from AdministrableTeamsQuery
   */
  public async fetch(variables?: L.AdministrableTeamsQueryVariables): LinearFetch<TeamConnection> {
    const response = await this._request<L.AdministrableTeamsQuery, L.AdministrableTeamsQueryVariables>(
      L.AdministrableTeamsDocument,
      variables
    );
    const data = response.administrableTeams;

    return new TeamConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AgentActivities Query
 *
 * @param request - function to call the graphql client
 */
export class AgentActivitiesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AgentActivities query and return a AgentActivityConnection
   *
   * @param variables - variables to pass into the AgentActivitiesQuery
   * @returns parsed response from AgentActivitiesQuery
   */
  public async fetch(variables?: L.AgentActivitiesQueryVariables): LinearFetch<AgentActivityConnection> {
    const response = await this._request<L.AgentActivitiesQuery, L.AgentActivitiesQueryVariables>(
      L.AgentActivitiesDocument,
      variables
    );
    const data = response.agentActivities;

    return new AgentActivityConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AgentActivity Query
 *
 * @param request - function to call the graphql client
 */
export class AgentActivityQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AgentActivity query and return a AgentActivity
   *
   * @param id - required id to pass to agentActivity
   * @returns parsed response from AgentActivityQuery
   */
  public async fetch(id: string): LinearFetch<AgentActivity> {
    const response = await this._request<L.AgentActivityQuery, L.AgentActivityQueryVariables>(L.AgentActivityDocument, {
      id,
    });
    const data = response.agentActivity;

    return new AgentActivity(this._request, data);
  }
}

/**
 * A fetchable AgentContext Query
 *
 * @param request - function to call the graphql client
 */
export class AgentContextQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AgentContext query and return a AgentContext
   *
   * @param id - required id to pass to agentContext
   * @returns parsed response from AgentContextQuery
   */
  public async fetch(id: string): LinearFetch<AgentContext> {
    const response = await this._request<L.AgentContextQuery, L.AgentContextQueryVariables>(L.AgentContextDocument, {
      id,
    });
    const data = response.agentContext;

    return new AgentContext(this._request, data);
  }
}

/**
 * A fetchable AgentContexts Query
 *
 * @param request - function to call the graphql client
 */
export class AgentContextsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AgentContexts query and return a AgentContextConnection
   *
   * @param variables - variables to pass into the AgentContextsQuery
   * @returns parsed response from AgentContextsQuery
   */
  public async fetch(variables?: L.AgentContextsQueryVariables): LinearFetch<AgentContextConnection> {
    const response = await this._request<L.AgentContextsQuery, L.AgentContextsQueryVariables>(
      L.AgentContextsDocument,
      variables
    );
    const data = response.agentContexts;

    return new AgentContextConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AgentSession Query
 *
 * @param request - function to call the graphql client
 */
export class AgentSessionQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AgentSession query and return a AgentSession
   *
   * @param id - required id to pass to agentSession
   * @returns parsed response from AgentSessionQuery
   */
  public async fetch(id: string): LinearFetch<AgentSession> {
    const response = await this._request<L.AgentSessionQuery, L.AgentSessionQueryVariables>(L.AgentSessionDocument, {
      id,
    });
    const data = response.agentSession;

    return new AgentSession(this._request, data);
  }
}

/**
 * A fetchable AgentSessions Query
 *
 * @param request - function to call the graphql client
 */
export class AgentSessionsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AgentSessions query and return a AgentSessionConnection
   *
   * @param variables - variables to pass into the AgentSessionsQuery
   * @returns parsed response from AgentSessionsQuery
   */
  public async fetch(variables?: L.AgentSessionsQueryVariables): LinearFetch<AgentSessionConnection> {
    const response = await this._request<L.AgentSessionsQuery, L.AgentSessionsQueryVariables>(
      L.AgentSessionsDocument,
      variables
    );
    const data = response.agentSessions;

    return new AgentSessionConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ApiKeys Query
 *
 * @param request - function to call the graphql client
 */
export class ApiKeysQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ApiKeys query and return a ApiKeyConnection
   *
   * @param variables - variables to pass into the ApiKeysQuery
   * @returns parsed response from ApiKeysQuery
   */
  public async fetch(variables?: L.ApiKeysQueryVariables): LinearFetch<ApiKeyConnection> {
    const response = await this._request<L.ApiKeysQuery, L.ApiKeysQueryVariables>(L.ApiKeysDocument, variables);
    const data = response.apiKeys;

    return new ApiKeyConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ApplicationInfo Query
 *
 * @param request - function to call the graphql client
 */
export class ApplicationInfoQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ApplicationInfo query and return a Application
   *
   * @param clientId - required clientId to pass to applicationInfo
   * @returns parsed response from ApplicationInfoQuery
   */
  public async fetch(clientId: string): LinearFetch<Application> {
    const response = await this._request<L.ApplicationInfoQuery, L.ApplicationInfoQueryVariables>(
      L.ApplicationInfoDocument,
      {
        clientId,
      }
    );
    const data = response.applicationInfo;

    return new Application(this._request, data);
  }
}

/**
 * A fetchable ApplicationWithAuthorization Query
 *
 * @param request - function to call the graphql client
 */
export class ApplicationWithAuthorizationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ApplicationWithAuthorization query and return a UserAuthorizedApplication
   *
   * @param clientId - required clientId to pass to applicationWithAuthorization
   * @param scope - required scope to pass to applicationWithAuthorization
   * @param variables - variables without 'clientId', 'scope' to pass into the ApplicationWithAuthorizationQuery
   * @returns parsed response from ApplicationWithAuthorizationQuery
   */
  public async fetch(
    clientId: string,
    scope: string[],
    variables?: Omit<L.ApplicationWithAuthorizationQueryVariables, "clientId" | "scope">
  ): LinearFetch<UserAuthorizedApplication> {
    const response = await this._request<
      L.ApplicationWithAuthorizationQuery,
      L.ApplicationWithAuthorizationQueryVariables
    >(L.ApplicationWithAuthorizationDocument, {
      clientId,
      scope,
      ...variables,
    });
    const data = response.applicationWithAuthorization;

    return new UserAuthorizedApplication(this._request, data);
  }
}

/**
 * A fetchable Attachment Query
 *
 * @param request - function to call the graphql client
 */
export class AttachmentQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Attachment query and return a Attachment
   *
   * @param id - required id to pass to attachment
   * @returns parsed response from AttachmentQuery
   */
  public async fetch(id: string): LinearFetch<Attachment> {
    const response = await this._request<L.AttachmentQuery, L.AttachmentQueryVariables>(L.AttachmentDocument, {
      id,
    });
    const data = response.attachment;

    return new Attachment(this._request, data);
  }
}

/**
 * A fetchable AttachmentIssue Query
 *
 * @param request - function to call the graphql client
 */
export class AttachmentIssueQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentIssue query and return a Issue
   *
   * @param id - required id to pass to attachmentIssue
   * @returns parsed response from AttachmentIssueQuery
   */
  public async fetch(id: string): LinearFetch<Issue> {
    const response = await this._request<L.AttachmentIssueQuery, L.AttachmentIssueQueryVariables>(
      L.AttachmentIssueDocument,
      {
        id,
      }
    );
    const data = response.attachmentIssue;

    return new Issue(this._request, data);
  }
}

/**
 * A fetchable Attachments Query
 *
 * @param request - function to call the graphql client
 */
export class AttachmentsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Attachments query and return a AttachmentConnection
   *
   * @param variables - variables to pass into the AttachmentsQuery
   * @returns parsed response from AttachmentsQuery
   */
  public async fetch(variables?: L.AttachmentsQueryVariables): LinearFetch<AttachmentConnection> {
    const response = await this._request<L.AttachmentsQuery, L.AttachmentsQueryVariables>(
      L.AttachmentsDocument,
      variables
    );
    const data = response.attachments;

    return new AttachmentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentsForUrl Query
 *
 * @param request - function to call the graphql client
 */
export class AttachmentsForUrlQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentsForUrl query and return a AttachmentConnection
   *
   * @param url - required url to pass to attachmentsForURL
   * @param variables - variables without 'url' to pass into the AttachmentsForUrlQuery
   * @returns parsed response from AttachmentsForUrlQuery
   */
  public async fetch(
    url: string,
    variables?: Omit<L.AttachmentsForUrlQueryVariables, "url">
  ): LinearFetch<AttachmentConnection> {
    const response = await this._request<L.AttachmentsForUrlQuery, L.AttachmentsForUrlQueryVariables>(
      L.AttachmentsForUrlDocument,
      {
        url,
        ...variables,
      }
    );
    const data = response.attachmentsForURL;

    return new AttachmentConnection(
      this._request,
      connection =>
        this.fetch(
          url,
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AuditEntries Query
 *
 * @param request - function to call the graphql client
 */
export class AuditEntriesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AuditEntries query and return a AuditEntryConnection
   *
   * @param variables - variables to pass into the AuditEntriesQuery
   * @returns parsed response from AuditEntriesQuery
   */
  public async fetch(variables?: L.AuditEntriesQueryVariables): LinearFetch<AuditEntryConnection> {
    const response = await this._request<L.AuditEntriesQuery, L.AuditEntriesQueryVariables>(
      L.AuditEntriesDocument,
      variables
    );
    const data = response.auditEntries;

    return new AuditEntryConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AuditEntryTypes Query
 *
 * @param request - function to call the graphql client
 */
export class AuditEntryTypesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AuditEntryTypes query and return a AuditEntryType list
   *
   * @returns parsed response from AuditEntryTypesQuery
   */
  public async fetch(): LinearFetch<AuditEntryType[]> {
    const response = await this._request<L.AuditEntryTypesQuery, L.AuditEntryTypesQueryVariables>(
      L.AuditEntryTypesDocument,
      {}
    );
    const data = response.auditEntryTypes;

    return data.map(node => {
      return new AuditEntryType(this._request, node);
    });
  }
}

/**
 * A fetchable AuthenticationSessions Query
 *
 * @param request - function to call the graphql client
 */
export class AuthenticationSessionsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AuthenticationSessions query and return a AuthenticationSessionResponse list
   *
   * @returns parsed response from AuthenticationSessionsQuery
   */
  public async fetch(): LinearFetch<AuthenticationSessionResponse[]> {
    const response = await this._request<L.AuthenticationSessionsQuery, L.AuthenticationSessionsQueryVariables>(
      L.AuthenticationSessionsDocument,
      {}
    );
    const data = response.authenticationSessions;

    return data.map(node => {
      return new AuthenticationSessionResponse(this._request, node);
    });
  }
}

/**
 * A fetchable AvailableUsers Query
 *
 * @param request - function to call the graphql client
 */
export class AvailableUsersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AvailableUsers query and return a AuthResolverResponse
   *
   * @returns parsed response from AvailableUsersQuery
   */
  public async fetch(): LinearFetch<AuthResolverResponse> {
    const response = await this._request<L.AvailableUsersQuery, L.AvailableUsersQueryVariables>(
      L.AvailableUsersDocument,
      {}
    );
    const data = response.availableUsers;

    return new AuthResolverResponse(this._request, data);
  }
}

/**
 * A fetchable Comment Query
 *
 * @param request - function to call the graphql client
 */
export class CommentQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Comment query and return a Comment
   *
   * @param variables - variables to pass into the CommentQuery
   * @returns parsed response from CommentQuery
   */
  public async fetch(variables?: L.CommentQueryVariables): LinearFetch<Comment> {
    const response = await this._request<L.CommentQuery, L.CommentQueryVariables>(L.CommentDocument, variables);
    const data = response.comment;

    return new Comment(this._request, data);
  }
}

/**
 * A fetchable Comments Query
 *
 * @param request - function to call the graphql client
 */
export class CommentsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Comments query and return a CommentConnection
   *
   * @param variables - variables to pass into the CommentsQuery
   * @returns parsed response from CommentsQuery
   */
  public async fetch(variables?: L.CommentsQueryVariables): LinearFetch<CommentConnection> {
    const response = await this._request<L.CommentsQuery, L.CommentsQueryVariables>(L.CommentsDocument, variables);
    const data = response.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable CustomView Query
 *
 * @param request - function to call the graphql client
 */
export class CustomViewQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomView query and return a CustomView
   *
   * @param id - required id to pass to customView
   * @returns parsed response from CustomViewQuery
   */
  public async fetch(id: string): LinearFetch<CustomView> {
    const response = await this._request<L.CustomViewQuery, L.CustomViewQueryVariables>(L.CustomViewDocument, {
      id,
    });
    const data = response.customView;

    return new CustomView(this._request, data);
  }
}

/**
 * A fetchable CustomViewHasSubscribers Query
 *
 * @param request - function to call the graphql client
 */
export class CustomViewHasSubscribersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomViewHasSubscribers query and return a CustomViewHasSubscribersPayload
   *
   * @param id - required id to pass to customViewHasSubscribers
   * @returns parsed response from CustomViewHasSubscribersQuery
   */
  public async fetch(id: string): LinearFetch<CustomViewHasSubscribersPayload> {
    const response = await this._request<L.CustomViewHasSubscribersQuery, L.CustomViewHasSubscribersQueryVariables>(
      L.CustomViewHasSubscribersDocument,
      {
        id,
      }
    );
    const data = response.customViewHasSubscribers;

    return new CustomViewHasSubscribersPayload(this._request, data);
  }
}

/**
 * A fetchable CustomViews Query
 *
 * @param request - function to call the graphql client
 */
export class CustomViewsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomViews query and return a CustomViewConnection
   *
   * @param variables - variables to pass into the CustomViewsQuery
   * @returns parsed response from CustomViewsQuery
   */
  public async fetch(variables?: L.CustomViewsQueryVariables): LinearFetch<CustomViewConnection> {
    const response = await this._request<L.CustomViewsQuery, L.CustomViewsQueryVariables>(
      L.CustomViewsDocument,
      variables
    );
    const data = response.customViews;

    return new CustomViewConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Customer Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Customer query and return a Customer
   *
   * @param id - required id to pass to customer
   * @returns parsed response from CustomerQuery
   */
  public async fetch(id: string): LinearFetch<Customer> {
    const response = await this._request<L.CustomerQuery, L.CustomerQueryVariables>(L.CustomerDocument, {
      id,
    });
    const data = response.customer;

    return new Customer(this._request, data);
  }
}

/**
 * A fetchable CustomerNeed Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerNeedQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerNeed query and return a CustomerNeed
   *
   * @param variables - variables to pass into the CustomerNeedQuery
   * @returns parsed response from CustomerNeedQuery
   */
  public async fetch(variables?: L.CustomerNeedQueryVariables): LinearFetch<CustomerNeed> {
    const response = await this._request<L.CustomerNeedQuery, L.CustomerNeedQueryVariables>(
      L.CustomerNeedDocument,
      variables
    );
    const data = response.customerNeed;

    return new CustomerNeed(this._request, data);
  }
}

/**
 * A fetchable CustomerNeeds Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerNeedsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerNeeds query and return a CustomerNeedConnection
   *
   * @param variables - variables to pass into the CustomerNeedsQuery
   * @returns parsed response from CustomerNeedsQuery
   */
  public async fetch(variables?: L.CustomerNeedsQueryVariables): LinearFetch<CustomerNeedConnection> {
    const response = await this._request<L.CustomerNeedsQuery, L.CustomerNeedsQueryVariables>(
      L.CustomerNeedsDocument,
      variables
    );
    const data = response.customerNeeds;

    return new CustomerNeedConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable CustomerStatus Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerStatusQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerStatus query and return a CustomerStatus
   *
   * @param id - required id to pass to customerStatus
   * @returns parsed response from CustomerStatusQuery
   */
  public async fetch(id: string): LinearFetch<CustomerStatus> {
    const response = await this._request<L.CustomerStatusQuery, L.CustomerStatusQueryVariables>(
      L.CustomerStatusDocument,
      {
        id,
      }
    );
    const data = response.customerStatus;

    return new CustomerStatus(this._request, data);
  }
}

/**
 * A fetchable CustomerStatuses Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerStatusesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerStatuses query and return a CustomerStatusConnection
   *
   * @param variables - variables to pass into the CustomerStatusesQuery
   * @returns parsed response from CustomerStatusesQuery
   */
  public async fetch(variables?: L.CustomerStatusesQueryVariables): LinearFetch<CustomerStatusConnection> {
    const response = await this._request<L.CustomerStatusesQuery, L.CustomerStatusesQueryVariables>(
      L.CustomerStatusesDocument,
      variables
    );
    const data = response.customerStatuses;

    return new CustomerStatusConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable CustomerTier Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerTierQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerTier query and return a CustomerTier
   *
   * @param id - required id to pass to customerTier
   * @returns parsed response from CustomerTierQuery
   */
  public async fetch(id: string): LinearFetch<CustomerTier> {
    const response = await this._request<L.CustomerTierQuery, L.CustomerTierQueryVariables>(L.CustomerTierDocument, {
      id,
    });
    const data = response.customerTier;

    return new CustomerTier(this._request, data);
  }
}

/**
 * A fetchable CustomerTiers Query
 *
 * @param request - function to call the graphql client
 */
export class CustomerTiersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerTiers query and return a CustomerTierConnection
   *
   * @param variables - variables to pass into the CustomerTiersQuery
   * @returns parsed response from CustomerTiersQuery
   */
  public async fetch(variables?: L.CustomerTiersQueryVariables): LinearFetch<CustomerTierConnection> {
    const response = await this._request<L.CustomerTiersQuery, L.CustomerTiersQueryVariables>(
      L.CustomerTiersDocument,
      variables
    );
    const data = response.customerTiers;

    return new CustomerTierConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Customers Query
 *
 * @param request - function to call the graphql client
 */
export class CustomersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Customers query and return a CustomerConnection
   *
   * @param variables - variables to pass into the CustomersQuery
   * @returns parsed response from CustomersQuery
   */
  public async fetch(variables?: L.CustomersQueryVariables): LinearFetch<CustomerConnection> {
    const response = await this._request<L.CustomersQuery, L.CustomersQueryVariables>(L.CustomersDocument, variables);
    const data = response.customers;

    return new CustomerConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Cycle Query
 *
 * @param request - function to call the graphql client
 */
export class CycleQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Cycle query and return a Cycle
   *
   * @param id - required id to pass to cycle
   * @returns parsed response from CycleQuery
   */
  public async fetch(id: string): LinearFetch<Cycle> {
    const response = await this._request<L.CycleQuery, L.CycleQueryVariables>(L.CycleDocument, {
      id,
    });
    const data = response.cycle;

    return new Cycle(this._request, data);
  }
}

/**
 * A fetchable Cycles Query
 *
 * @param request - function to call the graphql client
 */
export class CyclesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Cycles query and return a CycleConnection
   *
   * @param variables - variables to pass into the CyclesQuery
   * @returns parsed response from CyclesQuery
   */
  public async fetch(variables?: L.CyclesQueryVariables): LinearFetch<CycleConnection> {
    const response = await this._request<L.CyclesQuery, L.CyclesQueryVariables>(L.CyclesDocument, variables);
    const data = response.cycles;

    return new CycleConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Document Query
 *
 * @param request - function to call the graphql client
 */
export class DocumentQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Document query and return a Document
   *
   * @param id - required id to pass to document
   * @returns parsed response from DocumentQuery
   */
  public async fetch(id: string): LinearFetch<Document> {
    const response = await this._request<L.DocumentQuery, L.DocumentQueryVariables>(L.DocumentDocument, {
      id,
    });
    const data = response.document;

    return new Document(this._request, data);
  }
}

/**
 * A fetchable DocumentContentHistory Query
 *
 * @param request - function to call the graphql client
 */
export class DocumentContentHistoryQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DocumentContentHistory query and return a DocumentContentHistoryPayload
   *
   * @param id - required id to pass to documentContentHistory
   * @returns parsed response from DocumentContentHistoryQuery
   */
  public async fetch(id: string): LinearFetch<DocumentContentHistoryPayload> {
    const response = await this._request<L.DocumentContentHistoryQuery, L.DocumentContentHistoryQueryVariables>(
      L.DocumentContentHistoryDocument,
      {
        id,
      }
    );
    const data = response.documentContentHistory;

    return new DocumentContentHistoryPayload(this._request, data);
  }
}

/**
 * A fetchable Documents Query
 *
 * @param request - function to call the graphql client
 */
export class DocumentsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Documents query and return a DocumentConnection
   *
   * @param variables - variables to pass into the DocumentsQuery
   * @returns parsed response from DocumentsQuery
   */
  public async fetch(variables?: L.DocumentsQueryVariables): LinearFetch<DocumentConnection> {
    const response = await this._request<L.DocumentsQuery, L.DocumentsQueryVariables>(L.DocumentsDocument, variables);
    const data = response.documents;

    return new DocumentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable EmailIntakeAddress Query
 *
 * @param request - function to call the graphql client
 */
export class EmailIntakeAddressQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the EmailIntakeAddress query and return a EmailIntakeAddress
   *
   * @param id - required id to pass to emailIntakeAddress
   * @returns parsed response from EmailIntakeAddressQuery
   */
  public async fetch(id: string): LinearFetch<EmailIntakeAddress> {
    const response = await this._request<L.EmailIntakeAddressQuery, L.EmailIntakeAddressQueryVariables>(
      L.EmailIntakeAddressDocument,
      {
        id,
      }
    );
    const data = response.emailIntakeAddress;

    return new EmailIntakeAddress(this._request, data);
  }
}

/**
 * A fetchable Emoji Query
 *
 * @param request - function to call the graphql client
 */
export class EmojiQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Emoji query and return a Emoji
   *
   * @param id - required id to pass to emoji
   * @returns parsed response from EmojiQuery
   */
  public async fetch(id: string): LinearFetch<Emoji> {
    const response = await this._request<L.EmojiQuery, L.EmojiQueryVariables>(L.EmojiDocument, {
      id,
    });
    const data = response.emoji;

    return new Emoji(this._request, data);
  }
}

/**
 * A fetchable Emojis Query
 *
 * @param request - function to call the graphql client
 */
export class EmojisQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Emojis query and return a EmojiConnection
   *
   * @param variables - variables to pass into the EmojisQuery
   * @returns parsed response from EmojisQuery
   */
  public async fetch(variables?: L.EmojisQueryVariables): LinearFetch<EmojiConnection> {
    const response = await this._request<L.EmojisQuery, L.EmojisQueryVariables>(L.EmojisDocument, variables);
    const data = response.emojis;

    return new EmojiConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable EntityExternalLink Query
 *
 * @param request - function to call the graphql client
 */
export class EntityExternalLinkQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the EntityExternalLink query and return a EntityExternalLink
   *
   * @param id - required id to pass to entityExternalLink
   * @returns parsed response from EntityExternalLinkQuery
   */
  public async fetch(id: string): LinearFetch<EntityExternalLink> {
    const response = await this._request<L.EntityExternalLinkQuery, L.EntityExternalLinkQueryVariables>(
      L.EntityExternalLinkDocument,
      {
        id,
      }
    );
    const data = response.entityExternalLink;

    return new EntityExternalLink(this._request, data);
  }
}

/**
 * A fetchable ExternalUser Query
 *
 * @param request - function to call the graphql client
 */
export class ExternalUserQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ExternalUser query and return a ExternalUser
   *
   * @param id - required id to pass to externalUser
   * @returns parsed response from ExternalUserQuery
   */
  public async fetch(id: string): LinearFetch<ExternalUser> {
    const response = await this._request<L.ExternalUserQuery, L.ExternalUserQueryVariables>(L.ExternalUserDocument, {
      id,
    });
    const data = response.externalUser;

    return new ExternalUser(this._request, data);
  }
}

/**
 * A fetchable ExternalUsers Query
 *
 * @param request - function to call the graphql client
 */
export class ExternalUsersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ExternalUsers query and return a ExternalUserConnection
   *
   * @param variables - variables to pass into the ExternalUsersQuery
   * @returns parsed response from ExternalUsersQuery
   */
  public async fetch(variables?: L.ExternalUsersQueryVariables): LinearFetch<ExternalUserConnection> {
    const response = await this._request<L.ExternalUsersQuery, L.ExternalUsersQueryVariables>(
      L.ExternalUsersDocument,
      variables
    );
    const data = response.externalUsers;

    return new ExternalUserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Favorite Query
 *
 * @param request - function to call the graphql client
 */
export class FavoriteQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Favorite query and return a Favorite
   *
   * @param id - required id to pass to favorite
   * @returns parsed response from FavoriteQuery
   */
  public async fetch(id: string): LinearFetch<Favorite> {
    const response = await this._request<L.FavoriteQuery, L.FavoriteQueryVariables>(L.FavoriteDocument, {
      id,
    });
    const data = response.favorite;

    return new Favorite(this._request, data);
  }
}

/**
 * A fetchable Favorites Query
 *
 * @param request - function to call the graphql client
 */
export class FavoritesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Favorites query and return a FavoriteConnection
   *
   * @param variables - variables to pass into the FavoritesQuery
   * @returns parsed response from FavoritesQuery
   */
  public async fetch(variables?: L.FavoritesQueryVariables): LinearFetch<FavoriteConnection> {
    const response = await this._request<L.FavoritesQuery, L.FavoritesQueryVariables>(L.FavoritesDocument, variables);
    const data = response.favorites;

    return new FavoriteConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiative Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Initiative query and return a Initiative
   *
   * @param id - required id to pass to initiative
   * @returns parsed response from InitiativeQuery
   */
  public async fetch(id: string): LinearFetch<Initiative> {
    const response = await this._request<L.InitiativeQuery, L.InitiativeQueryVariables>(L.InitiativeDocument, {
      id,
    });
    const data = response.initiative;

    return new Initiative(this._request, data);
  }
}

/**
 * A fetchable InitiativeRelation Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeRelationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the InitiativeRelation query and return a ProjectRelation
   *
   * @param id - required id to pass to initiativeRelation
   * @returns parsed response from InitiativeRelationQuery
   */
  public async fetch(id: string): LinearFetch<ProjectRelation> {
    const response = await this._request<L.InitiativeRelationQuery, L.InitiativeRelationQueryVariables>(
      L.InitiativeRelationDocument,
      {
        id,
      }
    );
    const data = response.initiativeRelation;

    return new ProjectRelation(this._request, data);
  }
}

/**
 * A fetchable InitiativeRelations Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeRelationsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the InitiativeRelations query and return a InitiativeRelationConnection
   *
   * @param variables - variables to pass into the InitiativeRelationsQuery
   * @returns parsed response from InitiativeRelationsQuery
   */
  public async fetch(variables?: L.InitiativeRelationsQueryVariables): LinearFetch<InitiativeRelationConnection> {
    const response = await this._request<L.InitiativeRelationsQuery, L.InitiativeRelationsQueryVariables>(
      L.InitiativeRelationsDocument,
      variables
    );
    const data = response.initiativeRelations;

    return new InitiativeRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable InitiativeToProject Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeToProjectQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the InitiativeToProject query and return a InitiativeToProject
   *
   * @param id - required id to pass to initiativeToProject
   * @returns parsed response from InitiativeToProjectQuery
   */
  public async fetch(id: string): LinearFetch<InitiativeToProject> {
    const response = await this._request<L.InitiativeToProjectQuery, L.InitiativeToProjectQueryVariables>(
      L.InitiativeToProjectDocument,
      {
        id,
      }
    );
    const data = response.initiativeToProject;

    return new InitiativeToProject(this._request, data);
  }
}

/**
 * A fetchable InitiativeToProjects Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeToProjectsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the InitiativeToProjects query and return a InitiativeToProjectConnection
   *
   * @param variables - variables to pass into the InitiativeToProjectsQuery
   * @returns parsed response from InitiativeToProjectsQuery
   */
  public async fetch(variables?: L.InitiativeToProjectsQueryVariables): LinearFetch<InitiativeToProjectConnection> {
    const response = await this._request<L.InitiativeToProjectsQuery, L.InitiativeToProjectsQueryVariables>(
      L.InitiativeToProjectsDocument,
      variables
    );
    const data = response.initiativeToProjects;

    return new InitiativeToProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable InitiativeUpdate Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeUpdateQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the InitiativeUpdate query and return a InitiativeUpdate
   *
   * @param id - required id to pass to initiativeUpdate
   * @returns parsed response from InitiativeUpdateQuery
   */
  public async fetch(id: string): LinearFetch<InitiativeUpdate> {
    const response = await this._request<L.InitiativeUpdateQuery, L.InitiativeUpdateQueryVariables>(
      L.InitiativeUpdateDocument,
      {
        id,
      }
    );
    const data = response.initiativeUpdate;

    return new InitiativeUpdate(this._request, data);
  }
}

/**
 * A fetchable InitiativeUpdates Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativeUpdatesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the InitiativeUpdates query and return a InitiativeUpdateConnection
   *
   * @param variables - variables to pass into the InitiativeUpdatesQuery
   * @returns parsed response from InitiativeUpdatesQuery
   */
  public async fetch(variables?: L.InitiativeUpdatesQueryVariables): LinearFetch<InitiativeUpdateConnection> {
    const response = await this._request<L.InitiativeUpdatesQuery, L.InitiativeUpdatesQueryVariables>(
      L.InitiativeUpdatesDocument,
      variables
    );
    const data = response.initiativeUpdates;

    return new InitiativeUpdateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiatives Query
 *
 * @param request - function to call the graphql client
 */
export class InitiativesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Initiatives query and return a InitiativeConnection
   *
   * @param variables - variables to pass into the InitiativesQuery
   * @returns parsed response from InitiativesQuery
   */
  public async fetch(variables?: L.InitiativesQueryVariables): LinearFetch<InitiativeConnection> {
    const response = await this._request<L.InitiativesQuery, L.InitiativesQueryVariables>(
      L.InitiativesDocument,
      variables
    );
    const data = response.initiatives;

    return new InitiativeConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Integration Query
 *
 * @param request - function to call the graphql client
 */
export class IntegrationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Integration query and return a Integration
   *
   * @param id - required id to pass to integration
   * @returns parsed response from IntegrationQuery
   */
  public async fetch(id: string): LinearFetch<Integration> {
    const response = await this._request<L.IntegrationQuery, L.IntegrationQueryVariables>(L.IntegrationDocument, {
      id,
    });
    const data = response.integration;

    return new Integration(this._request, data);
  }
}

/**
 * A fetchable IntegrationHasScopes Query
 *
 * @param request - function to call the graphql client
 */
export class IntegrationHasScopesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationHasScopes query and return a IntegrationHasScopesPayload
   *
   * @param integrationId - required integrationId to pass to integrationHasScopes
   * @param scopes - required scopes to pass to integrationHasScopes
   * @returns parsed response from IntegrationHasScopesQuery
   */
  public async fetch(integrationId: string, scopes: string[]): LinearFetch<IntegrationHasScopesPayload> {
    const response = await this._request<L.IntegrationHasScopesQuery, L.IntegrationHasScopesQueryVariables>(
      L.IntegrationHasScopesDocument,
      {
        integrationId,
        scopes,
      }
    );
    const data = response.integrationHasScopes;

    return new IntegrationHasScopesPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationTemplate Query
 *
 * @param request - function to call the graphql client
 */
export class IntegrationTemplateQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationTemplate query and return a IntegrationTemplate
   *
   * @param id - required id to pass to integrationTemplate
   * @returns parsed response from IntegrationTemplateQuery
   */
  public async fetch(id: string): LinearFetch<IntegrationTemplate> {
    const response = await this._request<L.IntegrationTemplateQuery, L.IntegrationTemplateQueryVariables>(
      L.IntegrationTemplateDocument,
      {
        id,
      }
    );
    const data = response.integrationTemplate;

    return new IntegrationTemplate(this._request, data);
  }
}

/**
 * A fetchable IntegrationTemplates Query
 *
 * @param request - function to call the graphql client
 */
export class IntegrationTemplatesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationTemplates query and return a IntegrationTemplateConnection
   *
   * @param variables - variables to pass into the IntegrationTemplatesQuery
   * @returns parsed response from IntegrationTemplatesQuery
   */
  public async fetch(variables?: L.IntegrationTemplatesQueryVariables): LinearFetch<IntegrationTemplateConnection> {
    const response = await this._request<L.IntegrationTemplatesQuery, L.IntegrationTemplatesQueryVariables>(
      L.IntegrationTemplatesDocument,
      variables
    );
    const data = response.integrationTemplates;

    return new IntegrationTemplateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Integrations Query
 *
 * @param request - function to call the graphql client
 */
export class IntegrationsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Integrations query and return a IntegrationConnection
   *
   * @param variables - variables to pass into the IntegrationsQuery
   * @returns parsed response from IntegrationsQuery
   */
  public async fetch(variables?: L.IntegrationsQueryVariables): LinearFetch<IntegrationConnection> {
    const response = await this._request<L.IntegrationsQuery, L.IntegrationsQueryVariables>(
      L.IntegrationsDocument,
      variables
    );
    const data = response.integrations;

    return new IntegrationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IntegrationsSettings Query
 *
 * @param request - function to call the graphql client
 */
export class IntegrationsSettingsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationsSettings query and return a IntegrationsSettings
   *
   * @param id - required id to pass to integrationsSettings
   * @returns parsed response from IntegrationsSettingsQuery
   */
  public async fetch(id: string): LinearFetch<IntegrationsSettings> {
    const response = await this._request<L.IntegrationsSettingsQuery, L.IntegrationsSettingsQueryVariables>(
      L.IntegrationsSettingsDocument,
      {
        id,
      }
    );
    const data = response.integrationsSettings;

    return new IntegrationsSettings(this._request, data);
  }
}

/**
 * A fetchable Issue Query
 *
 * @param request - function to call the graphql client
 */
export class IssueQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Issue query and return a Issue
   *
   * @param id - required id to pass to issue
   * @returns parsed response from IssueQuery
   */
  public async fetch(id: string): LinearFetch<Issue> {
    const response = await this._request<L.IssueQuery, L.IssueQueryVariables>(L.IssueDocument, {
      id,
    });
    const data = response.issue;

    return new Issue(this._request, data);
  }
}

/**
 * A fetchable IssueFigmaFileKeySearch Query
 *
 * @param request - function to call the graphql client
 */
export class IssueFigmaFileKeySearchQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueFigmaFileKeySearch query and return a IssueConnection
   *
   * @param fileKey - required fileKey to pass to issueFigmaFileKeySearch
   * @param variables - variables without 'fileKey' to pass into the IssueFigmaFileKeySearchQuery
   * @returns parsed response from IssueFigmaFileKeySearchQuery
   */
  public async fetch(
    fileKey: string,
    variables?: Omit<L.IssueFigmaFileKeySearchQueryVariables, "fileKey">
  ): LinearFetch<IssueConnection> {
    const response = await this._request<L.IssueFigmaFileKeySearchQuery, L.IssueFigmaFileKeySearchQueryVariables>(
      L.IssueFigmaFileKeySearchDocument,
      {
        fileKey,
        ...variables,
      }
    );
    const data = response.issueFigmaFileKeySearch;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          fileKey,
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssueFilterSuggestion Query
 *
 * @param request - function to call the graphql client
 */
export class IssueFilterSuggestionQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueFilterSuggestion query and return a IssueFilterSuggestionPayload
   *
   * @param prompt - required prompt to pass to issueFilterSuggestion
   * @param variables - variables without 'prompt' to pass into the IssueFilterSuggestionQuery
   * @returns parsed response from IssueFilterSuggestionQuery
   */
  public async fetch(
    prompt: string,
    variables?: Omit<L.IssueFilterSuggestionQueryVariables, "prompt">
  ): LinearFetch<IssueFilterSuggestionPayload> {
    const response = await this._request<L.IssueFilterSuggestionQuery, L.IssueFilterSuggestionQueryVariables>(
      L.IssueFilterSuggestionDocument,
      {
        prompt,
        ...variables,
      }
    );
    const data = response.issueFilterSuggestion;

    return new IssueFilterSuggestionPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCheckCsv Query
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCheckCsvQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCheckCsv query and return a IssueImportCheckPayload
   *
   * @param csvUrl - required csvUrl to pass to issueImportCheckCSV
   * @param service - required service to pass to issueImportCheckCSV
   * @returns parsed response from IssueImportCheckCsvQuery
   */
  public async fetch(csvUrl: string, service: string): LinearFetch<IssueImportCheckPayload> {
    const response = await this._request<L.IssueImportCheckCsvQuery, L.IssueImportCheckCsvQueryVariables>(
      L.IssueImportCheckCsvDocument,
      {
        csvUrl,
        service,
      }
    );
    const data = response.issueImportCheckCSV;

    return new IssueImportCheckPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCheckSync Query
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCheckSyncQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCheckSync query and return a IssueImportSyncCheckPayload
   *
   * @param issueImportId - required issueImportId to pass to issueImportCheckSync
   * @returns parsed response from IssueImportCheckSyncQuery
   */
  public async fetch(issueImportId: string): LinearFetch<IssueImportSyncCheckPayload> {
    const response = await this._request<L.IssueImportCheckSyncQuery, L.IssueImportCheckSyncQueryVariables>(
      L.IssueImportCheckSyncDocument,
      {
        issueImportId,
      }
    );
    const data = response.issueImportCheckSync;

    return new IssueImportSyncCheckPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportJqlCheck Query
 *
 * @param request - function to call the graphql client
 */
export class IssueImportJqlCheckQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportJqlCheck query and return a IssueImportJqlCheckPayload
   *
   * @param jiraEmail - required jiraEmail to pass to issueImportJqlCheck
   * @param jiraHostname - required jiraHostname to pass to issueImportJqlCheck
   * @param jiraProject - required jiraProject to pass to issueImportJqlCheck
   * @param jiraToken - required jiraToken to pass to issueImportJqlCheck
   * @param jql - required jql to pass to issueImportJqlCheck
   * @returns parsed response from IssueImportJqlCheckQuery
   */
  public async fetch(
    jiraEmail: string,
    jiraHostname: string,
    jiraProject: string,
    jiraToken: string,
    jql: string
  ): LinearFetch<IssueImportJqlCheckPayload> {
    const response = await this._request<L.IssueImportJqlCheckQuery, L.IssueImportJqlCheckQueryVariables>(
      L.IssueImportJqlCheckDocument,
      {
        jiraEmail,
        jiraHostname,
        jiraProject,
        jiraToken,
        jql,
      }
    );
    const data = response.issueImportJqlCheck;

    return new IssueImportJqlCheckPayload(this._request, data);
  }
}

/**
 * A fetchable IssueLabel Query
 *
 * @param request - function to call the graphql client
 */
export class IssueLabelQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueLabel query and return a IssueLabel
   *
   * @param id - required id to pass to issueLabel
   * @returns parsed response from IssueLabelQuery
   */
  public async fetch(id: string): LinearFetch<IssueLabel> {
    const response = await this._request<L.IssueLabelQuery, L.IssueLabelQueryVariables>(L.IssueLabelDocument, {
      id,
    });
    const data = response.issueLabel;

    return new IssueLabel(this._request, data);
  }
}

/**
 * A fetchable IssueLabels Query
 *
 * @param request - function to call the graphql client
 */
export class IssueLabelsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueLabels query and return a IssueLabelConnection
   *
   * @param variables - variables to pass into the IssueLabelsQuery
   * @returns parsed response from IssueLabelsQuery
   */
  public async fetch(variables?: L.IssueLabelsQueryVariables): LinearFetch<IssueLabelConnection> {
    const response = await this._request<L.IssueLabelsQuery, L.IssueLabelsQueryVariables>(
      L.IssueLabelsDocument,
      variables
    );
    const data = response.issueLabels;

    return new IssueLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssuePriorityValues Query
 *
 * @param request - function to call the graphql client
 */
export class IssuePriorityValuesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssuePriorityValues query and return a IssuePriorityValue list
   *
   * @returns parsed response from IssuePriorityValuesQuery
   */
  public async fetch(): LinearFetch<IssuePriorityValue[]> {
    const response = await this._request<L.IssuePriorityValuesQuery, L.IssuePriorityValuesQueryVariables>(
      L.IssuePriorityValuesDocument,
      {}
    );
    const data = response.issuePriorityValues;

    return data.map(node => {
      return new IssuePriorityValue(this._request, node);
    });
  }
}

/**
 * A fetchable IssueRelation Query
 *
 * @param request - function to call the graphql client
 */
export class IssueRelationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueRelation query and return a IssueRelation
   *
   * @param id - required id to pass to issueRelation
   * @returns parsed response from IssueRelationQuery
   */
  public async fetch(id: string): LinearFetch<IssueRelation> {
    const response = await this._request<L.IssueRelationQuery, L.IssueRelationQueryVariables>(L.IssueRelationDocument, {
      id,
    });
    const data = response.issueRelation;

    return new IssueRelation(this._request, data);
  }
}

/**
 * A fetchable IssueRelations Query
 *
 * @param request - function to call the graphql client
 */
export class IssueRelationsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueRelations query and return a IssueRelationConnection
   *
   * @param variables - variables to pass into the IssueRelationsQuery
   * @returns parsed response from IssueRelationsQuery
   */
  public async fetch(variables?: L.IssueRelationsQueryVariables): LinearFetch<IssueRelationConnection> {
    const response = await this._request<L.IssueRelationsQuery, L.IssueRelationsQueryVariables>(
      L.IssueRelationsDocument,
      variables
    );
    const data = response.issueRelations;

    return new IssueRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssueSearch Query
 *
 * @param request - function to call the graphql client
 */
export class IssueSearchQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueSearch query and return a IssueConnection
   *
   * @param variables - variables to pass into the IssueSearchQuery
   * @returns parsed response from IssueSearchQuery
   */
  public async fetch(variables?: L.IssueSearchQueryVariables): LinearFetch<IssueConnection> {
    const response = await this._request<L.IssueSearchQuery, L.IssueSearchQueryVariables>(
      L.IssueSearchDocument,
      variables
    );
    const data = response.issueSearch;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssueTitleSuggestionFromCustomerRequest Query
 *
 * @param request - function to call the graphql client
 */
export class IssueTitleSuggestionFromCustomerRequestQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueTitleSuggestionFromCustomerRequest query and return a IssueTitleSuggestionFromCustomerRequestPayload
   *
   * @param request - required request to pass to issueTitleSuggestionFromCustomerRequest
   * @returns parsed response from IssueTitleSuggestionFromCustomerRequestQuery
   */
  public async fetch(request: string): LinearFetch<IssueTitleSuggestionFromCustomerRequestPayload> {
    const response = await this._request<
      L.IssueTitleSuggestionFromCustomerRequestQuery,
      L.IssueTitleSuggestionFromCustomerRequestQueryVariables
    >(L.IssueTitleSuggestionFromCustomerRequestDocument, {
      request,
    });
    const data = response.issueTitleSuggestionFromCustomerRequest;

    return new IssueTitleSuggestionFromCustomerRequestPayload(this._request, data);
  }
}

/**
 * A fetchable IssueVcsBranchSearch Query
 *
 * @param request - function to call the graphql client
 */
export class IssueVcsBranchSearchQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueVcsBranchSearch query and return a Issue
   *
   * @param branchName - required branchName to pass to issueVcsBranchSearch
   * @returns parsed response from IssueVcsBranchSearchQuery
   */
  public async fetch(branchName: string): LinearFetch<Issue | undefined> {
    const response = await this._request<L.IssueVcsBranchSearchQuery, L.IssueVcsBranchSearchQueryVariables>(
      L.IssueVcsBranchSearchDocument,
      {
        branchName,
      }
    );
    const data = response.issueVcsBranchSearch;

    return data ? new Issue(this._request, data) : undefined;
  }
}

/**
 * A fetchable Issues Query
 *
 * @param request - function to call the graphql client
 */
export class IssuesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Issues query and return a IssueConnection
   *
   * @param variables - variables to pass into the IssuesQuery
   * @returns parsed response from IssuesQuery
   */
  public async fetch(variables?: L.IssuesQueryVariables): LinearFetch<IssueConnection> {
    const response = await this._request<L.IssuesQuery, L.IssuesQueryVariables>(L.IssuesDocument, variables);
    const data = response.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Notification Query
 *
 * @param request - function to call the graphql client
 */
export class NotificationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Notification query and return a Notification
   *
   * @param id - required id to pass to notification
   * @returns parsed response from NotificationQuery
   */
  public async fetch(
    id: string
  ): LinearFetch<
    | CustomerNeedNotification
    | CustomerNotification
    | DocumentNotification
    | InitiativeNotification
    | IssueNotification
    | OauthClientApprovalNotification
    | PostNotification
    | ProjectNotification
    | PullRequestNotification
    | Notification
  > {
    const response = await this._request<L.NotificationQuery, L.NotificationQueryVariables>(L.NotificationDocument, {
      id,
    });
    const data = response.notification;

    switch (data.__typename) {
      case "CustomerNeedNotification":
        return new CustomerNeedNotification(this._request, data as L.CustomerNeedNotificationFragment);
      case "CustomerNotification":
        return new CustomerNotification(this._request, data as L.CustomerNotificationFragment);
      case "DocumentNotification":
        return new DocumentNotification(this._request, data as L.DocumentNotificationFragment);
      case "InitiativeNotification":
        return new InitiativeNotification(this._request, data as L.InitiativeNotificationFragment);
      case "IssueNotification":
        return new IssueNotification(this._request, data as L.IssueNotificationFragment);
      case "OauthClientApprovalNotification":
        return new OauthClientApprovalNotification(this._request, data as L.OauthClientApprovalNotificationFragment);
      case "PostNotification":
        return new PostNotification(this._request, data as L.PostNotificationFragment);
      case "ProjectNotification":
        return new ProjectNotification(this._request, data as L.ProjectNotificationFragment);
      case "PullRequestNotification":
        return new PullRequestNotification(this._request, data as L.PullRequestNotificationFragment);

      default:
        return new Notification(this._request, data);
    }
  }
}

/**
 * A fetchable NotificationSubscription Query
 *
 * @param request - function to call the graphql client
 */
export class NotificationSubscriptionQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationSubscription query and return a NotificationSubscription
   *
   * @param id - required id to pass to notificationSubscription
   * @returns parsed response from NotificationSubscriptionQuery
   */
  public async fetch(
    id: string
  ): LinearFetch<
    | CustomViewNotificationSubscription
    | CustomerNotificationSubscription
    | CycleNotificationSubscription
    | InitiativeNotificationSubscription
    | LabelNotificationSubscription
    | ProjectNotificationSubscription
    | TeamNotificationSubscription
    | UserNotificationSubscription
    | NotificationSubscription
  > {
    const response = await this._request<L.NotificationSubscriptionQuery, L.NotificationSubscriptionQueryVariables>(
      L.NotificationSubscriptionDocument,
      {
        id,
      }
    );
    const data = response.notificationSubscription;

    switch (data.__typename) {
      case "CustomViewNotificationSubscription":
        return new CustomViewNotificationSubscription(
          this._request,
          data as L.CustomViewNotificationSubscriptionFragment
        );
      case "CustomerNotificationSubscription":
        return new CustomerNotificationSubscription(this._request, data as L.CustomerNotificationSubscriptionFragment);
      case "CycleNotificationSubscription":
        return new CycleNotificationSubscription(this._request, data as L.CycleNotificationSubscriptionFragment);
      case "InitiativeNotificationSubscription":
        return new InitiativeNotificationSubscription(
          this._request,
          data as L.InitiativeNotificationSubscriptionFragment
        );
      case "LabelNotificationSubscription":
        return new LabelNotificationSubscription(this._request, data as L.LabelNotificationSubscriptionFragment);
      case "ProjectNotificationSubscription":
        return new ProjectNotificationSubscription(this._request, data as L.ProjectNotificationSubscriptionFragment);
      case "TeamNotificationSubscription":
        return new TeamNotificationSubscription(this._request, data as L.TeamNotificationSubscriptionFragment);
      case "UserNotificationSubscription":
        return new UserNotificationSubscription(this._request, data as L.UserNotificationSubscriptionFragment);

      default:
        return new NotificationSubscription(this._request, data);
    }
  }
}

/**
 * A fetchable NotificationSubscriptions Query
 *
 * @param request - function to call the graphql client
 */
export class NotificationSubscriptionsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationSubscriptions query and return a NotificationSubscriptionConnection
   *
   * @param variables - variables to pass into the NotificationSubscriptionsQuery
   * @returns parsed response from NotificationSubscriptionsQuery
   */
  public async fetch(
    variables?: L.NotificationSubscriptionsQueryVariables
  ): LinearFetch<NotificationSubscriptionConnection> {
    const response = await this._request<L.NotificationSubscriptionsQuery, L.NotificationSubscriptionsQueryVariables>(
      L.NotificationSubscriptionsDocument,
      variables
    );
    const data = response.notificationSubscriptions;

    return new NotificationSubscriptionConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Notifications Query
 *
 * @param request - function to call the graphql client
 */
export class NotificationsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Notifications query and return a NotificationConnection
   *
   * @param variables - variables to pass into the NotificationsQuery
   * @returns parsed response from NotificationsQuery
   */
  public async fetch(variables?: L.NotificationsQueryVariables): LinearFetch<NotificationConnection> {
    const response = await this._request<L.NotificationsQuery, L.NotificationsQueryVariables>(
      L.NotificationsDocument,
      variables
    );
    const data = response.notifications;

    return new NotificationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Organization Query
 *
 * @param request - function to call the graphql client
 */
export class OrganizationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Organization query and return a Organization
   *
   * @returns parsed response from OrganizationQuery
   */
  public async fetch(): LinearFetch<Organization> {
    const response = await this._request<L.OrganizationQuery, L.OrganizationQueryVariables>(L.OrganizationDocument, {});
    const data = response.organization;

    return new Organization(this._request, data);
  }
}

/**
 * A fetchable OrganizationExists Query
 *
 * @param request - function to call the graphql client
 */
export class OrganizationExistsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the OrganizationExists query and return a OrganizationExistsPayload
   *
   * @param urlKey - required urlKey to pass to organizationExists
   * @returns parsed response from OrganizationExistsQuery
   */
  public async fetch(urlKey: string): LinearFetch<OrganizationExistsPayload> {
    const response = await this._request<L.OrganizationExistsQuery, L.OrganizationExistsQueryVariables>(
      L.OrganizationExistsDocument,
      {
        urlKey,
      }
    );
    const data = response.organizationExists;

    return new OrganizationExistsPayload(this._request, data);
  }
}

/**
 * A fetchable OrganizationInvite Query
 *
 * @param request - function to call the graphql client
 */
export class OrganizationInviteQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the OrganizationInvite query and return a OrganizationInvite
   *
   * @param id - required id to pass to organizationInvite
   * @returns parsed response from OrganizationInviteQuery
   */
  public async fetch(id: string): LinearFetch<OrganizationInvite> {
    const response = await this._request<L.OrganizationInviteQuery, L.OrganizationInviteQueryVariables>(
      L.OrganizationInviteDocument,
      {
        id,
      }
    );
    const data = response.organizationInvite;

    return new OrganizationInvite(this._request, data);
  }
}

/**
 * A fetchable OrganizationInvites Query
 *
 * @param request - function to call the graphql client
 */
export class OrganizationInvitesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the OrganizationInvites query and return a OrganizationInviteConnection
   *
   * @param variables - variables to pass into the OrganizationInvitesQuery
   * @returns parsed response from OrganizationInvitesQuery
   */
  public async fetch(variables?: L.OrganizationInvitesQueryVariables): LinearFetch<OrganizationInviteConnection> {
    const response = await this._request<L.OrganizationInvitesQuery, L.OrganizationInvitesQueryVariables>(
      L.OrganizationInvitesDocument,
      variables
    );
    const data = response.organizationInvites;

    return new OrganizationInviteConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Project query and return a Project
   *
   * @param id - required id to pass to project
   * @returns parsed response from ProjectQuery
   */
  public async fetch(id: string): LinearFetch<Project> {
    const response = await this._request<L.ProjectQuery, L.ProjectQueryVariables>(L.ProjectDocument, {
      id,
    });
    const data = response.project;

    return new Project(this._request, data);
  }
}

/**
 * A fetchable ProjectFilterSuggestion Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectFilterSuggestionQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectFilterSuggestion query and return a ProjectFilterSuggestionPayload
   *
   * @param prompt - required prompt to pass to projectFilterSuggestion
   * @returns parsed response from ProjectFilterSuggestionQuery
   */
  public async fetch(prompt: string): LinearFetch<ProjectFilterSuggestionPayload> {
    const response = await this._request<L.ProjectFilterSuggestionQuery, L.ProjectFilterSuggestionQueryVariables>(
      L.ProjectFilterSuggestionDocument,
      {
        prompt,
      }
    );
    const data = response.projectFilterSuggestion;

    return new ProjectFilterSuggestionPayload(this._request, data);
  }
}

/**
 * A fetchable ProjectLabel Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectLabelQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectLabel query and return a ProjectLabel
   *
   * @param id - required id to pass to projectLabel
   * @returns parsed response from ProjectLabelQuery
   */
  public async fetch(id: string): LinearFetch<ProjectLabel> {
    const response = await this._request<L.ProjectLabelQuery, L.ProjectLabelQueryVariables>(L.ProjectLabelDocument, {
      id,
    });
    const data = response.projectLabel;

    return new ProjectLabel(this._request, data);
  }
}

/**
 * A fetchable ProjectLabels Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectLabelsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectLabels query and return a ProjectLabelConnection
   *
   * @param variables - variables to pass into the ProjectLabelsQuery
   * @returns parsed response from ProjectLabelsQuery
   */
  public async fetch(variables?: L.ProjectLabelsQueryVariables): LinearFetch<ProjectLabelConnection> {
    const response = await this._request<L.ProjectLabelsQuery, L.ProjectLabelsQueryVariables>(
      L.ProjectLabelsDocument,
      variables
    );
    const data = response.projectLabels;

    return new ProjectLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectMilestone Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectMilestoneQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectMilestone query and return a ProjectMilestone
   *
   * @param id - required id to pass to projectMilestone
   * @returns parsed response from ProjectMilestoneQuery
   */
  public async fetch(id: string): LinearFetch<ProjectMilestone> {
    const response = await this._request<L.ProjectMilestoneQuery, L.ProjectMilestoneQueryVariables>(
      L.ProjectMilestoneDocument,
      {
        id,
      }
    );
    const data = response.projectMilestone;

    return new ProjectMilestone(this._request, data);
  }
}

/**
 * A fetchable ProjectMilestones Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectMilestonesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectMilestones query and return a ProjectMilestoneConnection
   *
   * @param variables - variables to pass into the ProjectMilestonesQuery
   * @returns parsed response from ProjectMilestonesQuery
   */
  public async fetch(variables?: L.ProjectMilestonesQueryVariables): LinearFetch<ProjectMilestoneConnection> {
    const response = await this._request<L.ProjectMilestonesQuery, L.ProjectMilestonesQueryVariables>(
      L.ProjectMilestonesDocument,
      variables
    );
    const data = response.projectMilestones;

    return new ProjectMilestoneConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectRelation Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectRelationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectRelation query and return a ProjectRelation
   *
   * @param id - required id to pass to projectRelation
   * @returns parsed response from ProjectRelationQuery
   */
  public async fetch(id: string): LinearFetch<ProjectRelation> {
    const response = await this._request<L.ProjectRelationQuery, L.ProjectRelationQueryVariables>(
      L.ProjectRelationDocument,
      {
        id,
      }
    );
    const data = response.projectRelation;

    return new ProjectRelation(this._request, data);
  }
}

/**
 * A fetchable ProjectRelations Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectRelationsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectRelations query and return a ProjectRelationConnection
   *
   * @param variables - variables to pass into the ProjectRelationsQuery
   * @returns parsed response from ProjectRelationsQuery
   */
  public async fetch(variables?: L.ProjectRelationsQueryVariables): LinearFetch<ProjectRelationConnection> {
    const response = await this._request<L.ProjectRelationsQuery, L.ProjectRelationsQueryVariables>(
      L.ProjectRelationsDocument,
      variables
    );
    const data = response.projectRelations;

    return new ProjectRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectStatus Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectStatusQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectStatus query and return a ProjectStatus
   *
   * @param id - required id to pass to projectStatus
   * @returns parsed response from ProjectStatusQuery
   */
  public async fetch(id: string): LinearFetch<ProjectStatus> {
    const response = await this._request<L.ProjectStatusQuery, L.ProjectStatusQueryVariables>(L.ProjectStatusDocument, {
      id,
    });
    const data = response.projectStatus;

    return new ProjectStatus(this._request, data);
  }
}

/**
 * A fetchable ProjectStatuses Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectStatusesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectStatuses query and return a ProjectStatusConnection
   *
   * @param variables - variables to pass into the ProjectStatusesQuery
   * @returns parsed response from ProjectStatusesQuery
   */
  public async fetch(variables?: L.ProjectStatusesQueryVariables): LinearFetch<ProjectStatusConnection> {
    const response = await this._request<L.ProjectStatusesQuery, L.ProjectStatusesQueryVariables>(
      L.ProjectStatusesDocument,
      variables
    );
    const data = response.projectStatuses;

    return new ProjectStatusConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectUpdate Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectUpdateQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectUpdate query and return a ProjectUpdate
   *
   * @param id - required id to pass to projectUpdate
   * @returns parsed response from ProjectUpdateQuery
   */
  public async fetch(id: string): LinearFetch<ProjectUpdate> {
    const response = await this._request<L.ProjectUpdateQuery, L.ProjectUpdateQueryVariables>(L.ProjectUpdateDocument, {
      id,
    });
    const data = response.projectUpdate;

    return new ProjectUpdate(this._request, data);
  }
}

/**
 * A fetchable ProjectUpdates Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectUpdatesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectUpdates query and return a ProjectUpdateConnection
   *
   * @param variables - variables to pass into the ProjectUpdatesQuery
   * @returns parsed response from ProjectUpdatesQuery
   */
  public async fetch(variables?: L.ProjectUpdatesQueryVariables): LinearFetch<ProjectUpdateConnection> {
    const response = await this._request<L.ProjectUpdatesQuery, L.ProjectUpdatesQueryVariables>(
      L.ProjectUpdatesDocument,
      variables
    );
    const data = response.projectUpdates;

    return new ProjectUpdateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Projects Query
 *
 * @param request - function to call the graphql client
 */
export class ProjectsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Projects query and return a ProjectConnection
   *
   * @param variables - variables to pass into the ProjectsQuery
   * @returns parsed response from ProjectsQuery
   */
  public async fetch(variables?: L.ProjectsQueryVariables): LinearFetch<ProjectConnection> {
    const response = await this._request<L.ProjectsQuery, L.ProjectsQueryVariables>(L.ProjectsDocument, variables);
    const data = response.projects;

    return new ProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable PushSubscriptionTest Query
 *
 * @param request - function to call the graphql client
 */
export class PushSubscriptionTestQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the PushSubscriptionTest query and return a PushSubscriptionTestPayload
   *
   * @param variables - variables to pass into the PushSubscriptionTestQuery
   * @returns parsed response from PushSubscriptionTestQuery
   */
  public async fetch(variables?: L.PushSubscriptionTestQueryVariables): LinearFetch<PushSubscriptionTestPayload> {
    const response = await this._request<L.PushSubscriptionTestQuery, L.PushSubscriptionTestQueryVariables>(
      L.PushSubscriptionTestDocument,
      variables
    );
    const data = response.pushSubscriptionTest;

    return new PushSubscriptionTestPayload(this._request, data);
  }
}

/**
 * A fetchable RateLimitStatus Query
 *
 * @param request - function to call the graphql client
 */
export class RateLimitStatusQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the RateLimitStatus query and return a RateLimitPayload
   *
   * @returns parsed response from RateLimitStatusQuery
   */
  public async fetch(): LinearFetch<RateLimitPayload> {
    const response = await this._request<L.RateLimitStatusQuery, L.RateLimitStatusQueryVariables>(
      L.RateLimitStatusDocument,
      {}
    );
    const data = response.rateLimitStatus;

    return new RateLimitPayload(this._request, data);
  }
}

/**
 * A fetchable Roadmap Query
 *
 * @param request - function to call the graphql client
 */
export class RoadmapQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Roadmap query and return a Roadmap
   *
   * @param id - required id to pass to roadmap
   * @returns parsed response from RoadmapQuery
   */
  public async fetch(id: string): LinearFetch<Roadmap> {
    const response = await this._request<L.RoadmapQuery, L.RoadmapQueryVariables>(L.RoadmapDocument, {
      id,
    });
    const data = response.roadmap;

    return new Roadmap(this._request, data);
  }
}

/**
 * A fetchable RoadmapToProject Query
 *
 * @param request - function to call the graphql client
 */
export class RoadmapToProjectQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the RoadmapToProject query and return a RoadmapToProject
   *
   * @param id - required id to pass to roadmapToProject
   * @returns parsed response from RoadmapToProjectQuery
   */
  public async fetch(id: string): LinearFetch<RoadmapToProject> {
    const response = await this._request<L.RoadmapToProjectQuery, L.RoadmapToProjectQueryVariables>(
      L.RoadmapToProjectDocument,
      {
        id,
      }
    );
    const data = response.roadmapToProject;

    return new RoadmapToProject(this._request, data);
  }
}

/**
 * A fetchable RoadmapToProjects Query
 *
 * @param request - function to call the graphql client
 */
export class RoadmapToProjectsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the RoadmapToProjects query and return a RoadmapToProjectConnection
   *
   * @param variables - variables to pass into the RoadmapToProjectsQuery
   * @returns parsed response from RoadmapToProjectsQuery
   */
  public async fetch(variables?: L.RoadmapToProjectsQueryVariables): LinearFetch<RoadmapToProjectConnection> {
    const response = await this._request<L.RoadmapToProjectsQuery, L.RoadmapToProjectsQueryVariables>(
      L.RoadmapToProjectsDocument,
      variables
    );
    const data = response.roadmapToProjects;

    return new RoadmapToProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Roadmaps Query
 *
 * @param request - function to call the graphql client
 */
export class RoadmapsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Roadmaps query and return a RoadmapConnection
   *
   * @param variables - variables to pass into the RoadmapsQuery
   * @returns parsed response from RoadmapsQuery
   */
  public async fetch(variables?: L.RoadmapsQueryVariables): LinearFetch<RoadmapConnection> {
    const response = await this._request<L.RoadmapsQuery, L.RoadmapsQueryVariables>(L.RoadmapsDocument, variables);
    const data = response.roadmaps;

    return new RoadmapConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable SearchDocuments Query
 *
 * @param request - function to call the graphql client
 */
export class SearchDocumentsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the SearchDocuments query and return a DocumentSearchPayload
   *
   * @param term - required term to pass to searchDocuments
   * @param variables - variables without 'term' to pass into the SearchDocumentsQuery
   * @returns parsed response from SearchDocumentsQuery
   */
  public async fetch(
    term: string,
    variables?: Omit<L.SearchDocumentsQueryVariables, "term">
  ): LinearFetch<DocumentSearchPayload> {
    const response = await this._request<L.SearchDocumentsQuery, L.SearchDocumentsQueryVariables>(
      L.SearchDocumentsDocument,
      {
        term,
        ...variables,
      }
    );
    const data = response.searchDocuments;

    return new DocumentSearchPayload(this._request, data);
  }
}

/**
 * A fetchable SearchIssues Query
 *
 * @param request - function to call the graphql client
 */
export class SearchIssuesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the SearchIssues query and return a IssueSearchPayload
   *
   * @param term - required term to pass to searchIssues
   * @param variables - variables without 'term' to pass into the SearchIssuesQuery
   * @returns parsed response from SearchIssuesQuery
   */
  public async fetch(
    term: string,
    variables?: Omit<L.SearchIssuesQueryVariables, "term">
  ): LinearFetch<IssueSearchPayload> {
    const response = await this._request<L.SearchIssuesQuery, L.SearchIssuesQueryVariables>(L.SearchIssuesDocument, {
      term,
      ...variables,
    });
    const data = response.searchIssues;

    return new IssueSearchPayload(this._request, data);
  }
}

/**
 * A fetchable SearchProjects Query
 *
 * @param request - function to call the graphql client
 */
export class SearchProjectsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the SearchProjects query and return a ProjectSearchPayload
   *
   * @param term - required term to pass to searchProjects
   * @param variables - variables without 'term' to pass into the SearchProjectsQuery
   * @returns parsed response from SearchProjectsQuery
   */
  public async fetch(
    term: string,
    variables?: Omit<L.SearchProjectsQueryVariables, "term">
  ): LinearFetch<ProjectSearchPayload> {
    const response = await this._request<L.SearchProjectsQuery, L.SearchProjectsQueryVariables>(
      L.SearchProjectsDocument,
      {
        term,
        ...variables,
      }
    );
    const data = response.searchProjects;

    return new ProjectSearchPayload(this._request, data);
  }
}

/**
 * A fetchable SsoUrlFromEmail Query
 *
 * @param request - function to call the graphql client
 */
export class SsoUrlFromEmailQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the SsoUrlFromEmail query and return a SsoUrlFromEmailResponse
   *
   * @param email - required email to pass to ssoUrlFromEmail
   * @param variables - variables without 'email' to pass into the SsoUrlFromEmailQuery
   * @returns parsed response from SsoUrlFromEmailQuery
   */
  public async fetch(
    email: string,
    variables?: Omit<L.SsoUrlFromEmailQueryVariables, "email">
  ): LinearFetch<SsoUrlFromEmailResponse> {
    const response = await this._request<L.SsoUrlFromEmailQuery, L.SsoUrlFromEmailQueryVariables>(
      L.SsoUrlFromEmailDocument,
      {
        email,
        ...variables,
      }
    );
    const data = response.ssoUrlFromEmail;

    return new SsoUrlFromEmailResponse(this._request, data);
  }
}

/**
 * A fetchable Team Query
 *
 * @param request - function to call the graphql client
 */
export class TeamQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Team query and return a Team
   *
   * @param id - required id to pass to team
   * @returns parsed response from TeamQuery
   */
  public async fetch(id: string): LinearFetch<Team> {
    const response = await this._request<L.TeamQuery, L.TeamQueryVariables>(L.TeamDocument, {
      id,
    });
    const data = response.team;

    return new Team(this._request, data);
  }
}

/**
 * A fetchable TeamMembership Query
 *
 * @param request - function to call the graphql client
 */
export class TeamMembershipQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TeamMembership query and return a TeamMembership
   *
   * @param id - required id to pass to teamMembership
   * @returns parsed response from TeamMembershipQuery
   */
  public async fetch(id: string): LinearFetch<TeamMembership> {
    const response = await this._request<L.TeamMembershipQuery, L.TeamMembershipQueryVariables>(
      L.TeamMembershipDocument,
      {
        id,
      }
    );
    const data = response.teamMembership;

    return new TeamMembership(this._request, data);
  }
}

/**
 * A fetchable TeamMemberships Query
 *
 * @param request - function to call the graphql client
 */
export class TeamMembershipsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TeamMemberships query and return a TeamMembershipConnection
   *
   * @param variables - variables to pass into the TeamMembershipsQuery
   * @returns parsed response from TeamMembershipsQuery
   */
  public async fetch(variables?: L.TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection> {
    const response = await this._request<L.TeamMembershipsQuery, L.TeamMembershipsQueryVariables>(
      L.TeamMembershipsDocument,
      variables
    );
    const data = response.teamMemberships;

    return new TeamMembershipConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Teams Query
 *
 * @param request - function to call the graphql client
 */
export class TeamsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Teams query and return a TeamConnection
   *
   * @param variables - variables to pass into the TeamsQuery
   * @returns parsed response from TeamsQuery
   */
  public async fetch(variables?: L.TeamsQueryVariables): LinearFetch<TeamConnection> {
    const response = await this._request<L.TeamsQuery, L.TeamsQueryVariables>(L.TeamsDocument, variables);
    const data = response.teams;

    return new TeamConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Template Query
 *
 * @param request - function to call the graphql client
 */
export class TemplateQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Template query and return a Template
   *
   * @param id - required id to pass to template
   * @returns parsed response from TemplateQuery
   */
  public async fetch(id: string): LinearFetch<Template> {
    const response = await this._request<L.TemplateQuery, L.TemplateQueryVariables>(L.TemplateDocument, {
      id,
    });
    const data = response.template;

    return new Template(this._request, data);
  }
}

/**
 * A fetchable Templates Query
 *
 * @param request - function to call the graphql client
 */
export class TemplatesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Templates query and return a Template list
   *
   * @returns parsed response from TemplatesQuery
   */
  public async fetch(): LinearFetch<Template[]> {
    const response = await this._request<L.TemplatesQuery, L.TemplatesQueryVariables>(L.TemplatesDocument, {});
    const data = response.templates;

    return data.map(node => {
      return new Template(this._request, node);
    });
  }
}

/**
 * A fetchable TemplatesForIntegration Query
 *
 * @param request - function to call the graphql client
 */
export class TemplatesForIntegrationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TemplatesForIntegration query and return a Template list
   *
   * @param integrationType - required integrationType to pass to templatesForIntegration
   * @returns parsed response from TemplatesForIntegrationQuery
   */
  public async fetch(integrationType: string): LinearFetch<Template[]> {
    const response = await this._request<L.TemplatesForIntegrationQuery, L.TemplatesForIntegrationQueryVariables>(
      L.TemplatesForIntegrationDocument,
      {
        integrationType,
      }
    );
    const data = response.templatesForIntegration;

    return data.map(node => {
      return new Template(this._request, node);
    });
  }
}

/**
 * A fetchable TimeSchedule Query
 *
 * @param request - function to call the graphql client
 */
export class TimeScheduleQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TimeSchedule query and return a TimeSchedule
   *
   * @param id - required id to pass to timeSchedule
   * @returns parsed response from TimeScheduleQuery
   */
  public async fetch(id: string): LinearFetch<TimeSchedule> {
    const response = await this._request<L.TimeScheduleQuery, L.TimeScheduleQueryVariables>(L.TimeScheduleDocument, {
      id,
    });
    const data = response.timeSchedule;

    return new TimeSchedule(this._request, data);
  }
}

/**
 * A fetchable TimeSchedules Query
 *
 * @param request - function to call the graphql client
 */
export class TimeSchedulesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TimeSchedules query and return a TimeScheduleConnection
   *
   * @param variables - variables to pass into the TimeSchedulesQuery
   * @returns parsed response from TimeSchedulesQuery
   */
  public async fetch(variables?: L.TimeSchedulesQueryVariables): LinearFetch<TimeScheduleConnection> {
    const response = await this._request<L.TimeSchedulesQuery, L.TimeSchedulesQueryVariables>(
      L.TimeSchedulesDocument,
      variables
    );
    const data = response.timeSchedules;

    return new TimeScheduleConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable TriageResponsibilities Query
 *
 * @param request - function to call the graphql client
 */
export class TriageResponsibilitiesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TriageResponsibilities query and return a TriageResponsibilityConnection
   *
   * @param variables - variables to pass into the TriageResponsibilitiesQuery
   * @returns parsed response from TriageResponsibilitiesQuery
   */
  public async fetch(variables?: L.TriageResponsibilitiesQueryVariables): LinearFetch<TriageResponsibilityConnection> {
    const response = await this._request<L.TriageResponsibilitiesQuery, L.TriageResponsibilitiesQueryVariables>(
      L.TriageResponsibilitiesDocument,
      variables
    );
    const data = response.triageResponsibilities;

    return new TriageResponsibilityConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable TriageResponsibility Query
 *
 * @param request - function to call the graphql client
 */
export class TriageResponsibilityQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TriageResponsibility query and return a TriageResponsibility
   *
   * @param id - required id to pass to triageResponsibility
   * @returns parsed response from TriageResponsibilityQuery
   */
  public async fetch(id: string): LinearFetch<TriageResponsibility> {
    const response = await this._request<L.TriageResponsibilityQuery, L.TriageResponsibilityQueryVariables>(
      L.TriageResponsibilityDocument,
      {
        id,
      }
    );
    const data = response.triageResponsibility;

    return new TriageResponsibility(this._request, data);
  }
}

/**
 * A fetchable User Query
 *
 * @param request - function to call the graphql client
 */
export class UserQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the User query and return a User
   *
   * @param id - required id to pass to user
   * @returns parsed response from UserQuery
   */
  public async fetch(id: string): LinearFetch<User> {
    const response = await this._request<L.UserQuery, L.UserQueryVariables>(L.UserDocument, {
      id,
    });
    const data = response.user;

    return new User(this._request, data);
  }
}

/**
 * A fetchable UserSettings Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettingsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings query and return a UserSettings
   *
   * @returns parsed response from UserSettingsQuery
   */
  public async fetch(): LinearFetch<UserSettings> {
    const response = await this._request<L.UserSettingsQuery, L.UserSettingsQueryVariables>(L.UserSettingsDocument, {});
    const data = response.userSettings;

    return new UserSettings(this._request, data);
  }
}

/**
 * A fetchable Users Query
 *
 * @param request - function to call the graphql client
 */
export class UsersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Users query and return a UserConnection
   *
   * @param variables - variables to pass into the UsersQuery
   * @returns parsed response from UsersQuery
   */
  public async fetch(variables?: L.UsersQueryVariables): LinearFetch<UserConnection> {
    const response = await this._request<L.UsersQuery, L.UsersQueryVariables>(L.UsersDocument, variables);
    const data = response.users;

    return new UserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable VerifyGitHubEnterpriseServerInstallation Query
 *
 * @param request - function to call the graphql client
 */
export class VerifyGitHubEnterpriseServerInstallationQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the VerifyGitHubEnterpriseServerInstallation query and return a GitHubEnterpriseServerInstallVerificationPayload
   *
   * @returns parsed response from VerifyGitHubEnterpriseServerInstallationQuery
   */
  public async fetch(): LinearFetch<GitHubEnterpriseServerInstallVerificationPayload> {
    const response = await this._request<
      L.VerifyGitHubEnterpriseServerInstallationQuery,
      L.VerifyGitHubEnterpriseServerInstallationQueryVariables
    >(L.VerifyGitHubEnterpriseServerInstallationDocument, {});
    const data = response.verifyGitHubEnterpriseServerInstallation;

    return new GitHubEnterpriseServerInstallVerificationPayload(this._request, data);
  }
}

/**
 * A fetchable Viewer Query
 *
 * @param request - function to call the graphql client
 */
export class ViewerQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Viewer query and return a User
   *
   * @returns parsed response from ViewerQuery
   */
  public async fetch(): LinearFetch<User> {
    const response = await this._request<L.ViewerQuery, L.ViewerQueryVariables>(L.ViewerDocument, {});
    const data = response.viewer;

    return new User(this._request, data);
  }
}

/**
 * A fetchable Webhook Query
 *
 * @param request - function to call the graphql client
 */
export class WebhookQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Webhook query and return a Webhook
   *
   * @param id - required id to pass to webhook
   * @returns parsed response from WebhookQuery
   */
  public async fetch(id: string): LinearFetch<Webhook> {
    const response = await this._request<L.WebhookQuery, L.WebhookQueryVariables>(L.WebhookDocument, {
      id,
    });
    const data = response.webhook;

    return new Webhook(this._request, data);
  }
}

/**
 * A fetchable Webhooks Query
 *
 * @param request - function to call the graphql client
 */
export class WebhooksQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Webhooks query and return a WebhookConnection
   *
   * @param variables - variables to pass into the WebhooksQuery
   * @returns parsed response from WebhooksQuery
   */
  public async fetch(variables?: L.WebhooksQueryVariables): LinearFetch<WebhookConnection> {
    const response = await this._request<L.WebhooksQuery, L.WebhooksQueryVariables>(L.WebhooksDocument, variables);
    const data = response.webhooks;

    return new WebhookConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable WorkflowState Query
 *
 * @param request - function to call the graphql client
 */
export class WorkflowStateQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the WorkflowState query and return a WorkflowState
   *
   * @param id - required id to pass to workflowState
   * @returns parsed response from WorkflowStateQuery
   */
  public async fetch(id: string): LinearFetch<WorkflowState> {
    const response = await this._request<L.WorkflowStateQuery, L.WorkflowStateQueryVariables>(L.WorkflowStateDocument, {
      id,
    });
    const data = response.workflowState;

    return new WorkflowState(this._request, data);
  }
}

/**
 * A fetchable WorkflowStates Query
 *
 * @param request - function to call the graphql client
 */
export class WorkflowStatesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the WorkflowStates query and return a WorkflowStateConnection
   *
   * @param variables - variables to pass into the WorkflowStatesQuery
   * @returns parsed response from WorkflowStatesQuery
   */
  public async fetch(variables?: L.WorkflowStatesQueryVariables): LinearFetch<WorkflowStateConnection> {
    const response = await this._request<L.WorkflowStatesQuery, L.WorkflowStatesQueryVariables>(
      L.WorkflowStatesDocument,
      variables
    );
    const data = response.workflowStates;

    return new WorkflowStateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable CreateAgentActivity Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateAgentActivityMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateAgentActivity mutation and return a AgentActivityPayload
   *
   * @param input - required input to pass to createAgentActivity
   * @returns parsed response from CreateAgentActivityMutation
   */
  public async fetch(input: L.AgentActivityCreateInput): LinearFetch<AgentActivityPayload> {
    const response = await this._request<L.CreateAgentActivityMutation, L.CreateAgentActivityMutationVariables>(
      L.CreateAgentActivityDocument,
      {
        input,
      }
    );
    const data = response.agentActivityCreate;

    return new AgentActivityPayload(this._request, data);
  }
}

/**
 * A fetchable CreateAgentContext Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateAgentContextMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateAgentContext mutation and return a AgentContextPayload
   *
   * @param input - required input to pass to createAgentContext
   * @returns parsed response from CreateAgentContextMutation
   */
  public async fetch(input: L.AgentContextCreateInput): LinearFetch<AgentContextPayload> {
    const response = await this._request<L.CreateAgentContextMutation, L.CreateAgentContextMutationVariables>(
      L.CreateAgentContextDocument,
      {
        input,
      }
    );
    const data = response.agentContextCreate;

    return new AgentContextPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateAgentContext Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateAgentContextMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateAgentContext mutation and return a AgentContextPayload
   *
   * @param id - required id to pass to updateAgentContext
   * @param input - required input to pass to updateAgentContext
   * @returns parsed response from UpdateAgentContextMutation
   */
  public async fetch(id: string, input: L.AgentContextUpdateInput): LinearFetch<AgentContextPayload> {
    const response = await this._request<L.UpdateAgentContextMutation, L.UpdateAgentContextMutationVariables>(
      L.UpdateAgentContextDocument,
      {
        id,
        input,
      }
    );
    const data = response.agentContextUpdate;

    return new AgentContextPayload(this._request, data);
  }
}

/**
 * A fetchable AirbyteIntegrationConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class AirbyteIntegrationConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AirbyteIntegrationConnect mutation and return a IntegrationPayload
   *
   * @param input - required input to pass to airbyteIntegrationConnect
   * @returns parsed response from AirbyteIntegrationConnectMutation
   */
  public async fetch(input: L.AirbyteConfigurationInput): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.AirbyteIntegrationConnectMutation,
      L.AirbyteIntegrationConnectMutationVariables
    >(L.AirbyteIntegrationConnectDocument, {
      input,
    });
    const data = response.airbyteIntegrationConnect;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable CreateAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateAttachmentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateAttachment mutation and return a AttachmentPayload
   *
   * @param input - required input to pass to createAttachment
   * @returns parsed response from CreateAttachmentMutation
   */
  public async fetch(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.CreateAttachmentMutation, L.CreateAttachmentMutationVariables>(
      L.CreateAttachmentDocument,
      {
        input,
      }
    );
    const data = response.attachmentCreate;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteAttachmentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteAttachment mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteAttachment
   * @returns parsed response from DeleteAttachmentMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteAttachmentMutation, L.DeleteAttachmentMutationVariables>(
      L.DeleteAttachmentDocument,
      {
        id,
      }
    );
    const data = response.attachmentDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkDiscord Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkDiscordMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkDiscord mutation and return a AttachmentPayload
   *
   * @param channelId - required channelId to pass to attachmentLinkDiscord
   * @param issueId - required issueId to pass to attachmentLinkDiscord
   * @param messageId - required messageId to pass to attachmentLinkDiscord
   * @param url - required url to pass to attachmentLinkDiscord
   * @param variables - variables without 'channelId', 'issueId', 'messageId', 'url' to pass into the AttachmentLinkDiscordMutation
   * @returns parsed response from AttachmentLinkDiscordMutation
   */
  public async fetch(
    channelId: string,
    issueId: string,
    messageId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkDiscordMutationVariables, "channelId" | "issueId" | "messageId" | "url">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkDiscordMutation, L.AttachmentLinkDiscordMutationVariables>(
      L.AttachmentLinkDiscordDocument,
      {
        channelId,
        issueId,
        messageId,
        url,
        ...variables,
      }
    );
    const data = response.attachmentLinkDiscord;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkFront Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkFrontMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkFront mutation and return a FrontAttachmentPayload
   *
   * @param conversationId - required conversationId to pass to attachmentLinkFront
   * @param issueId - required issueId to pass to attachmentLinkFront
   * @param variables - variables without 'conversationId', 'issueId' to pass into the AttachmentLinkFrontMutation
   * @returns parsed response from AttachmentLinkFrontMutation
   */
  public async fetch(
    conversationId: string,
    issueId: string,
    variables?: Omit<L.AttachmentLinkFrontMutationVariables, "conversationId" | "issueId">
  ): LinearFetch<FrontAttachmentPayload> {
    const response = await this._request<L.AttachmentLinkFrontMutation, L.AttachmentLinkFrontMutationVariables>(
      L.AttachmentLinkFrontDocument,
      {
        conversationId,
        issueId,
        ...variables,
      }
    );
    const data = response.attachmentLinkFront;

    return new FrontAttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkGitHubIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkGitHubIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkGitHubIssue mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkGitHubIssue
   * @param url - required url to pass to attachmentLinkGitHubIssue
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkGitHubIssueMutation
   * @returns parsed response from AttachmentLinkGitHubIssueMutation
   */
  public async fetch(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkGitHubIssueMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<
      L.AttachmentLinkGitHubIssueMutation,
      L.AttachmentLinkGitHubIssueMutationVariables
    >(L.AttachmentLinkGitHubIssueDocument, {
      issueId,
      url,
      ...variables,
    });
    const data = response.attachmentLinkGitHubIssue;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkGitHubPr Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkGitHubPrMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkGitHubPr mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkGitHubPR
   * @param url - required url to pass to attachmentLinkGitHubPR
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkGitHubPrMutation
   * @returns parsed response from AttachmentLinkGitHubPrMutation
   */
  public async fetch(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkGitHubPrMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkGitHubPrMutation, L.AttachmentLinkGitHubPrMutationVariables>(
      L.AttachmentLinkGitHubPrDocument,
      {
        issueId,
        url,
        ...variables,
      }
    );
    const data = response.attachmentLinkGitHubPR;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkGitLabMr Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkGitLabMrMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkGitLabMr mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkGitLabMR
   * @param number - required number to pass to attachmentLinkGitLabMR
   * @param projectPathWithNamespace - required projectPathWithNamespace to pass to attachmentLinkGitLabMR
   * @param url - required url to pass to attachmentLinkGitLabMR
   * @param variables - variables without 'issueId', 'number', 'projectPathWithNamespace', 'url' to pass into the AttachmentLinkGitLabMrMutation
   * @returns parsed response from AttachmentLinkGitLabMrMutation
   */
  public async fetch(
    issueId: string,
    number: number,
    projectPathWithNamespace: string,
    url: string,
    variables?: Omit<
      L.AttachmentLinkGitLabMrMutationVariables,
      "issueId" | "number" | "projectPathWithNamespace" | "url"
    >
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkGitLabMrMutation, L.AttachmentLinkGitLabMrMutationVariables>(
      L.AttachmentLinkGitLabMrDocument,
      {
        issueId,
        number,
        projectPathWithNamespace,
        url,
        ...variables,
      }
    );
    const data = response.attachmentLinkGitLabMR;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkIntercomMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkIntercom mutation and return a AttachmentPayload
   *
   * @param conversationId - required conversationId to pass to attachmentLinkIntercom
   * @param issueId - required issueId to pass to attachmentLinkIntercom
   * @param variables - variables without 'conversationId', 'issueId' to pass into the AttachmentLinkIntercomMutation
   * @returns parsed response from AttachmentLinkIntercomMutation
   */
  public async fetch(
    conversationId: string,
    issueId: string,
    variables?: Omit<L.AttachmentLinkIntercomMutationVariables, "conversationId" | "issueId">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkIntercomMutation, L.AttachmentLinkIntercomMutationVariables>(
      L.AttachmentLinkIntercomDocument,
      {
        conversationId,
        issueId,
        ...variables,
      }
    );
    const data = response.attachmentLinkIntercom;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkJiraIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkJiraIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkJiraIssue mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkJiraIssue
   * @param jiraIssueId - required jiraIssueId to pass to attachmentLinkJiraIssue
   * @param variables - variables without 'issueId', 'jiraIssueId' to pass into the AttachmentLinkJiraIssueMutation
   * @returns parsed response from AttachmentLinkJiraIssueMutation
   */
  public async fetch(
    issueId: string,
    jiraIssueId: string,
    variables?: Omit<L.AttachmentLinkJiraIssueMutationVariables, "issueId" | "jiraIssueId">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkJiraIssueMutation, L.AttachmentLinkJiraIssueMutationVariables>(
      L.AttachmentLinkJiraIssueDocument,
      {
        issueId,
        jiraIssueId,
        ...variables,
      }
    );
    const data = response.attachmentLinkJiraIssue;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkSalesforce Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkSalesforceMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkSalesforce mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkSalesforce
   * @param url - required url to pass to attachmentLinkSalesforce
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkSalesforceMutation
   * @returns parsed response from AttachmentLinkSalesforceMutation
   */
  public async fetch(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkSalesforceMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<
      L.AttachmentLinkSalesforceMutation,
      L.AttachmentLinkSalesforceMutationVariables
    >(L.AttachmentLinkSalesforceDocument, {
      issueId,
      url,
      ...variables,
    });
    const data = response.attachmentLinkSalesforce;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkSlackMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkSlack mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkSlack
   * @param url - required url to pass to attachmentLinkSlack
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkSlackMutation
   * @returns parsed response from AttachmentLinkSlackMutation
   */
  public async fetch(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkSlackMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkSlackMutation, L.AttachmentLinkSlackMutationVariables>(
      L.AttachmentLinkSlackDocument,
      {
        issueId,
        url,
        ...variables,
      }
    );
    const data = response.attachmentLinkSlack;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkUrl Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkUrlMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkUrl mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkURL
   * @param url - required url to pass to attachmentLinkURL
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkUrlMutation
   * @returns parsed response from AttachmentLinkUrlMutation
   */
  public async fetch(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkUrlMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkUrlMutation, L.AttachmentLinkUrlMutationVariables>(
      L.AttachmentLinkUrlDocument,
      {
        issueId,
        url,
        ...variables,
      }
    );
    const data = response.attachmentLinkURL;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentLinkZendesk Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentLinkZendeskMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentLinkZendesk mutation and return a AttachmentPayload
   *
   * @param issueId - required issueId to pass to attachmentLinkZendesk
   * @param ticketId - required ticketId to pass to attachmentLinkZendesk
   * @param variables - variables without 'issueId', 'ticketId' to pass into the AttachmentLinkZendeskMutation
   * @returns parsed response from AttachmentLinkZendeskMutation
   */
  public async fetch(
    issueId: string,
    ticketId: string,
    variables?: Omit<L.AttachmentLinkZendeskMutationVariables, "issueId" | "ticketId">
  ): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentLinkZendeskMutation, L.AttachmentLinkZendeskMutationVariables>(
      L.AttachmentLinkZendeskDocument,
      {
        issueId,
        ticketId,
        ...variables,
      }
    );
    const data = response.attachmentLinkZendesk;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable AttachmentSyncToSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export class AttachmentSyncToSlackMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the AttachmentSyncToSlack mutation and return a AttachmentPayload
   *
   * @param id - required id to pass to attachmentSyncToSlack
   * @returns parsed response from AttachmentSyncToSlackMutation
   */
  public async fetch(id: string): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.AttachmentSyncToSlackMutation, L.AttachmentSyncToSlackMutationVariables>(
      L.AttachmentSyncToSlackDocument,
      {
        id,
      }
    );
    const data = response.attachmentSyncToSlack;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateAttachmentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateAttachment mutation and return a AttachmentPayload
   *
   * @param id - required id to pass to updateAttachment
   * @param input - required input to pass to updateAttachment
   * @returns parsed response from UpdateAttachmentMutation
   */
  public async fetch(id: string, input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload> {
    const response = await this._request<L.UpdateAttachmentMutation, L.UpdateAttachmentMutationVariables>(
      L.UpdateAttachmentDocument,
      {
        id,
        input,
      }
    );
    const data = response.attachmentUpdate;

    return new AttachmentPayload(this._request, data);
  }
}

/**
 * A fetchable CreateComment Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCommentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateComment mutation and return a CommentPayload
   *
   * @param input - required input to pass to createComment
   * @returns parsed response from CreateCommentMutation
   */
  public async fetch(input: L.CommentCreateInput): LinearFetch<CommentPayload> {
    const response = await this._request<L.CreateCommentMutation, L.CreateCommentMutationVariables>(
      L.CreateCommentDocument,
      {
        input,
      }
    );
    const data = response.commentCreate;

    return new CommentPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteComment Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteCommentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteComment mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteComment
   * @returns parsed response from DeleteCommentMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteCommentMutation, L.DeleteCommentMutationVariables>(
      L.DeleteCommentDocument,
      {
        id,
      }
    );
    const data = response.commentDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CommentResolve Mutation
 *
 * @param request - function to call the graphql client
 */
export class CommentResolveMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CommentResolve mutation and return a CommentPayload
   *
   * @param id - required id to pass to commentResolve
   * @param variables - variables without 'id' to pass into the CommentResolveMutation
   * @returns parsed response from CommentResolveMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.CommentResolveMutationVariables, "id">
  ): LinearFetch<CommentPayload> {
    const response = await this._request<L.CommentResolveMutation, L.CommentResolveMutationVariables>(
      L.CommentResolveDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.commentResolve;

    return new CommentPayload(this._request, data);
  }
}

/**
 * A fetchable CommentUnresolve Mutation
 *
 * @param request - function to call the graphql client
 */
export class CommentUnresolveMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CommentUnresolve mutation and return a CommentPayload
   *
   * @param id - required id to pass to commentUnresolve
   * @returns parsed response from CommentUnresolveMutation
   */
  public async fetch(id: string): LinearFetch<CommentPayload> {
    const response = await this._request<L.CommentUnresolveMutation, L.CommentUnresolveMutationVariables>(
      L.CommentUnresolveDocument,
      {
        id,
      }
    );
    const data = response.commentUnresolve;

    return new CommentPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateComment Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCommentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateComment mutation and return a CommentPayload
   *
   * @param id - required id to pass to updateComment
   * @param input - required input to pass to updateComment
   * @returns parsed response from UpdateCommentMutation
   */
  public async fetch(id: string, input: L.CommentUpdateInput): LinearFetch<CommentPayload> {
    const response = await this._request<L.UpdateCommentMutation, L.UpdateCommentMutationVariables>(
      L.UpdateCommentDocument,
      {
        id,
        input,
      }
    );
    const data = response.commentUpdate;

    return new CommentPayload(this._request, data);
  }
}

/**
 * A fetchable CreateContact Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateContactMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateContact mutation and return a ContactPayload
   *
   * @param input - required input to pass to createContact
   * @returns parsed response from CreateContactMutation
   */
  public async fetch(input: L.ContactCreateInput): LinearFetch<ContactPayload> {
    const response = await this._request<L.CreateContactMutation, L.CreateContactMutationVariables>(
      L.CreateContactDocument,
      {
        input,
      }
    );
    const data = response.contactCreate;

    return new ContactPayload(this._request, data);
  }
}

/**
 * A fetchable CreateCsvExportReport Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCsvExportReportMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCsvExportReport mutation and return a CreateCsvExportReportPayload
   *
   * @param variables - variables to pass into the CreateCsvExportReportMutation
   * @returns parsed response from CreateCsvExportReportMutation
   */
  public async fetch(variables?: L.CreateCsvExportReportMutationVariables): LinearFetch<CreateCsvExportReportPayload> {
    const response = await this._request<L.CreateCsvExportReportMutation, L.CreateCsvExportReportMutationVariables>(
      L.CreateCsvExportReportDocument,
      variables
    );
    const data = response.createCsvExportReport;

    return new CreateCsvExportReportPayload(this._request, data);
  }
}

/**
 * A fetchable CreateInitiativeUpdateReminder Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateInitiativeUpdateReminderMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateInitiativeUpdateReminder mutation and return a InitiativeUpdateReminderPayload
   *
   * @param initiativeId - required initiativeId to pass to createInitiativeUpdateReminder
   * @param variables - variables without 'initiativeId' to pass into the CreateInitiativeUpdateReminderMutation
   * @returns parsed response from CreateInitiativeUpdateReminderMutation
   */
  public async fetch(
    initiativeId: string,
    variables?: Omit<L.CreateInitiativeUpdateReminderMutationVariables, "initiativeId">
  ): LinearFetch<InitiativeUpdateReminderPayload> {
    const response = await this._request<
      L.CreateInitiativeUpdateReminderMutation,
      L.CreateInitiativeUpdateReminderMutationVariables
    >(L.CreateInitiativeUpdateReminderDocument, {
      initiativeId,
      ...variables,
    });
    const data = response.createInitiativeUpdateReminder;

    return new InitiativeUpdateReminderPayload(this._request, data);
  }
}

/**
 * A fetchable CreateOrganizationFromOnboarding Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateOrganizationFromOnboardingMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateOrganizationFromOnboarding mutation and return a CreateOrJoinOrganizationResponse
   *
   * @param input - required input to pass to createOrganizationFromOnboarding
   * @param variables - variables without 'input' to pass into the CreateOrganizationFromOnboardingMutation
   * @returns parsed response from CreateOrganizationFromOnboardingMutation
   */
  public async fetch(
    input: L.CreateOrganizationInput,
    variables?: Omit<L.CreateOrganizationFromOnboardingMutationVariables, "input">
  ): LinearFetch<CreateOrJoinOrganizationResponse> {
    const response = await this._request<
      L.CreateOrganizationFromOnboardingMutation,
      L.CreateOrganizationFromOnboardingMutationVariables
    >(L.CreateOrganizationFromOnboardingDocument, {
      input,
      ...variables,
    });
    const data = response.createOrganizationFromOnboarding;

    return new CreateOrJoinOrganizationResponse(this._request, data);
  }
}

/**
 * A fetchable CreateProjectUpdateReminder Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectUpdateReminderMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProjectUpdateReminder mutation and return a ProjectUpdateReminderPayload
   *
   * @param projectId - required projectId to pass to createProjectUpdateReminder
   * @param variables - variables without 'projectId' to pass into the CreateProjectUpdateReminderMutation
   * @returns parsed response from CreateProjectUpdateReminderMutation
   */
  public async fetch(
    projectId: string,
    variables?: Omit<L.CreateProjectUpdateReminderMutationVariables, "projectId">
  ): LinearFetch<ProjectUpdateReminderPayload> {
    const response = await this._request<
      L.CreateProjectUpdateReminderMutation,
      L.CreateProjectUpdateReminderMutationVariables
    >(L.CreateProjectUpdateReminderDocument, {
      projectId,
      ...variables,
    });
    const data = response.createProjectUpdateReminder;

    return new ProjectUpdateReminderPayload(this._request, data);
  }
}

/**
 * A fetchable CreateCustomView Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCustomViewMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCustomView mutation and return a CustomViewPayload
   *
   * @param input - required input to pass to createCustomView
   * @returns parsed response from CreateCustomViewMutation
   */
  public async fetch(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload> {
    const response = await this._request<L.CreateCustomViewMutation, L.CreateCustomViewMutationVariables>(
      L.CreateCustomViewDocument,
      {
        input,
      }
    );
    const data = response.customViewCreate;

    return new CustomViewPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteCustomView Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteCustomViewMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteCustomView mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteCustomView
   * @returns parsed response from DeleteCustomViewMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteCustomViewMutation, L.DeleteCustomViewMutationVariables>(
      L.DeleteCustomViewDocument,
      {
        id,
      }
    );
    const data = response.customViewDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateCustomView Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCustomViewMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateCustomView mutation and return a CustomViewPayload
   *
   * @param id - required id to pass to updateCustomView
   * @param input - required input to pass to updateCustomView
   * @returns parsed response from UpdateCustomViewMutation
   */
  public async fetch(id: string, input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload> {
    const response = await this._request<L.UpdateCustomViewMutation, L.UpdateCustomViewMutationVariables>(
      L.UpdateCustomViewDocument,
      {
        id,
        input,
      }
    );
    const data = response.customViewUpdate;

    return new CustomViewPayload(this._request, data);
  }
}

/**
 * A fetchable CreateCustomer Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCustomerMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCustomer mutation and return a CustomerPayload
   *
   * @param input - required input to pass to createCustomer
   * @returns parsed response from CreateCustomerMutation
   */
  public async fetch(input: L.CustomerCreateInput): LinearFetch<CustomerPayload> {
    const response = await this._request<L.CreateCustomerMutation, L.CreateCustomerMutationVariables>(
      L.CreateCustomerDocument,
      {
        input,
      }
    );
    const data = response.customerCreate;

    return new CustomerPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteCustomer Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteCustomerMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteCustomer mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteCustomer
   * @returns parsed response from DeleteCustomerMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteCustomerMutation, L.DeleteCustomerMutationVariables>(
      L.DeleteCustomerDocument,
      {
        id,
      }
    );
    const data = response.customerDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CustomerMerge Mutation
 *
 * @param request - function to call the graphql client
 */
export class CustomerMergeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerMerge mutation and return a CustomerPayload
   *
   * @param sourceCustomerId - required sourceCustomerId to pass to customerMerge
   * @param targetCustomerId - required targetCustomerId to pass to customerMerge
   * @returns parsed response from CustomerMergeMutation
   */
  public async fetch(sourceCustomerId: string, targetCustomerId: string): LinearFetch<CustomerPayload> {
    const response = await this._request<L.CustomerMergeMutation, L.CustomerMergeMutationVariables>(
      L.CustomerMergeDocument,
      {
        sourceCustomerId,
        targetCustomerId,
      }
    );
    const data = response.customerMerge;

    return new CustomerPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveCustomerNeed Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveCustomerNeedMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveCustomerNeed mutation and return a CustomerNeedArchivePayload
   *
   * @param id - required id to pass to archiveCustomerNeed
   * @returns parsed response from ArchiveCustomerNeedMutation
   */
  public async fetch(id: string): LinearFetch<CustomerNeedArchivePayload> {
    const response = await this._request<L.ArchiveCustomerNeedMutation, L.ArchiveCustomerNeedMutationVariables>(
      L.ArchiveCustomerNeedDocument,
      {
        id,
      }
    );
    const data = response.customerNeedArchive;

    return new CustomerNeedArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateCustomerNeed Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCustomerNeedMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCustomerNeed mutation and return a CustomerNeedPayload
   *
   * @param input - required input to pass to createCustomerNeed
   * @returns parsed response from CreateCustomerNeedMutation
   */
  public async fetch(input: L.CustomerNeedCreateInput): LinearFetch<CustomerNeedPayload> {
    const response = await this._request<L.CreateCustomerNeedMutation, L.CreateCustomerNeedMutationVariables>(
      L.CreateCustomerNeedDocument,
      {
        input,
      }
    );
    const data = response.customerNeedCreate;

    return new CustomerNeedPayload(this._request, data);
  }
}

/**
 * A fetchable CustomerNeedCreateFromAttachment Mutation
 *
 * @param request - function to call the graphql client
 */
export class CustomerNeedCreateFromAttachmentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerNeedCreateFromAttachment mutation and return a CustomerNeedPayload
   *
   * @param input - required input to pass to customerNeedCreateFromAttachment
   * @returns parsed response from CustomerNeedCreateFromAttachmentMutation
   */
  public async fetch(input: L.CustomerNeedCreateFromAttachmentInput): LinearFetch<CustomerNeedPayload> {
    const response = await this._request<
      L.CustomerNeedCreateFromAttachmentMutation,
      L.CustomerNeedCreateFromAttachmentMutationVariables
    >(L.CustomerNeedCreateFromAttachmentDocument, {
      input,
    });
    const data = response.customerNeedCreateFromAttachment;

    return new CustomerNeedPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteCustomerNeed Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteCustomerNeedMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteCustomerNeed mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteCustomerNeed
   * @param variables - variables without 'id' to pass into the DeleteCustomerNeedMutation
   * @returns parsed response from DeleteCustomerNeedMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.DeleteCustomerNeedMutationVariables, "id">
  ): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteCustomerNeedMutation, L.DeleteCustomerNeedMutationVariables>(
      L.DeleteCustomerNeedDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.customerNeedDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveCustomerNeed Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveCustomerNeedMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveCustomerNeed mutation and return a CustomerNeedArchivePayload
   *
   * @param id - required id to pass to unarchiveCustomerNeed
   * @returns parsed response from UnarchiveCustomerNeedMutation
   */
  public async fetch(id: string): LinearFetch<CustomerNeedArchivePayload> {
    const response = await this._request<L.UnarchiveCustomerNeedMutation, L.UnarchiveCustomerNeedMutationVariables>(
      L.UnarchiveCustomerNeedDocument,
      {
        id,
      }
    );
    const data = response.customerNeedUnarchive;

    return new CustomerNeedArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateCustomerNeed Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCustomerNeedMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateCustomerNeed mutation and return a CustomerNeedUpdatePayload
   *
   * @param id - required id to pass to updateCustomerNeed
   * @param input - required input to pass to updateCustomerNeed
   * @returns parsed response from UpdateCustomerNeedMutation
   */
  public async fetch(id: string, input: L.CustomerNeedUpdateInput): LinearFetch<CustomerNeedUpdatePayload> {
    const response = await this._request<L.UpdateCustomerNeedMutation, L.UpdateCustomerNeedMutationVariables>(
      L.UpdateCustomerNeedDocument,
      {
        id,
        input,
      }
    );
    const data = response.customerNeedUpdate;

    return new CustomerNeedUpdatePayload(this._request, data);
  }
}

/**
 * A fetchable CreateCustomerStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCustomerStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCustomerStatus mutation and return a CustomerStatusPayload
   *
   * @param input - required input to pass to createCustomerStatus
   * @returns parsed response from CreateCustomerStatusMutation
   */
  public async fetch(input: L.CustomerStatusCreateInput): LinearFetch<CustomerStatusPayload> {
    const response = await this._request<L.CreateCustomerStatusMutation, L.CreateCustomerStatusMutationVariables>(
      L.CreateCustomerStatusDocument,
      {
        input,
      }
    );
    const data = response.customerStatusCreate;

    return new CustomerStatusPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteCustomerStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteCustomerStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteCustomerStatus mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteCustomerStatus
   * @returns parsed response from DeleteCustomerStatusMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteCustomerStatusMutation, L.DeleteCustomerStatusMutationVariables>(
      L.DeleteCustomerStatusDocument,
      {
        id,
      }
    );
    const data = response.customerStatusDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateCustomerStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCustomerStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateCustomerStatus mutation and return a CustomerStatusPayload
   *
   * @param id - required id to pass to updateCustomerStatus
   * @param input - required input to pass to updateCustomerStatus
   * @returns parsed response from UpdateCustomerStatusMutation
   */
  public async fetch(id: string, input: L.CustomerStatusUpdateInput): LinearFetch<CustomerStatusPayload> {
    const response = await this._request<L.UpdateCustomerStatusMutation, L.UpdateCustomerStatusMutationVariables>(
      L.UpdateCustomerStatusDocument,
      {
        id,
        input,
      }
    );
    const data = response.customerStatusUpdate;

    return new CustomerStatusPayload(this._request, data);
  }
}

/**
 * A fetchable CreateCustomerTier Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCustomerTierMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCustomerTier mutation and return a CustomerTierPayload
   *
   * @param input - required input to pass to createCustomerTier
   * @returns parsed response from CreateCustomerTierMutation
   */
  public async fetch(input: L.CustomerTierCreateInput): LinearFetch<CustomerTierPayload> {
    const response = await this._request<L.CreateCustomerTierMutation, L.CreateCustomerTierMutationVariables>(
      L.CreateCustomerTierDocument,
      {
        input,
      }
    );
    const data = response.customerTierCreate;

    return new CustomerTierPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteCustomerTier Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteCustomerTierMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteCustomerTier mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteCustomerTier
   * @returns parsed response from DeleteCustomerTierMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteCustomerTierMutation, L.DeleteCustomerTierMutationVariables>(
      L.DeleteCustomerTierDocument,
      {
        id,
      }
    );
    const data = response.customerTierDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateCustomerTier Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCustomerTierMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateCustomerTier mutation and return a CustomerTierPayload
   *
   * @param id - required id to pass to updateCustomerTier
   * @param input - required input to pass to updateCustomerTier
   * @returns parsed response from UpdateCustomerTierMutation
   */
  public async fetch(id: string, input: L.CustomerTierUpdateInput): LinearFetch<CustomerTierPayload> {
    const response = await this._request<L.UpdateCustomerTierMutation, L.UpdateCustomerTierMutationVariables>(
      L.UpdateCustomerTierDocument,
      {
        id,
        input,
      }
    );
    const data = response.customerTierUpdate;

    return new CustomerTierPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateCustomer Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCustomerMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateCustomer mutation and return a CustomerPayload
   *
   * @param id - required id to pass to updateCustomer
   * @param input - required input to pass to updateCustomer
   * @returns parsed response from UpdateCustomerMutation
   */
  public async fetch(id: string, input: L.CustomerUpdateInput): LinearFetch<CustomerPayload> {
    const response = await this._request<L.UpdateCustomerMutation, L.UpdateCustomerMutationVariables>(
      L.UpdateCustomerDocument,
      {
        id,
        input,
      }
    );
    const data = response.customerUpdate;

    return new CustomerPayload(this._request, data);
  }
}

/**
 * A fetchable CustomerUpsert Mutation
 *
 * @param request - function to call the graphql client
 */
export class CustomerUpsertMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CustomerUpsert mutation and return a CustomerPayload
   *
   * @param input - required input to pass to customerUpsert
   * @returns parsed response from CustomerUpsertMutation
   */
  public async fetch(input: L.CustomerUpsertInput): LinearFetch<CustomerPayload> {
    const response = await this._request<L.CustomerUpsertMutation, L.CustomerUpsertMutationVariables>(
      L.CustomerUpsertDocument,
      {
        input,
      }
    );
    const data = response.customerUpsert;

    return new CustomerPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveCycle Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveCycleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveCycle mutation and return a CycleArchivePayload
   *
   * @param id - required id to pass to archiveCycle
   * @returns parsed response from ArchiveCycleMutation
   */
  public async fetch(id: string): LinearFetch<CycleArchivePayload> {
    const response = await this._request<L.ArchiveCycleMutation, L.ArchiveCycleMutationVariables>(
      L.ArchiveCycleDocument,
      {
        id,
      }
    );
    const data = response.cycleArchive;

    return new CycleArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateCycle Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateCycleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateCycle mutation and return a CyclePayload
   *
   * @param input - required input to pass to createCycle
   * @returns parsed response from CreateCycleMutation
   */
  public async fetch(input: L.CycleCreateInput): LinearFetch<CyclePayload> {
    const response = await this._request<L.CreateCycleMutation, L.CreateCycleMutationVariables>(L.CreateCycleDocument, {
      input,
    });
    const data = response.cycleCreate;

    return new CyclePayload(this._request, data);
  }
}

/**
 * A fetchable CycleShiftAll Mutation
 *
 * @param request - function to call the graphql client
 */
export class CycleShiftAllMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CycleShiftAll mutation and return a CyclePayload
   *
   * @param input - required input to pass to cycleShiftAll
   * @returns parsed response from CycleShiftAllMutation
   */
  public async fetch(input: L.CycleShiftAllInput): LinearFetch<CyclePayload> {
    const response = await this._request<L.CycleShiftAllMutation, L.CycleShiftAllMutationVariables>(
      L.CycleShiftAllDocument,
      {
        input,
      }
    );
    const data = response.cycleShiftAll;

    return new CyclePayload(this._request, data);
  }
}

/**
 * A fetchable CycleStartUpcomingCycleToday Mutation
 *
 * @param request - function to call the graphql client
 */
export class CycleStartUpcomingCycleTodayMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CycleStartUpcomingCycleToday mutation and return a CyclePayload
   *
   * @param id - required id to pass to cycleStartUpcomingCycleToday
   * @returns parsed response from CycleStartUpcomingCycleTodayMutation
   */
  public async fetch(id: string): LinearFetch<CyclePayload> {
    const response = await this._request<
      L.CycleStartUpcomingCycleTodayMutation,
      L.CycleStartUpcomingCycleTodayMutationVariables
    >(L.CycleStartUpcomingCycleTodayDocument, {
      id,
    });
    const data = response.cycleStartUpcomingCycleToday;

    return new CyclePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateCycle Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateCycleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateCycle mutation and return a CyclePayload
   *
   * @param id - required id to pass to updateCycle
   * @param input - required input to pass to updateCycle
   * @returns parsed response from UpdateCycleMutation
   */
  public async fetch(id: string, input: L.CycleUpdateInput): LinearFetch<CyclePayload> {
    const response = await this._request<L.UpdateCycleMutation, L.UpdateCycleMutationVariables>(L.UpdateCycleDocument, {
      id,
      input,
    });
    const data = response.cycleUpdate;

    return new CyclePayload(this._request, data);
  }
}

/**
 * A fetchable CreateDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateDocumentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateDocument mutation and return a DocumentPayload
   *
   * @param input - required input to pass to createDocument
   * @returns parsed response from CreateDocumentMutation
   */
  public async fetch(input: L.DocumentCreateInput): LinearFetch<DocumentPayload> {
    const response = await this._request<L.CreateDocumentMutation, L.CreateDocumentMutationVariables>(
      L.CreateDocumentDocument,
      {
        input,
      }
    );
    const data = response.documentCreate;

    return new DocumentPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteDocumentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteDocument mutation and return a DocumentArchivePayload
   *
   * @param id - required id to pass to deleteDocument
   * @returns parsed response from DeleteDocumentMutation
   */
  public async fetch(id: string): LinearFetch<DocumentArchivePayload> {
    const response = await this._request<L.DeleteDocumentMutation, L.DeleteDocumentMutationVariables>(
      L.DeleteDocumentDocument,
      {
        id,
      }
    );
    const data = response.documentDelete;

    return new DocumentArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveDocumentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveDocument mutation and return a DocumentArchivePayload
   *
   * @param id - required id to pass to unarchiveDocument
   * @returns parsed response from UnarchiveDocumentMutation
   */
  public async fetch(id: string): LinearFetch<DocumentArchivePayload> {
    const response = await this._request<L.UnarchiveDocumentMutation, L.UnarchiveDocumentMutationVariables>(
      L.UnarchiveDocumentDocument,
      {
        id,
      }
    );
    const data = response.documentUnarchive;

    return new DocumentArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateDocument Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateDocumentMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateDocument mutation and return a DocumentPayload
   *
   * @param id - required id to pass to updateDocument
   * @param input - required input to pass to updateDocument
   * @returns parsed response from UpdateDocumentMutation
   */
  public async fetch(id: string, input: L.DocumentUpdateInput): LinearFetch<DocumentPayload> {
    const response = await this._request<L.UpdateDocumentMutation, L.UpdateDocumentMutationVariables>(
      L.UpdateDocumentDocument,
      {
        id,
        input,
      }
    );
    const data = response.documentUpdate;

    return new DocumentPayload(this._request, data);
  }
}

/**
 * A fetchable CreateEmailIntakeAddress Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateEmailIntakeAddressMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateEmailIntakeAddress mutation and return a EmailIntakeAddressPayload
   *
   * @param input - required input to pass to createEmailIntakeAddress
   * @returns parsed response from CreateEmailIntakeAddressMutation
   */
  public async fetch(input: L.EmailIntakeAddressCreateInput): LinearFetch<EmailIntakeAddressPayload> {
    const response = await this._request<
      L.CreateEmailIntakeAddressMutation,
      L.CreateEmailIntakeAddressMutationVariables
    >(L.CreateEmailIntakeAddressDocument, {
      input,
    });
    const data = response.emailIntakeAddressCreate;

    return new EmailIntakeAddressPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteEmailIntakeAddress Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteEmailIntakeAddressMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteEmailIntakeAddress mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteEmailIntakeAddress
   * @returns parsed response from DeleteEmailIntakeAddressMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteEmailIntakeAddressMutation,
      L.DeleteEmailIntakeAddressMutationVariables
    >(L.DeleteEmailIntakeAddressDocument, {
      id,
    });
    const data = response.emailIntakeAddressDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable EmailIntakeAddressRotate Mutation
 *
 * @param request - function to call the graphql client
 */
export class EmailIntakeAddressRotateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the EmailIntakeAddressRotate mutation and return a EmailIntakeAddressPayload
   *
   * @param id - required id to pass to emailIntakeAddressRotate
   * @returns parsed response from EmailIntakeAddressRotateMutation
   */
  public async fetch(id: string): LinearFetch<EmailIntakeAddressPayload> {
    const response = await this._request<
      L.EmailIntakeAddressRotateMutation,
      L.EmailIntakeAddressRotateMutationVariables
    >(L.EmailIntakeAddressRotateDocument, {
      id,
    });
    const data = response.emailIntakeAddressRotate;

    return new EmailIntakeAddressPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateEmailIntakeAddress Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateEmailIntakeAddressMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateEmailIntakeAddress mutation and return a EmailIntakeAddressPayload
   *
   * @param id - required id to pass to updateEmailIntakeAddress
   * @param input - required input to pass to updateEmailIntakeAddress
   * @returns parsed response from UpdateEmailIntakeAddressMutation
   */
  public async fetch(id: string, input: L.EmailIntakeAddressUpdateInput): LinearFetch<EmailIntakeAddressPayload> {
    const response = await this._request<
      L.UpdateEmailIntakeAddressMutation,
      L.UpdateEmailIntakeAddressMutationVariables
    >(L.UpdateEmailIntakeAddressDocument, {
      id,
      input,
    });
    const data = response.emailIntakeAddressUpdate;

    return new EmailIntakeAddressPayload(this._request, data);
  }
}

/**
 * A fetchable EmailTokenUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export class EmailTokenUserAccountAuthMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the EmailTokenUserAccountAuth mutation and return a AuthResolverResponse
   *
   * @param input - required input to pass to emailTokenUserAccountAuth
   * @returns parsed response from EmailTokenUserAccountAuthMutation
   */
  public async fetch(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse> {
    const response = await this._request<
      L.EmailTokenUserAccountAuthMutation,
      L.EmailTokenUserAccountAuthMutationVariables
    >(L.EmailTokenUserAccountAuthDocument, {
      input,
    });
    const data = response.emailTokenUserAccountAuth;

    return new AuthResolverResponse(this._request, data);
  }
}

/**
 * A fetchable EmailUnsubscribe Mutation
 *
 * @param request - function to call the graphql client
 */
export class EmailUnsubscribeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the EmailUnsubscribe mutation and return a EmailUnsubscribePayload
   *
   * @param input - required input to pass to emailUnsubscribe
   * @returns parsed response from EmailUnsubscribeMutation
   */
  public async fetch(input: L.EmailUnsubscribeInput): LinearFetch<EmailUnsubscribePayload> {
    const response = await this._request<L.EmailUnsubscribeMutation, L.EmailUnsubscribeMutationVariables>(
      L.EmailUnsubscribeDocument,
      {
        input,
      }
    );
    const data = response.emailUnsubscribe;

    return new EmailUnsubscribePayload(this._request, data);
  }
}

/**
 * A fetchable EmailUserAccountAuthChallenge Mutation
 *
 * @param request - function to call the graphql client
 */
export class EmailUserAccountAuthChallengeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the EmailUserAccountAuthChallenge mutation and return a EmailUserAccountAuthChallengeResponse
   *
   * @param input - required input to pass to emailUserAccountAuthChallenge
   * @returns parsed response from EmailUserAccountAuthChallengeMutation
   */
  public async fetch(input: L.EmailUserAccountAuthChallengeInput): LinearFetch<EmailUserAccountAuthChallengeResponse> {
    const response = await this._request<
      L.EmailUserAccountAuthChallengeMutation,
      L.EmailUserAccountAuthChallengeMutationVariables
    >(L.EmailUserAccountAuthChallengeDocument, {
      input,
    });
    const data = response.emailUserAccountAuthChallenge;

    return new EmailUserAccountAuthChallengeResponse(this._request, data);
  }
}

/**
 * A fetchable CreateEmoji Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateEmojiMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateEmoji mutation and return a EmojiPayload
   *
   * @param input - required input to pass to createEmoji
   * @returns parsed response from CreateEmojiMutation
   */
  public async fetch(input: L.EmojiCreateInput): LinearFetch<EmojiPayload> {
    const response = await this._request<L.CreateEmojiMutation, L.CreateEmojiMutationVariables>(L.CreateEmojiDocument, {
      input,
    });
    const data = response.emojiCreate;

    return new EmojiPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteEmoji Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteEmojiMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteEmoji mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteEmoji
   * @returns parsed response from DeleteEmojiMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteEmojiMutation, L.DeleteEmojiMutationVariables>(L.DeleteEmojiDocument, {
      id,
    });
    const data = response.emojiDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CreateEntityExternalLink Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateEntityExternalLinkMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateEntityExternalLink mutation and return a EntityExternalLinkPayload
   *
   * @param input - required input to pass to createEntityExternalLink
   * @returns parsed response from CreateEntityExternalLinkMutation
   */
  public async fetch(input: L.EntityExternalLinkCreateInput): LinearFetch<EntityExternalLinkPayload> {
    const response = await this._request<
      L.CreateEntityExternalLinkMutation,
      L.CreateEntityExternalLinkMutationVariables
    >(L.CreateEntityExternalLinkDocument, {
      input,
    });
    const data = response.entityExternalLinkCreate;

    return new EntityExternalLinkPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteEntityExternalLink Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteEntityExternalLinkMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteEntityExternalLink mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteEntityExternalLink
   * @returns parsed response from DeleteEntityExternalLinkMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteEntityExternalLinkMutation,
      L.DeleteEntityExternalLinkMutationVariables
    >(L.DeleteEntityExternalLinkDocument, {
      id,
    });
    const data = response.entityExternalLinkDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateEntityExternalLink Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateEntityExternalLinkMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateEntityExternalLink mutation and return a EntityExternalLinkPayload
   *
   * @param id - required id to pass to updateEntityExternalLink
   * @param input - required input to pass to updateEntityExternalLink
   * @returns parsed response from UpdateEntityExternalLinkMutation
   */
  public async fetch(id: string, input: L.EntityExternalLinkUpdateInput): LinearFetch<EntityExternalLinkPayload> {
    const response = await this._request<
      L.UpdateEntityExternalLinkMutation,
      L.UpdateEntityExternalLinkMutationVariables
    >(L.UpdateEntityExternalLinkDocument, {
      id,
      input,
    });
    const data = response.entityExternalLinkUpdate;

    return new EntityExternalLinkPayload(this._request, data);
  }
}

/**
 * A fetchable CreateFavorite Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateFavoriteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateFavorite mutation and return a FavoritePayload
   *
   * @param input - required input to pass to createFavorite
   * @returns parsed response from CreateFavoriteMutation
   */
  public async fetch(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload> {
    const response = await this._request<L.CreateFavoriteMutation, L.CreateFavoriteMutationVariables>(
      L.CreateFavoriteDocument,
      {
        input,
      }
    );
    const data = response.favoriteCreate;

    return new FavoritePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteFavorite Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteFavoriteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteFavorite mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteFavorite
   * @returns parsed response from DeleteFavoriteMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteFavoriteMutation, L.DeleteFavoriteMutationVariables>(
      L.DeleteFavoriteDocument,
      {
        id,
      }
    );
    const data = response.favoriteDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateFavorite Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateFavoriteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateFavorite mutation and return a FavoritePayload
   *
   * @param id - required id to pass to updateFavorite
   * @param input - required input to pass to updateFavorite
   * @returns parsed response from UpdateFavoriteMutation
   */
  public async fetch(id: string, input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload> {
    const response = await this._request<L.UpdateFavoriteMutation, L.UpdateFavoriteMutationVariables>(
      L.UpdateFavoriteDocument,
      {
        id,
        input,
      }
    );
    const data = response.favoriteUpdate;

    return new FavoritePayload(this._request, data);
  }
}

/**
 * A fetchable FileUpload Mutation
 *
 * @param request - function to call the graphql client
 */
export class FileUploadMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the FileUpload mutation and return a UploadPayload
   *
   * @param contentType - required contentType to pass to fileUpload
   * @param filename - required filename to pass to fileUpload
   * @param size - required size to pass to fileUpload
   * @param variables - variables without 'contentType', 'filename', 'size' to pass into the FileUploadMutation
   * @returns parsed response from FileUploadMutation
   */
  public async fetch(
    contentType: string,
    filename: string,
    size: number,
    variables?: Omit<L.FileUploadMutationVariables, "contentType" | "filename" | "size">
  ): LinearFetch<UploadPayload> {
    const response = await this._request<L.FileUploadMutation, L.FileUploadMutationVariables>(L.FileUploadDocument, {
      contentType,
      filename,
      size,
      ...variables,
    });
    const data = response.fileUpload;

    return new UploadPayload(this._request, data);
  }
}

/**
 * A fetchable CreateGitAutomationState Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateGitAutomationStateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateGitAutomationState mutation and return a GitAutomationStatePayload
   *
   * @param input - required input to pass to createGitAutomationState
   * @returns parsed response from CreateGitAutomationStateMutation
   */
  public async fetch(input: L.GitAutomationStateCreateInput): LinearFetch<GitAutomationStatePayload> {
    const response = await this._request<
      L.CreateGitAutomationStateMutation,
      L.CreateGitAutomationStateMutationVariables
    >(L.CreateGitAutomationStateDocument, {
      input,
    });
    const data = response.gitAutomationStateCreate;

    return new GitAutomationStatePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteGitAutomationState Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteGitAutomationStateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteGitAutomationState mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteGitAutomationState
   * @returns parsed response from DeleteGitAutomationStateMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteGitAutomationStateMutation,
      L.DeleteGitAutomationStateMutationVariables
    >(L.DeleteGitAutomationStateDocument, {
      id,
    });
    const data = response.gitAutomationStateDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateGitAutomationState Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateGitAutomationStateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateGitAutomationState mutation and return a GitAutomationStatePayload
   *
   * @param id - required id to pass to updateGitAutomationState
   * @param input - required input to pass to updateGitAutomationState
   * @returns parsed response from UpdateGitAutomationStateMutation
   */
  public async fetch(id: string, input: L.GitAutomationStateUpdateInput): LinearFetch<GitAutomationStatePayload> {
    const response = await this._request<
      L.UpdateGitAutomationStateMutation,
      L.UpdateGitAutomationStateMutationVariables
    >(L.UpdateGitAutomationStateDocument, {
      id,
      input,
    });
    const data = response.gitAutomationStateUpdate;

    return new GitAutomationStatePayload(this._request, data);
  }
}

/**
 * A fetchable CreateGitAutomationTargetBranch Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateGitAutomationTargetBranchMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateGitAutomationTargetBranch mutation and return a GitAutomationTargetBranchPayload
   *
   * @param input - required input to pass to createGitAutomationTargetBranch
   * @returns parsed response from CreateGitAutomationTargetBranchMutation
   */
  public async fetch(input: L.GitAutomationTargetBranchCreateInput): LinearFetch<GitAutomationTargetBranchPayload> {
    const response = await this._request<
      L.CreateGitAutomationTargetBranchMutation,
      L.CreateGitAutomationTargetBranchMutationVariables
    >(L.CreateGitAutomationTargetBranchDocument, {
      input,
    });
    const data = response.gitAutomationTargetBranchCreate;

    return new GitAutomationTargetBranchPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteGitAutomationTargetBranch Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteGitAutomationTargetBranchMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteGitAutomationTargetBranch mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteGitAutomationTargetBranch
   * @returns parsed response from DeleteGitAutomationTargetBranchMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteGitAutomationTargetBranchMutation,
      L.DeleteGitAutomationTargetBranchMutationVariables
    >(L.DeleteGitAutomationTargetBranchDocument, {
      id,
    });
    const data = response.gitAutomationTargetBranchDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateGitAutomationTargetBranch Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateGitAutomationTargetBranchMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateGitAutomationTargetBranch mutation and return a GitAutomationTargetBranchPayload
   *
   * @param id - required id to pass to updateGitAutomationTargetBranch
   * @param input - required input to pass to updateGitAutomationTargetBranch
   * @returns parsed response from UpdateGitAutomationTargetBranchMutation
   */
  public async fetch(
    id: string,
    input: L.GitAutomationTargetBranchUpdateInput
  ): LinearFetch<GitAutomationTargetBranchPayload> {
    const response = await this._request<
      L.UpdateGitAutomationTargetBranchMutation,
      L.UpdateGitAutomationTargetBranchMutationVariables
    >(L.UpdateGitAutomationTargetBranchDocument, {
      id,
      input,
    });
    const data = response.gitAutomationTargetBranchUpdate;

    return new GitAutomationTargetBranchPayload(this._request, data);
  }
}

/**
 * A fetchable GoogleUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export class GoogleUserAccountAuthMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the GoogleUserAccountAuth mutation and return a AuthResolverResponse
   *
   * @param input - required input to pass to googleUserAccountAuth
   * @returns parsed response from GoogleUserAccountAuthMutation
   */
  public async fetch(input: L.GoogleUserAccountAuthInput): LinearFetch<AuthResolverResponse> {
    const response = await this._request<L.GoogleUserAccountAuthMutation, L.GoogleUserAccountAuthMutationVariables>(
      L.GoogleUserAccountAuthDocument,
      {
        input,
      }
    );
    const data = response.googleUserAccountAuth;

    return new AuthResolverResponse(this._request, data);
  }
}

/**
 * A fetchable ImageUploadFromUrl Mutation
 *
 * @param request - function to call the graphql client
 */
export class ImageUploadFromUrlMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ImageUploadFromUrl mutation and return a ImageUploadFromUrlPayload
   *
   * @param url - required url to pass to imageUploadFromUrl
   * @returns parsed response from ImageUploadFromUrlMutation
   */
  public async fetch(url: string): LinearFetch<ImageUploadFromUrlPayload> {
    const response = await this._request<L.ImageUploadFromUrlMutation, L.ImageUploadFromUrlMutationVariables>(
      L.ImageUploadFromUrlDocument,
      {
        url,
      }
    );
    const data = response.imageUploadFromUrl;

    return new ImageUploadFromUrlPayload(this._request, data);
  }
}

/**
 * A fetchable ImportFileUpload Mutation
 *
 * @param request - function to call the graphql client
 */
export class ImportFileUploadMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ImportFileUpload mutation and return a UploadPayload
   *
   * @param contentType - required contentType to pass to importFileUpload
   * @param filename - required filename to pass to importFileUpload
   * @param size - required size to pass to importFileUpload
   * @param variables - variables without 'contentType', 'filename', 'size' to pass into the ImportFileUploadMutation
   * @returns parsed response from ImportFileUploadMutation
   */
  public async fetch(
    contentType: string,
    filename: string,
    size: number,
    variables?: Omit<L.ImportFileUploadMutationVariables, "contentType" | "filename" | "size">
  ): LinearFetch<UploadPayload> {
    const response = await this._request<L.ImportFileUploadMutation, L.ImportFileUploadMutationVariables>(
      L.ImportFileUploadDocument,
      {
        contentType,
        filename,
        size,
        ...variables,
      }
    );
    const data = response.importFileUpload;

    return new UploadPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveInitiative Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveInitiativeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveInitiative mutation and return a InitiativeArchivePayload
   *
   * @param id - required id to pass to archiveInitiative
   * @returns parsed response from ArchiveInitiativeMutation
   */
  public async fetch(id: string): LinearFetch<InitiativeArchivePayload> {
    const response = await this._request<L.ArchiveInitiativeMutation, L.ArchiveInitiativeMutationVariables>(
      L.ArchiveInitiativeDocument,
      {
        id,
      }
    );
    const data = response.initiativeArchive;

    return new InitiativeArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateInitiative Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateInitiativeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateInitiative mutation and return a InitiativePayload
   *
   * @param input - required input to pass to createInitiative
   * @returns parsed response from CreateInitiativeMutation
   */
  public async fetch(input: L.InitiativeCreateInput): LinearFetch<InitiativePayload> {
    const response = await this._request<L.CreateInitiativeMutation, L.CreateInitiativeMutationVariables>(
      L.CreateInitiativeDocument,
      {
        input,
      }
    );
    const data = response.initiativeCreate;

    return new InitiativePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteInitiative Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteInitiativeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteInitiative mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteInitiative
   * @returns parsed response from DeleteInitiativeMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteInitiativeMutation, L.DeleteInitiativeMutationVariables>(
      L.DeleteInitiativeDocument,
      {
        id,
      }
    );
    const data = response.initiativeDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CreateInitiativeRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateInitiativeRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateInitiativeRelation mutation and return a InitiativeRelationPayload
   *
   * @param input - required input to pass to createInitiativeRelation
   * @returns parsed response from CreateInitiativeRelationMutation
   */
  public async fetch(input: L.InitiativeRelationCreateInput): LinearFetch<InitiativeRelationPayload> {
    const response = await this._request<
      L.CreateInitiativeRelationMutation,
      L.CreateInitiativeRelationMutationVariables
    >(L.CreateInitiativeRelationDocument, {
      input,
    });
    const data = response.initiativeRelationCreate;

    return new InitiativeRelationPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteInitiativeRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteInitiativeRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteInitiativeRelation mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteInitiativeRelation
   * @returns parsed response from DeleteInitiativeRelationMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteInitiativeRelationMutation,
      L.DeleteInitiativeRelationMutationVariables
    >(L.DeleteInitiativeRelationDocument, {
      id,
    });
    const data = response.initiativeRelationDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateInitiativeRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateInitiativeRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateInitiativeRelation mutation and return a DeletePayload
   *
   * @param id - required id to pass to updateInitiativeRelation
   * @param input - required input to pass to updateInitiativeRelation
   * @returns parsed response from UpdateInitiativeRelationMutation
   */
  public async fetch(id: string, input: L.InitiativeRelationUpdateInput): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.UpdateInitiativeRelationMutation,
      L.UpdateInitiativeRelationMutationVariables
    >(L.UpdateInitiativeRelationDocument, {
      id,
      input,
    });
    const data = response.initiativeRelationUpdate;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CreateInitiativeToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateInitiativeToProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateInitiativeToProject mutation and return a InitiativeToProjectPayload
   *
   * @param input - required input to pass to createInitiativeToProject
   * @returns parsed response from CreateInitiativeToProjectMutation
   */
  public async fetch(input: L.InitiativeToProjectCreateInput): LinearFetch<InitiativeToProjectPayload> {
    const response = await this._request<
      L.CreateInitiativeToProjectMutation,
      L.CreateInitiativeToProjectMutationVariables
    >(L.CreateInitiativeToProjectDocument, {
      input,
    });
    const data = response.initiativeToProjectCreate;

    return new InitiativeToProjectPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteInitiativeToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteInitiativeToProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteInitiativeToProject mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteInitiativeToProject
   * @returns parsed response from DeleteInitiativeToProjectMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteInitiativeToProjectMutation,
      L.DeleteInitiativeToProjectMutationVariables
    >(L.DeleteInitiativeToProjectDocument, {
      id,
    });
    const data = response.initiativeToProjectDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateInitiativeToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateInitiativeToProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateInitiativeToProject mutation and return a InitiativeToProjectPayload
   *
   * @param id - required id to pass to updateInitiativeToProject
   * @param input - required input to pass to updateInitiativeToProject
   * @returns parsed response from UpdateInitiativeToProjectMutation
   */
  public async fetch(id: string, input: L.InitiativeToProjectUpdateInput): LinearFetch<InitiativeToProjectPayload> {
    const response = await this._request<
      L.UpdateInitiativeToProjectMutation,
      L.UpdateInitiativeToProjectMutationVariables
    >(L.UpdateInitiativeToProjectDocument, {
      id,
      input,
    });
    const data = response.initiativeToProjectUpdate;

    return new InitiativeToProjectPayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveInitiative Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveInitiativeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveInitiative mutation and return a InitiativeArchivePayload
   *
   * @param id - required id to pass to unarchiveInitiative
   * @returns parsed response from UnarchiveInitiativeMutation
   */
  public async fetch(id: string): LinearFetch<InitiativeArchivePayload> {
    const response = await this._request<L.UnarchiveInitiativeMutation, L.UnarchiveInitiativeMutationVariables>(
      L.UnarchiveInitiativeDocument,
      {
        id,
      }
    );
    const data = response.initiativeUnarchive;

    return new InitiativeArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateInitiative Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateInitiativeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateInitiative mutation and return a InitiativePayload
   *
   * @param id - required id to pass to updateInitiative
   * @param input - required input to pass to updateInitiative
   * @returns parsed response from UpdateInitiativeMutation
   */
  public async fetch(id: string, input: L.InitiativeUpdateInput): LinearFetch<InitiativePayload> {
    const response = await this._request<L.UpdateInitiativeMutation, L.UpdateInitiativeMutationVariables>(
      L.UpdateInitiativeDocument,
      {
        id,
        input,
      }
    );
    const data = response.initiativeUpdate;

    return new InitiativePayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveInitiativeUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveInitiativeUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveInitiativeUpdate mutation and return a InitiativeUpdateArchivePayload
   *
   * @param id - required id to pass to archiveInitiativeUpdate
   * @returns parsed response from ArchiveInitiativeUpdateMutation
   */
  public async fetch(id: string): LinearFetch<InitiativeUpdateArchivePayload> {
    const response = await this._request<L.ArchiveInitiativeUpdateMutation, L.ArchiveInitiativeUpdateMutationVariables>(
      L.ArchiveInitiativeUpdateDocument,
      {
        id,
      }
    );
    const data = response.initiativeUpdateArchive;

    return new InitiativeUpdateArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateInitiativeUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateInitiativeUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateInitiativeUpdate mutation and return a InitiativeUpdatePayload
   *
   * @param input - required input to pass to createInitiativeUpdate
   * @returns parsed response from CreateInitiativeUpdateMutation
   */
  public async fetch(input: L.InitiativeUpdateCreateInput): LinearFetch<InitiativeUpdatePayload> {
    const response = await this._request<L.CreateInitiativeUpdateMutation, L.CreateInitiativeUpdateMutationVariables>(
      L.CreateInitiativeUpdateDocument,
      {
        input,
      }
    );
    const data = response.initiativeUpdateCreate;

    return new InitiativeUpdatePayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveInitiativeUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveInitiativeUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveInitiativeUpdate mutation and return a InitiativeUpdateArchivePayload
   *
   * @param id - required id to pass to unarchiveInitiativeUpdate
   * @returns parsed response from UnarchiveInitiativeUpdateMutation
   */
  public async fetch(id: string): LinearFetch<InitiativeUpdateArchivePayload> {
    const response = await this._request<
      L.UnarchiveInitiativeUpdateMutation,
      L.UnarchiveInitiativeUpdateMutationVariables
    >(L.UnarchiveInitiativeUpdateDocument, {
      id,
    });
    const data = response.initiativeUpdateUnarchive;

    return new InitiativeUpdateArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateInitiativeUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateInitiativeUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateInitiativeUpdate mutation and return a InitiativeUpdatePayload
   *
   * @param id - required id to pass to updateInitiativeUpdate
   * @param input - required input to pass to updateInitiativeUpdate
   * @returns parsed response from UpdateInitiativeUpdateMutation
   */
  public async fetch(id: string, input: L.InitiativeUpdateUpdateInput): LinearFetch<InitiativeUpdatePayload> {
    const response = await this._request<L.UpdateInitiativeUpdateMutation, L.UpdateInitiativeUpdateMutationVariables>(
      L.UpdateInitiativeUpdateDocument,
      {
        id,
        input,
      }
    );
    const data = response.initiativeUpdateUpdate;

    return new InitiativeUpdatePayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveIntegration Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveIntegrationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveIntegration mutation and return a DeletePayload
   *
   * @param id - required id to pass to archiveIntegration
   * @returns parsed response from ArchiveIntegrationMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.ArchiveIntegrationMutation, L.ArchiveIntegrationMutationVariables>(
      L.ArchiveIntegrationDocument,
      {
        id,
      }
    );
    const data = response.integrationArchive;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationAsksConnectChannel Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationAsksConnectChannelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationAsksConnectChannel mutation and return a AsksChannelConnectPayload
   *
   * @param code - required code to pass to integrationAsksConnectChannel
   * @param redirectUri - required redirectUri to pass to integrationAsksConnectChannel
   * @returns parsed response from IntegrationAsksConnectChannelMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<AsksChannelConnectPayload> {
    const response = await this._request<
      L.IntegrationAsksConnectChannelMutation,
      L.IntegrationAsksConnectChannelMutationVariables
    >(L.IntegrationAsksConnectChannelDocument, {
      code,
      redirectUri,
    });
    const data = response.integrationAsksConnectChannel;

    return new AsksChannelConnectPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIntegration Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIntegrationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIntegration mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteIntegration
   * @returns parsed response from DeleteIntegrationMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteIntegrationMutation, L.DeleteIntegrationMutationVariables>(
      L.DeleteIntegrationDocument,
      {
        id,
      }
    );
    const data = response.integrationDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationDiscord Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationDiscordMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationDiscord mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationDiscord
   * @param redirectUri - required redirectUri to pass to integrationDiscord
   * @returns parsed response from IntegrationDiscordMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationDiscordMutation, L.IntegrationDiscordMutationVariables>(
      L.IntegrationDiscordDocument,
      {
        code,
        redirectUri,
      }
    );
    const data = response.integrationDiscord;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationFigma Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationFigmaMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationFigma mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationFigma
   * @param redirectUri - required redirectUri to pass to integrationFigma
   * @returns parsed response from IntegrationFigmaMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationFigmaMutation, L.IntegrationFigmaMutationVariables>(
      L.IntegrationFigmaDocument,
      {
        code,
        redirectUri,
      }
    );
    const data = response.integrationFigma;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationFront Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationFrontMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationFront mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationFront
   * @param redirectUri - required redirectUri to pass to integrationFront
   * @returns parsed response from IntegrationFrontMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationFrontMutation, L.IntegrationFrontMutationVariables>(
      L.IntegrationFrontDocument,
      {
        code,
        redirectUri,
      }
    );
    const data = response.integrationFront;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGitHubEnterpriseServerConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGitHubEnterpriseServerConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGitHubEnterpriseServerConnect mutation and return a GitHubEnterpriseServerPayload
   *
   * @param githubUrl - required githubUrl to pass to integrationGitHubEnterpriseServerConnect
   * @param variables - variables without 'githubUrl' to pass into the IntegrationGitHubEnterpriseServerConnectMutation
   * @returns parsed response from IntegrationGitHubEnterpriseServerConnectMutation
   */
  public async fetch(
    githubUrl: string,
    variables?: Omit<L.IntegrationGitHubEnterpriseServerConnectMutationVariables, "githubUrl">
  ): LinearFetch<GitHubEnterpriseServerPayload> {
    const response = await this._request<
      L.IntegrationGitHubEnterpriseServerConnectMutation,
      L.IntegrationGitHubEnterpriseServerConnectMutationVariables
    >(L.IntegrationGitHubEnterpriseServerConnectDocument, {
      githubUrl,
      ...variables,
    });
    const data = response.integrationGitHubEnterpriseServerConnect;

    return new GitHubEnterpriseServerPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGitHubPersonal Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGitHubPersonalMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGitHubPersonal mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationGitHubPersonal
   * @returns parsed response from IntegrationGitHubPersonalMutation
   */
  public async fetch(code: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationGitHubPersonalMutation,
      L.IntegrationGitHubPersonalMutationVariables
    >(L.IntegrationGitHubPersonalDocument, {
      code,
    });
    const data = response.integrationGitHubPersonal;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable CreateIntegrationGithubCommit Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIntegrationGithubCommitMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIntegrationGithubCommit mutation and return a GitHubCommitIntegrationPayload
   *
   * @returns parsed response from CreateIntegrationGithubCommitMutation
   */
  public async fetch(): LinearFetch<GitHubCommitIntegrationPayload> {
    const response = await this._request<
      L.CreateIntegrationGithubCommitMutation,
      L.CreateIntegrationGithubCommitMutationVariables
    >(L.CreateIntegrationGithubCommitDocument, {});
    const data = response.integrationGithubCommitCreate;

    return new GitHubCommitIntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGithubConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGithubConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGithubConnect mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationGithubConnect
   * @param installationId - required installationId to pass to integrationGithubConnect
   * @returns parsed response from IntegrationGithubConnectMutation
   */
  public async fetch(code: string, installationId: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationGithubConnectMutation,
      L.IntegrationGithubConnectMutationVariables
    >(L.IntegrationGithubConnectDocument, {
      code,
      installationId,
    });
    const data = response.integrationGithubConnect;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGithubImportConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGithubImportConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGithubImportConnect mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationGithubImportConnect
   * @param installationId - required installationId to pass to integrationGithubImportConnect
   * @returns parsed response from IntegrationGithubImportConnectMutation
   */
  public async fetch(code: string, installationId: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationGithubImportConnectMutation,
      L.IntegrationGithubImportConnectMutationVariables
    >(L.IntegrationGithubImportConnectDocument, {
      code,
      installationId,
    });
    const data = response.integrationGithubImportConnect;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGithubImportRefresh Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGithubImportRefreshMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGithubImportRefresh mutation and return a IntegrationPayload
   *
   * @param id - required id to pass to integrationGithubImportRefresh
   * @returns parsed response from IntegrationGithubImportRefreshMutation
   */
  public async fetch(id: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationGithubImportRefreshMutation,
      L.IntegrationGithubImportRefreshMutationVariables
    >(L.IntegrationGithubImportRefreshDocument, {
      id,
    });
    const data = response.integrationGithubImportRefresh;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGitlabConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGitlabConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGitlabConnect mutation and return a GitLabIntegrationCreatePayload
   *
   * @param accessToken - required accessToken to pass to integrationGitlabConnect
   * @param gitlabUrl - required gitlabUrl to pass to integrationGitlabConnect
   * @returns parsed response from IntegrationGitlabConnectMutation
   */
  public async fetch(accessToken: string, gitlabUrl: string): LinearFetch<GitLabIntegrationCreatePayload> {
    const response = await this._request<
      L.IntegrationGitlabConnectMutation,
      L.IntegrationGitlabConnectMutationVariables
    >(L.IntegrationGitlabConnectDocument, {
      accessToken,
      gitlabUrl,
    });
    const data = response.integrationGitlabConnect;

    return new GitLabIntegrationCreatePayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationGoogleSheets Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationGoogleSheetsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationGoogleSheets mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationGoogleSheets
   * @returns parsed response from IntegrationGoogleSheetsMutation
   */
  public async fetch(code: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationGoogleSheetsMutation, L.IntegrationGoogleSheetsMutationVariables>(
      L.IntegrationGoogleSheetsDocument,
      {
        code,
      }
    );
    const data = response.integrationGoogleSheets;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationIntercomMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationIntercom mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationIntercom
   * @param redirectUri - required redirectUri to pass to integrationIntercom
   * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationIntercomMutation
   * @returns parsed response from IntegrationIntercomMutation
   */
  public async fetch(
    code: string,
    redirectUri: string,
    variables?: Omit<L.IntegrationIntercomMutationVariables, "code" | "redirectUri">
  ): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationIntercomMutation, L.IntegrationIntercomMutationVariables>(
      L.IntegrationIntercomDocument,
      {
        code,
        redirectUri,
        ...variables,
      }
    );
    const data = response.integrationIntercom;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIntegrationIntercom Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIntegrationIntercomMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIntegrationIntercom mutation and return a IntegrationPayload
   *
   * @returns parsed response from DeleteIntegrationIntercomMutation
   */
  public async fetch(): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.DeleteIntegrationIntercomMutation,
      L.DeleteIntegrationIntercomMutationVariables
    >(L.DeleteIntegrationIntercomDocument, {});
    const data = response.integrationIntercomDelete;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIntegrationIntercomSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIntegrationIntercomSettingsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIntegrationIntercomSettings mutation and return a IntegrationPayload
   *
   * @param input - required input to pass to updateIntegrationIntercomSettings
   * @returns parsed response from UpdateIntegrationIntercomSettingsMutation
   */
  public async fetch(input: L.IntercomSettingsInput): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.UpdateIntegrationIntercomSettingsMutation,
      L.UpdateIntegrationIntercomSettingsMutationVariables
    >(L.UpdateIntegrationIntercomSettingsDocument, {
      input,
    });
    const data = response.integrationIntercomSettingsUpdate;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationJiraPersonal Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationJiraPersonalMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationJiraPersonal mutation and return a IntegrationPayload
   *
   * @param variables - variables to pass into the IntegrationJiraPersonalMutation
   * @returns parsed response from IntegrationJiraPersonalMutation
   */
  public async fetch(variables?: L.IntegrationJiraPersonalMutationVariables): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationJiraPersonalMutation, L.IntegrationJiraPersonalMutationVariables>(
      L.IntegrationJiraPersonalDocument,
      variables
    );
    const data = response.integrationJiraPersonal;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationLoom Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationLoomMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationLoom mutation and return a IntegrationPayload
   *
   * @returns parsed response from IntegrationLoomMutation
   */
  public async fetch(): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationLoomMutation, L.IntegrationLoomMutationVariables>(
      L.IntegrationLoomDocument,
      {}
    );
    const data = response.integrationLoom;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationRequest Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationRequestMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationRequest mutation and return a IntegrationRequestPayload
   *
   * @param input - required input to pass to integrationRequest
   * @returns parsed response from IntegrationRequestMutation
   */
  public async fetch(input: L.IntegrationRequestInput): LinearFetch<IntegrationRequestPayload> {
    const response = await this._request<L.IntegrationRequestMutation, L.IntegrationRequestMutationVariables>(
      L.IntegrationRequestDocument,
      {
        input,
      }
    );
    const data = response.integrationRequest;

    return new IntegrationRequestPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSalesforce Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSalesforceMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSalesforce mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationSalesforce
   * @param redirectUri - required redirectUri to pass to integrationSalesforce
   * @param subdomain - required subdomain to pass to integrationSalesforce
   * @returns parsed response from IntegrationSalesforceMutation
   */
  public async fetch(code: string, redirectUri: string, subdomain: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationSalesforceMutation, L.IntegrationSalesforceMutationVariables>(
      L.IntegrationSalesforceDocument,
      {
        code,
        redirectUri,
        subdomain,
      }
    );
    const data = response.integrationSalesforce;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSentryConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSentryConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSentryConnect mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationSentryConnect
   * @param installationId - required installationId to pass to integrationSentryConnect
   * @param organizationSlug - required organizationSlug to pass to integrationSentryConnect
   * @returns parsed response from IntegrationSentryConnectMutation
   */
  public async fetch(code: string, installationId: string, organizationSlug: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationSentryConnectMutation,
      L.IntegrationSentryConnectMutationVariables
    >(L.IntegrationSentryConnectDocument, {
      code,
      installationId,
      organizationSlug,
    });
    const data = response.integrationSentryConnect;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlack Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlack mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationSlack
   * @param redirectUri - required redirectUri to pass to integrationSlack
   * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationSlackMutation
   * @returns parsed response from IntegrationSlackMutation
   */
  public async fetch(
    code: string,
    redirectUri: string,
    variables?: Omit<L.IntegrationSlackMutationVariables, "code" | "redirectUri">
  ): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationSlackMutation, L.IntegrationSlackMutationVariables>(
      L.IntegrationSlackDocument,
      {
        code,
        redirectUri,
        ...variables,
      }
    );
    const data = response.integrationSlack;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackAsks Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackAsksMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackAsks mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationSlackAsks
   * @param redirectUri - required redirectUri to pass to integrationSlackAsks
   * @returns parsed response from IntegrationSlackAsksMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationSlackAsksMutation, L.IntegrationSlackAsksMutationVariables>(
      L.IntegrationSlackAsksDocument,
      {
        code,
        redirectUri,
      }
    );
    const data = response.integrationSlackAsks;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackCustomViewNotifications Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackCustomViewNotificationsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackCustomViewNotifications mutation and return a SlackChannelConnectPayload
   *
   * @param code - required code to pass to integrationSlackCustomViewNotifications
   * @param customViewId - required customViewId to pass to integrationSlackCustomViewNotifications
   * @param redirectUri - required redirectUri to pass to integrationSlackCustomViewNotifications
   * @returns parsed response from IntegrationSlackCustomViewNotificationsMutation
   */
  public async fetch(code: string, customViewId: string, redirectUri: string): LinearFetch<SlackChannelConnectPayload> {
    const response = await this._request<
      L.IntegrationSlackCustomViewNotificationsMutation,
      L.IntegrationSlackCustomViewNotificationsMutationVariables
    >(L.IntegrationSlackCustomViewNotificationsDocument, {
      code,
      customViewId,
      redirectUri,
    });
    const data = response.integrationSlackCustomViewNotifications;

    return new SlackChannelConnectPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackCustomerChannelLink Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackCustomerChannelLinkMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackCustomerChannelLink mutation and return a SuccessPayload
   *
   * @param code - required code to pass to integrationSlackCustomerChannelLink
   * @param customerId - required customerId to pass to integrationSlackCustomerChannelLink
   * @param redirectUri - required redirectUri to pass to integrationSlackCustomerChannelLink
   * @returns parsed response from IntegrationSlackCustomerChannelLinkMutation
   */
  public async fetch(code: string, customerId: string, redirectUri: string): LinearFetch<SuccessPayload> {
    const response = await this._request<
      L.IntegrationSlackCustomerChannelLinkMutation,
      L.IntegrationSlackCustomerChannelLinkMutationVariables
    >(L.IntegrationSlackCustomerChannelLinkDocument, {
      code,
      customerId,
      redirectUri,
    });
    const data = response.integrationSlackCustomerChannelLink;

    return new SuccessPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackImportEmojis Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackImportEmojisMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackImportEmojis mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationSlackImportEmojis
   * @param redirectUri - required redirectUri to pass to integrationSlackImportEmojis
   * @returns parsed response from IntegrationSlackImportEmojisMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationSlackImportEmojisMutation,
      L.IntegrationSlackImportEmojisMutationVariables
    >(L.IntegrationSlackImportEmojisDocument, {
      code,
      redirectUri,
    });
    const data = response.integrationSlackImportEmojis;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackOrgProjectUpdatesPost Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackOrgProjectUpdatesPostMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackOrgProjectUpdatesPost mutation and return a SlackChannelConnectPayload
   *
   * @param code - required code to pass to integrationSlackOrgProjectUpdatesPost
   * @param redirectUri - required redirectUri to pass to integrationSlackOrgProjectUpdatesPost
   * @returns parsed response from IntegrationSlackOrgProjectUpdatesPostMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<SlackChannelConnectPayload> {
    const response = await this._request<
      L.IntegrationSlackOrgProjectUpdatesPostMutation,
      L.IntegrationSlackOrgProjectUpdatesPostMutationVariables
    >(L.IntegrationSlackOrgProjectUpdatesPostDocument, {
      code,
      redirectUri,
    });
    const data = response.integrationSlackOrgProjectUpdatesPost;

    return new SlackChannelConnectPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackPersonal Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackPersonalMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackPersonal mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationSlackPersonal
   * @param redirectUri - required redirectUri to pass to integrationSlackPersonal
   * @returns parsed response from IntegrationSlackPersonalMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    const response = await this._request<
      L.IntegrationSlackPersonalMutation,
      L.IntegrationSlackPersonalMutationVariables
    >(L.IntegrationSlackPersonalDocument, {
      code,
      redirectUri,
    });
    const data = response.integrationSlackPersonal;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackPost Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackPostMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackPost mutation and return a SlackChannelConnectPayload
   *
   * @param code - required code to pass to integrationSlackPost
   * @param redirectUri - required redirectUri to pass to integrationSlackPost
   * @param teamId - required teamId to pass to integrationSlackPost
   * @param variables - variables without 'code', 'redirectUri', 'teamId' to pass into the IntegrationSlackPostMutation
   * @returns parsed response from IntegrationSlackPostMutation
   */
  public async fetch(
    code: string,
    redirectUri: string,
    teamId: string,
    variables?: Omit<L.IntegrationSlackPostMutationVariables, "code" | "redirectUri" | "teamId">
  ): LinearFetch<SlackChannelConnectPayload> {
    const response = await this._request<L.IntegrationSlackPostMutation, L.IntegrationSlackPostMutationVariables>(
      L.IntegrationSlackPostDocument,
      {
        code,
        redirectUri,
        teamId,
        ...variables,
      }
    );
    const data = response.integrationSlackPost;

    return new SlackChannelConnectPayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationSlackProjectPost Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationSlackProjectPostMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationSlackProjectPost mutation and return a SlackChannelConnectPayload
   *
   * @param code - required code to pass to integrationSlackProjectPost
   * @param projectId - required projectId to pass to integrationSlackProjectPost
   * @param redirectUri - required redirectUri to pass to integrationSlackProjectPost
   * @param service - required service to pass to integrationSlackProjectPost
   * @returns parsed response from IntegrationSlackProjectPostMutation
   */
  public async fetch(
    code: string,
    projectId: string,
    redirectUri: string,
    service: string
  ): LinearFetch<SlackChannelConnectPayload> {
    const response = await this._request<
      L.IntegrationSlackProjectPostMutation,
      L.IntegrationSlackProjectPostMutationVariables
    >(L.IntegrationSlackProjectPostDocument, {
      code,
      projectId,
      redirectUri,
      service,
    });
    const data = response.integrationSlackProjectPost;

    return new SlackChannelConnectPayload(this._request, data);
  }
}

/**
 * A fetchable CreateIntegrationTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIntegrationTemplateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIntegrationTemplate mutation and return a IntegrationTemplatePayload
   *
   * @param input - required input to pass to createIntegrationTemplate
   * @returns parsed response from CreateIntegrationTemplateMutation
   */
  public async fetch(input: L.IntegrationTemplateCreateInput): LinearFetch<IntegrationTemplatePayload> {
    const response = await this._request<
      L.CreateIntegrationTemplateMutation,
      L.CreateIntegrationTemplateMutationVariables
    >(L.CreateIntegrationTemplateDocument, {
      input,
    });
    const data = response.integrationTemplateCreate;

    return new IntegrationTemplatePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIntegrationTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIntegrationTemplateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIntegrationTemplate mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteIntegrationTemplate
   * @returns parsed response from DeleteIntegrationTemplateMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteIntegrationTemplateMutation,
      L.DeleteIntegrationTemplateMutationVariables
    >(L.DeleteIntegrationTemplateDocument, {
      id,
    });
    const data = response.integrationTemplateDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable IntegrationZendesk Mutation
 *
 * @param request - function to call the graphql client
 */
export class IntegrationZendeskMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IntegrationZendesk mutation and return a IntegrationPayload
   *
   * @param code - required code to pass to integrationZendesk
   * @param redirectUri - required redirectUri to pass to integrationZendesk
   * @param scope - required scope to pass to integrationZendesk
   * @param subdomain - required subdomain to pass to integrationZendesk
   * @returns parsed response from IntegrationZendeskMutation
   */
  public async fetch(
    code: string,
    redirectUri: string,
    scope: string,
    subdomain: string
  ): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.IntegrationZendeskMutation, L.IntegrationZendeskMutationVariables>(
      L.IntegrationZendeskDocument,
      {
        code,
        redirectUri,
        scope,
        subdomain,
      }
    );
    const data = response.integrationZendesk;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable CreateIntegrationsSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIntegrationsSettingsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIntegrationsSettings mutation and return a IntegrationsSettingsPayload
   *
   * @param input - required input to pass to createIntegrationsSettings
   * @returns parsed response from CreateIntegrationsSettingsMutation
   */
  public async fetch(input: L.IntegrationsSettingsCreateInput): LinearFetch<IntegrationsSettingsPayload> {
    const response = await this._request<
      L.CreateIntegrationsSettingsMutation,
      L.CreateIntegrationsSettingsMutationVariables
    >(L.CreateIntegrationsSettingsDocument, {
      input,
    });
    const data = response.integrationsSettingsCreate;

    return new IntegrationsSettingsPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIntegrationsSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIntegrationsSettingsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIntegrationsSettings mutation and return a IntegrationsSettingsPayload
   *
   * @param id - required id to pass to updateIntegrationsSettings
   * @param input - required input to pass to updateIntegrationsSettings
   * @returns parsed response from UpdateIntegrationsSettingsMutation
   */
  public async fetch(id: string, input: L.IntegrationsSettingsUpdateInput): LinearFetch<IntegrationsSettingsPayload> {
    const response = await this._request<
      L.UpdateIntegrationsSettingsMutation,
      L.UpdateIntegrationsSettingsMutationVariables
    >(L.UpdateIntegrationsSettingsDocument, {
      id,
      input,
    });
    const data = response.integrationsSettingsUpdate;

    return new IntegrationsSettingsPayload(this._request, data);
  }
}

/**
 * A fetchable IssueAddLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueAddLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueAddLabel mutation and return a IssuePayload
   *
   * @param id - required id to pass to issueAddLabel
   * @param labelId - required labelId to pass to issueAddLabel
   * @returns parsed response from IssueAddLabelMutation
   */
  public async fetch(id: string, labelId: string): LinearFetch<IssuePayload> {
    const response = await this._request<L.IssueAddLabelMutation, L.IssueAddLabelMutationVariables>(
      L.IssueAddLabelDocument,
      {
        id,
        labelId,
      }
    );
    const data = response.issueAddLabel;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveIssue mutation and return a IssueArchivePayload
   *
   * @param id - required id to pass to archiveIssue
   * @param variables - variables without 'id' to pass into the ArchiveIssueMutation
   * @returns parsed response from ArchiveIssueMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.ArchiveIssueMutationVariables, "id">
  ): LinearFetch<IssueArchivePayload> {
    const response = await this._request<L.ArchiveIssueMutation, L.ArchiveIssueMutationVariables>(
      L.ArchiveIssueDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.issueArchive;

    return new IssueArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateIssueBatch Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIssueBatchMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIssueBatch mutation and return a IssueBatchPayload
   *
   * @param input - required input to pass to createIssueBatch
   * @returns parsed response from CreateIssueBatchMutation
   */
  public async fetch(input: L.IssueBatchCreateInput): LinearFetch<IssueBatchPayload> {
    const response = await this._request<L.CreateIssueBatchMutation, L.CreateIssueBatchMutationVariables>(
      L.CreateIssueBatchDocument,
      {
        input,
      }
    );
    const data = response.issueBatchCreate;

    return new IssueBatchPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIssueBatch Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIssueBatchMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIssueBatch mutation and return a IssueBatchPayload
   *
   * @param ids - required ids to pass to updateIssueBatch
   * @param input - required input to pass to updateIssueBatch
   * @returns parsed response from UpdateIssueBatchMutation
   */
  public async fetch(ids: L.Scalars["UUID"][], input: L.IssueUpdateInput): LinearFetch<IssueBatchPayload> {
    const response = await this._request<L.UpdateIssueBatchMutation, L.UpdateIssueBatchMutationVariables>(
      L.UpdateIssueBatchDocument,
      {
        ids,
        input,
      }
    );
    const data = response.issueBatchUpdate;

    return new IssueBatchPayload(this._request, data);
  }
}

/**
 * A fetchable CreateIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIssue mutation and return a IssuePayload
   *
   * @param input - required input to pass to createIssue
   * @returns parsed response from CreateIssueMutation
   */
  public async fetch(input: L.IssueCreateInput): LinearFetch<IssuePayload> {
    const response = await this._request<L.CreateIssueMutation, L.CreateIssueMutationVariables>(L.CreateIssueDocument, {
      input,
    });
    const data = response.issueCreate;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIssue mutation and return a IssueArchivePayload
   *
   * @param id - required id to pass to deleteIssue
   * @param variables - variables without 'id' to pass into the DeleteIssueMutation
   * @returns parsed response from DeleteIssueMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.DeleteIssueMutationVariables, "id">
  ): LinearFetch<IssueArchivePayload> {
    const response = await this._request<L.DeleteIssueMutation, L.DeleteIssueMutationVariables>(L.DeleteIssueDocument, {
      id,
      ...variables,
    });
    const data = response.issueDelete;

    return new IssueArchivePayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCreateAsana Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCreateAsanaMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCreateAsana mutation and return a IssueImportPayload
   *
   * @param asanaTeamName - required asanaTeamName to pass to issueImportCreateAsana
   * @param asanaToken - required asanaToken to pass to issueImportCreateAsana
   * @param variables - variables without 'asanaTeamName', 'asanaToken' to pass into the IssueImportCreateAsanaMutation
   * @returns parsed response from IssueImportCreateAsanaMutation
   */
  public async fetch(
    asanaTeamName: string,
    asanaToken: string,
    variables?: Omit<L.IssueImportCreateAsanaMutationVariables, "asanaTeamName" | "asanaToken">
  ): LinearFetch<IssueImportPayload> {
    const response = await this._request<L.IssueImportCreateAsanaMutation, L.IssueImportCreateAsanaMutationVariables>(
      L.IssueImportCreateAsanaDocument,
      {
        asanaTeamName,
        asanaToken,
        ...variables,
      }
    );
    const data = response.issueImportCreateAsana;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCreateCsvJira Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCreateCsvJiraMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCreateCsvJira mutation and return a IssueImportPayload
   *
   * @param csvUrl - required csvUrl to pass to issueImportCreateCSVJira
   * @param variables - variables without 'csvUrl' to pass into the IssueImportCreateCsvJiraMutation
   * @returns parsed response from IssueImportCreateCsvJiraMutation
   */
  public async fetch(
    csvUrl: string,
    variables?: Omit<L.IssueImportCreateCsvJiraMutationVariables, "csvUrl">
  ): LinearFetch<IssueImportPayload> {
    const response = await this._request<
      L.IssueImportCreateCsvJiraMutation,
      L.IssueImportCreateCsvJiraMutationVariables
    >(L.IssueImportCreateCsvJiraDocument, {
      csvUrl,
      ...variables,
    });
    const data = response.issueImportCreateCSVJira;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCreateClubhouse Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCreateClubhouseMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCreateClubhouse mutation and return a IssueImportPayload
   *
   * @param clubhouseGroupName - required clubhouseGroupName to pass to issueImportCreateClubhouse
   * @param clubhouseToken - required clubhouseToken to pass to issueImportCreateClubhouse
   * @param variables - variables without 'clubhouseGroupName', 'clubhouseToken' to pass into the IssueImportCreateClubhouseMutation
   * @returns parsed response from IssueImportCreateClubhouseMutation
   */
  public async fetch(
    clubhouseGroupName: string,
    clubhouseToken: string,
    variables?: Omit<L.IssueImportCreateClubhouseMutationVariables, "clubhouseGroupName" | "clubhouseToken">
  ): LinearFetch<IssueImportPayload> {
    const response = await this._request<
      L.IssueImportCreateClubhouseMutation,
      L.IssueImportCreateClubhouseMutationVariables
    >(L.IssueImportCreateClubhouseDocument, {
      clubhouseGroupName,
      clubhouseToken,
      ...variables,
    });
    const data = response.issueImportCreateClubhouse;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCreateGithub Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCreateGithubMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCreateGithub mutation and return a IssueImportPayload
   *
   * @param variables - variables to pass into the IssueImportCreateGithubMutation
   * @returns parsed response from IssueImportCreateGithubMutation
   */
  public async fetch(variables?: L.IssueImportCreateGithubMutationVariables): LinearFetch<IssueImportPayload> {
    const response = await this._request<L.IssueImportCreateGithubMutation, L.IssueImportCreateGithubMutationVariables>(
      L.IssueImportCreateGithubDocument,
      variables
    );
    const data = response.issueImportCreateGithub;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportCreateJira Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueImportCreateJiraMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportCreateJira mutation and return a IssueImportPayload
   *
   * @param jiraEmail - required jiraEmail to pass to issueImportCreateJira
   * @param jiraHostname - required jiraHostname to pass to issueImportCreateJira
   * @param jiraProject - required jiraProject to pass to issueImportCreateJira
   * @param jiraToken - required jiraToken to pass to issueImportCreateJira
   * @param variables - variables without 'jiraEmail', 'jiraHostname', 'jiraProject', 'jiraToken' to pass into the IssueImportCreateJiraMutation
   * @returns parsed response from IssueImportCreateJiraMutation
   */
  public async fetch(
    jiraEmail: string,
    jiraHostname: string,
    jiraProject: string,
    jiraToken: string,
    variables?: Omit<
      L.IssueImportCreateJiraMutationVariables,
      "jiraEmail" | "jiraHostname" | "jiraProject" | "jiraToken"
    >
  ): LinearFetch<IssueImportPayload> {
    const response = await this._request<L.IssueImportCreateJiraMutation, L.IssueImportCreateJiraMutationVariables>(
      L.IssueImportCreateJiraDocument,
      {
        jiraEmail,
        jiraHostname,
        jiraProject,
        jiraToken,
        ...variables,
      }
    );
    const data = response.issueImportCreateJira;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIssueImport Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIssueImportMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIssueImport mutation and return a IssueImportDeletePayload
   *
   * @param issueImportId - required issueImportId to pass to deleteIssueImport
   * @returns parsed response from DeleteIssueImportMutation
   */
  public async fetch(issueImportId: string): LinearFetch<IssueImportDeletePayload> {
    const response = await this._request<L.DeleteIssueImportMutation, L.DeleteIssueImportMutationVariables>(
      L.DeleteIssueImportDocument,
      {
        issueImportId,
      }
    );
    const data = response.issueImportDelete;

    return new IssueImportDeletePayload(this._request, data);
  }
}

/**
 * A fetchable IssueImportProcess Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueImportProcessMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueImportProcess mutation and return a IssueImportPayload
   *
   * @param issueImportId - required issueImportId to pass to issueImportProcess
   * @param mapping - required mapping to pass to issueImportProcess
   * @returns parsed response from IssueImportProcessMutation
   */
  public async fetch(issueImportId: string, mapping: L.Scalars["JSONObject"]): LinearFetch<IssueImportPayload> {
    const response = await this._request<L.IssueImportProcessMutation, L.IssueImportProcessMutationVariables>(
      L.IssueImportProcessDocument,
      {
        issueImportId,
        mapping,
      }
    );
    const data = response.issueImportProcess;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIssueImport Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIssueImportMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIssueImport mutation and return a IssueImportPayload
   *
   * @param id - required id to pass to updateIssueImport
   * @param input - required input to pass to updateIssueImport
   * @returns parsed response from UpdateIssueImportMutation
   */
  public async fetch(id: string, input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload> {
    const response = await this._request<L.UpdateIssueImportMutation, L.UpdateIssueImportMutationVariables>(
      L.UpdateIssueImportDocument,
      {
        id,
        input,
      }
    );
    const data = response.issueImportUpdate;

    return new IssueImportPayload(this._request, data);
  }
}

/**
 * A fetchable CreateIssueLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIssueLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIssueLabel mutation and return a IssueLabelPayload
   *
   * @param input - required input to pass to createIssueLabel
   * @param variables - variables without 'input' to pass into the CreateIssueLabelMutation
   * @returns parsed response from CreateIssueLabelMutation
   */
  public async fetch(
    input: L.IssueLabelCreateInput,
    variables?: Omit<L.CreateIssueLabelMutationVariables, "input">
  ): LinearFetch<IssueLabelPayload> {
    const response = await this._request<L.CreateIssueLabelMutation, L.CreateIssueLabelMutationVariables>(
      L.CreateIssueLabelDocument,
      {
        input,
        ...variables,
      }
    );
    const data = response.issueLabelCreate;

    return new IssueLabelPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIssueLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIssueLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIssueLabel mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteIssueLabel
   * @returns parsed response from DeleteIssueLabelMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteIssueLabelMutation, L.DeleteIssueLabelMutationVariables>(
      L.DeleteIssueLabelDocument,
      {
        id,
      }
    );
    const data = response.issueLabelDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIssueLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIssueLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIssueLabel mutation and return a IssueLabelPayload
   *
   * @param id - required id to pass to updateIssueLabel
   * @param input - required input to pass to updateIssueLabel
   * @param variables - variables without 'id', 'input' to pass into the UpdateIssueLabelMutation
   * @returns parsed response from UpdateIssueLabelMutation
   */
  public async fetch(
    id: string,
    input: L.IssueLabelUpdateInput,
    variables?: Omit<L.UpdateIssueLabelMutationVariables, "id" | "input">
  ): LinearFetch<IssueLabelPayload> {
    const response = await this._request<L.UpdateIssueLabelMutation, L.UpdateIssueLabelMutationVariables>(
      L.UpdateIssueLabelDocument,
      {
        id,
        input,
        ...variables,
      }
    );
    const data = response.issueLabelUpdate;

    return new IssueLabelPayload(this._request, data);
  }
}

/**
 * A fetchable CreateIssueRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateIssueRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateIssueRelation mutation and return a IssueRelationPayload
   *
   * @param input - required input to pass to createIssueRelation
   * @param variables - variables without 'input' to pass into the CreateIssueRelationMutation
   * @returns parsed response from CreateIssueRelationMutation
   */
  public async fetch(
    input: L.IssueRelationCreateInput,
    variables?: Omit<L.CreateIssueRelationMutationVariables, "input">
  ): LinearFetch<IssueRelationPayload> {
    const response = await this._request<L.CreateIssueRelationMutation, L.CreateIssueRelationMutationVariables>(
      L.CreateIssueRelationDocument,
      {
        input,
        ...variables,
      }
    );
    const data = response.issueRelationCreate;

    return new IssueRelationPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteIssueRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteIssueRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteIssueRelation mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteIssueRelation
   * @returns parsed response from DeleteIssueRelationMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteIssueRelationMutation, L.DeleteIssueRelationMutationVariables>(
      L.DeleteIssueRelationDocument,
      {
        id,
      }
    );
    const data = response.issueRelationDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIssueRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIssueRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIssueRelation mutation and return a IssueRelationPayload
   *
   * @param id - required id to pass to updateIssueRelation
   * @param input - required input to pass to updateIssueRelation
   * @returns parsed response from UpdateIssueRelationMutation
   */
  public async fetch(id: string, input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload> {
    const response = await this._request<L.UpdateIssueRelationMutation, L.UpdateIssueRelationMutationVariables>(
      L.UpdateIssueRelationDocument,
      {
        id,
        input,
      }
    );
    const data = response.issueRelationUpdate;

    return new IssueRelationPayload(this._request, data);
  }
}

/**
 * A fetchable IssueReminder Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueReminderMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueReminder mutation and return a IssuePayload
   *
   * @param id - required id to pass to issueReminder
   * @param reminderAt - required reminderAt to pass to issueReminder
   * @returns parsed response from IssueReminderMutation
   */
  public async fetch(id: string, reminderAt: Date): LinearFetch<IssuePayload> {
    const response = await this._request<L.IssueReminderMutation, L.IssueReminderMutationVariables>(
      L.IssueReminderDocument,
      {
        id,
        reminderAt,
      }
    );
    const data = response.issueReminder;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable IssueRemoveLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueRemoveLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueRemoveLabel mutation and return a IssuePayload
   *
   * @param id - required id to pass to issueRemoveLabel
   * @param labelId - required labelId to pass to issueRemoveLabel
   * @returns parsed response from IssueRemoveLabelMutation
   */
  public async fetch(id: string, labelId: string): LinearFetch<IssuePayload> {
    const response = await this._request<L.IssueRemoveLabelMutation, L.IssueRemoveLabelMutationVariables>(
      L.IssueRemoveLabelDocument,
      {
        id,
        labelId,
      }
    );
    const data = response.issueRemoveLabel;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable IssueSubscribe Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueSubscribeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueSubscribe mutation and return a IssuePayload
   *
   * @param id - required id to pass to issueSubscribe
   * @param variables - variables without 'id' to pass into the IssueSubscribeMutation
   * @returns parsed response from IssueSubscribeMutation
   */
  public async fetch(id: string, variables?: Omit<L.IssueSubscribeMutationVariables, "id">): LinearFetch<IssuePayload> {
    const response = await this._request<L.IssueSubscribeMutation, L.IssueSubscribeMutationVariables>(
      L.IssueSubscribeDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.issueSubscribe;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveIssue mutation and return a IssueArchivePayload
   *
   * @param id - required id to pass to unarchiveIssue
   * @returns parsed response from UnarchiveIssueMutation
   */
  public async fetch(id: string): LinearFetch<IssueArchivePayload> {
    const response = await this._request<L.UnarchiveIssueMutation, L.UnarchiveIssueMutationVariables>(
      L.UnarchiveIssueDocument,
      {
        id,
      }
    );
    const data = response.issueUnarchive;

    return new IssueArchivePayload(this._request, data);
  }
}

/**
 * A fetchable IssueUnsubscribe Mutation
 *
 * @param request - function to call the graphql client
 */
export class IssueUnsubscribeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the IssueUnsubscribe mutation and return a IssuePayload
   *
   * @param id - required id to pass to issueUnsubscribe
   * @param variables - variables without 'id' to pass into the IssueUnsubscribeMutation
   * @returns parsed response from IssueUnsubscribeMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.IssueUnsubscribeMutationVariables, "id">
  ): LinearFetch<IssuePayload> {
    const response = await this._request<L.IssueUnsubscribeMutation, L.IssueUnsubscribeMutationVariables>(
      L.IssueUnsubscribeDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.issueUnsubscribe;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateIssue Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateIssueMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateIssue mutation and return a IssuePayload
   *
   * @param id - required id to pass to updateIssue
   * @param input - required input to pass to updateIssue
   * @returns parsed response from UpdateIssueMutation
   */
  public async fetch(id: string, input: L.IssueUpdateInput): LinearFetch<IssuePayload> {
    const response = await this._request<L.UpdateIssueMutation, L.UpdateIssueMutationVariables>(L.UpdateIssueDocument, {
      id,
      input,
    });
    const data = response.issueUpdate;

    return new IssuePayload(this._request, data);
  }
}

/**
 * A fetchable JoinOrganizationFromOnboarding Mutation
 *
 * @param request - function to call the graphql client
 */
export class JoinOrganizationFromOnboardingMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the JoinOrganizationFromOnboarding mutation and return a CreateOrJoinOrganizationResponse
   *
   * @param input - required input to pass to joinOrganizationFromOnboarding
   * @returns parsed response from JoinOrganizationFromOnboardingMutation
   */
  public async fetch(input: L.JoinOrganizationInput): LinearFetch<CreateOrJoinOrganizationResponse> {
    const response = await this._request<
      L.JoinOrganizationFromOnboardingMutation,
      L.JoinOrganizationFromOnboardingMutationVariables
    >(L.JoinOrganizationFromOnboardingDocument, {
      input,
    });
    const data = response.joinOrganizationFromOnboarding;

    return new CreateOrJoinOrganizationResponse(this._request, data);
  }
}

/**
 * A fetchable LeaveOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export class LeaveOrganizationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the LeaveOrganization mutation and return a CreateOrJoinOrganizationResponse
   *
   * @param organizationId - required organizationId to pass to leaveOrganization
   * @returns parsed response from LeaveOrganizationMutation
   */
  public async fetch(organizationId: string): LinearFetch<CreateOrJoinOrganizationResponse> {
    const response = await this._request<L.LeaveOrganizationMutation, L.LeaveOrganizationMutationVariables>(
      L.LeaveOrganizationDocument,
      {
        organizationId,
      }
    );
    const data = response.leaveOrganization;

    return new CreateOrJoinOrganizationResponse(this._request, data);
  }
}

/**
 * A fetchable Logout Mutation
 *
 * @param request - function to call the graphql client
 */
export class LogoutMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Logout mutation and return a LogoutResponse
   *
   * @param variables - variables to pass into the LogoutMutation
   * @returns parsed response from LogoutMutation
   */
  public async fetch(variables?: L.LogoutMutationVariables): LinearFetch<LogoutResponse> {
    const response = await this._request<L.LogoutMutation, L.LogoutMutationVariables>(L.LogoutDocument, variables);
    const data = response.logout;

    return new LogoutResponse(this._request, data);
  }
}

/**
 * A fetchable LogoutAllSessions Mutation
 *
 * @param request - function to call the graphql client
 */
export class LogoutAllSessionsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the LogoutAllSessions mutation and return a LogoutResponse
   *
   * @param variables - variables to pass into the LogoutAllSessionsMutation
   * @returns parsed response from LogoutAllSessionsMutation
   */
  public async fetch(variables?: L.LogoutAllSessionsMutationVariables): LinearFetch<LogoutResponse> {
    const response = await this._request<L.LogoutAllSessionsMutation, L.LogoutAllSessionsMutationVariables>(
      L.LogoutAllSessionsDocument,
      variables
    );
    const data = response.logoutAllSessions;

    return new LogoutResponse(this._request, data);
  }
}

/**
 * A fetchable LogoutOtherSessions Mutation
 *
 * @param request - function to call the graphql client
 */
export class LogoutOtherSessionsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the LogoutOtherSessions mutation and return a LogoutResponse
   *
   * @param variables - variables to pass into the LogoutOtherSessionsMutation
   * @returns parsed response from LogoutOtherSessionsMutation
   */
  public async fetch(variables?: L.LogoutOtherSessionsMutationVariables): LinearFetch<LogoutResponse> {
    const response = await this._request<L.LogoutOtherSessionsMutation, L.LogoutOtherSessionsMutationVariables>(
      L.LogoutOtherSessionsDocument,
      variables
    );
    const data = response.logoutOtherSessions;

    return new LogoutResponse(this._request, data);
  }
}

/**
 * A fetchable LogoutSession Mutation
 *
 * @param request - function to call the graphql client
 */
export class LogoutSessionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the LogoutSession mutation and return a LogoutResponse
   *
   * @param sessionId - required sessionId to pass to logoutSession
   * @returns parsed response from LogoutSessionMutation
   */
  public async fetch(sessionId: string): LinearFetch<LogoutResponse> {
    const response = await this._request<L.LogoutSessionMutation, L.LogoutSessionMutationVariables>(
      L.LogoutSessionDocument,
      {
        sessionId,
      }
    );
    const data = response.logoutSession;

    return new LogoutResponse(this._request, data);
  }
}

/**
 * A fetchable ArchiveNotification Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveNotificationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveNotification mutation and return a NotificationArchivePayload
   *
   * @param id - required id to pass to archiveNotification
   * @returns parsed response from ArchiveNotificationMutation
   */
  public async fetch(id: string): LinearFetch<NotificationArchivePayload> {
    const response = await this._request<L.ArchiveNotificationMutation, L.ArchiveNotificationMutationVariables>(
      L.ArchiveNotificationDocument,
      {
        id,
      }
    );
    const data = response.notificationArchive;

    return new NotificationArchivePayload(this._request, data);
  }
}

/**
 * A fetchable NotificationArchiveAll Mutation
 *
 * @param request - function to call the graphql client
 */
export class NotificationArchiveAllMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationArchiveAll mutation and return a NotificationBatchActionPayload
   *
   * @param input - required input to pass to notificationArchiveAll
   * @returns parsed response from NotificationArchiveAllMutation
   */
  public async fetch(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload> {
    const response = await this._request<L.NotificationArchiveAllMutation, L.NotificationArchiveAllMutationVariables>(
      L.NotificationArchiveAllDocument,
      {
        input,
      }
    );
    const data = response.notificationArchiveAll;

    return new NotificationBatchActionPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateNotificationCategoryChannelSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateNotificationCategoryChannelSubscriptionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateNotificationCategoryChannelSubscription mutation and return a UserSettingsPayload
   *
   * @param category - required category to pass to updateNotificationCategoryChannelSubscription
   * @param channel - required channel to pass to updateNotificationCategoryChannelSubscription
   * @param subscribe - required subscribe to pass to updateNotificationCategoryChannelSubscription
   * @returns parsed response from UpdateNotificationCategoryChannelSubscriptionMutation
   */
  public async fetch(
    category: L.NotificationCategory,
    channel: L.NotificationChannel,
    subscribe: boolean
  ): LinearFetch<UserSettingsPayload> {
    const response = await this._request<
      L.UpdateNotificationCategoryChannelSubscriptionMutation,
      L.UpdateNotificationCategoryChannelSubscriptionMutationVariables
    >(L.UpdateNotificationCategoryChannelSubscriptionDocument, {
      category,
      channel,
      subscribe,
    });
    const data = response.notificationCategoryChannelSubscriptionUpdate;

    return new UserSettingsPayload(this._request, data);
  }
}

/**
 * A fetchable NotificationMarkReadAll Mutation
 *
 * @param request - function to call the graphql client
 */
export class NotificationMarkReadAllMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationMarkReadAll mutation and return a NotificationBatchActionPayload
   *
   * @param input - required input to pass to notificationMarkReadAll
   * @param readAt - required readAt to pass to notificationMarkReadAll
   * @returns parsed response from NotificationMarkReadAllMutation
   */
  public async fetch(input: L.NotificationEntityInput, readAt: Date): LinearFetch<NotificationBatchActionPayload> {
    const response = await this._request<L.NotificationMarkReadAllMutation, L.NotificationMarkReadAllMutationVariables>(
      L.NotificationMarkReadAllDocument,
      {
        input,
        readAt,
      }
    );
    const data = response.notificationMarkReadAll;

    return new NotificationBatchActionPayload(this._request, data);
  }
}

/**
 * A fetchable NotificationMarkUnreadAll Mutation
 *
 * @param request - function to call the graphql client
 */
export class NotificationMarkUnreadAllMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationMarkUnreadAll mutation and return a NotificationBatchActionPayload
   *
   * @param input - required input to pass to notificationMarkUnreadAll
   * @returns parsed response from NotificationMarkUnreadAllMutation
   */
  public async fetch(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload> {
    const response = await this._request<
      L.NotificationMarkUnreadAllMutation,
      L.NotificationMarkUnreadAllMutationVariables
    >(L.NotificationMarkUnreadAllDocument, {
      input,
    });
    const data = response.notificationMarkUnreadAll;

    return new NotificationBatchActionPayload(this._request, data);
  }
}

/**
 * A fetchable NotificationSnoozeAll Mutation
 *
 * @param request - function to call the graphql client
 */
export class NotificationSnoozeAllMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationSnoozeAll mutation and return a NotificationBatchActionPayload
   *
   * @param input - required input to pass to notificationSnoozeAll
   * @param snoozedUntilAt - required snoozedUntilAt to pass to notificationSnoozeAll
   * @returns parsed response from NotificationSnoozeAllMutation
   */
  public async fetch(
    input: L.NotificationEntityInput,
    snoozedUntilAt: Date
  ): LinearFetch<NotificationBatchActionPayload> {
    const response = await this._request<L.NotificationSnoozeAllMutation, L.NotificationSnoozeAllMutationVariables>(
      L.NotificationSnoozeAllDocument,
      {
        input,
        snoozedUntilAt,
      }
    );
    const data = response.notificationSnoozeAll;

    return new NotificationBatchActionPayload(this._request, data);
  }
}

/**
 * A fetchable CreateNotificationSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateNotificationSubscriptionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateNotificationSubscription mutation and return a NotificationSubscriptionPayload
   *
   * @param input - required input to pass to createNotificationSubscription
   * @returns parsed response from CreateNotificationSubscriptionMutation
   */
  public async fetch(input: L.NotificationSubscriptionCreateInput): LinearFetch<NotificationSubscriptionPayload> {
    const response = await this._request<
      L.CreateNotificationSubscriptionMutation,
      L.CreateNotificationSubscriptionMutationVariables
    >(L.CreateNotificationSubscriptionDocument, {
      input,
    });
    const data = response.notificationSubscriptionCreate;

    return new NotificationSubscriptionPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteNotificationSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteNotificationSubscriptionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteNotificationSubscription mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteNotificationSubscription
   * @returns parsed response from DeleteNotificationSubscriptionMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteNotificationSubscriptionMutation,
      L.DeleteNotificationSubscriptionMutationVariables
    >(L.DeleteNotificationSubscriptionDocument, {
      id,
    });
    const data = response.notificationSubscriptionDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateNotificationSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateNotificationSubscriptionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateNotificationSubscription mutation and return a NotificationSubscriptionPayload
   *
   * @param id - required id to pass to updateNotificationSubscription
   * @param input - required input to pass to updateNotificationSubscription
   * @returns parsed response from UpdateNotificationSubscriptionMutation
   */
  public async fetch(
    id: string,
    input: L.NotificationSubscriptionUpdateInput
  ): LinearFetch<NotificationSubscriptionPayload> {
    const response = await this._request<
      L.UpdateNotificationSubscriptionMutation,
      L.UpdateNotificationSubscriptionMutationVariables
    >(L.UpdateNotificationSubscriptionDocument, {
      id,
      input,
    });
    const data = response.notificationSubscriptionUpdate;

    return new NotificationSubscriptionPayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveNotification Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveNotificationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveNotification mutation and return a NotificationArchivePayload
   *
   * @param id - required id to pass to unarchiveNotification
   * @returns parsed response from UnarchiveNotificationMutation
   */
  public async fetch(id: string): LinearFetch<NotificationArchivePayload> {
    const response = await this._request<L.UnarchiveNotificationMutation, L.UnarchiveNotificationMutationVariables>(
      L.UnarchiveNotificationDocument,
      {
        id,
      }
    );
    const data = response.notificationUnarchive;

    return new NotificationArchivePayload(this._request, data);
  }
}

/**
 * A fetchable NotificationUnsnoozeAll Mutation
 *
 * @param request - function to call the graphql client
 */
export class NotificationUnsnoozeAllMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the NotificationUnsnoozeAll mutation and return a NotificationBatchActionPayload
   *
   * @param input - required input to pass to notificationUnsnoozeAll
   * @param unsnoozedAt - required unsnoozedAt to pass to notificationUnsnoozeAll
   * @returns parsed response from NotificationUnsnoozeAllMutation
   */
  public async fetch(input: L.NotificationEntityInput, unsnoozedAt: Date): LinearFetch<NotificationBatchActionPayload> {
    const response = await this._request<L.NotificationUnsnoozeAllMutation, L.NotificationUnsnoozeAllMutationVariables>(
      L.NotificationUnsnoozeAllDocument,
      {
        input,
        unsnoozedAt,
      }
    );
    const data = response.notificationUnsnoozeAll;

    return new NotificationBatchActionPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateNotification Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateNotificationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateNotification mutation and return a NotificationPayload
   *
   * @param id - required id to pass to updateNotification
   * @param input - required input to pass to updateNotification
   * @returns parsed response from UpdateNotificationMutation
   */
  public async fetch(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload> {
    const response = await this._request<L.UpdateNotificationMutation, L.UpdateNotificationMutationVariables>(
      L.UpdateNotificationDocument,
      {
        id,
        input,
      }
    );
    const data = response.notificationUpdate;

    return new NotificationPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteOrganizationCancel Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteOrganizationCancelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteOrganizationCancel mutation and return a OrganizationCancelDeletePayload
   *
   * @returns parsed response from DeleteOrganizationCancelMutation
   */
  public async fetch(): LinearFetch<OrganizationCancelDeletePayload> {
    const response = await this._request<
      L.DeleteOrganizationCancelMutation,
      L.DeleteOrganizationCancelMutationVariables
    >(L.DeleteOrganizationCancelDocument, {});
    const data = response.organizationCancelDelete;

    return new OrganizationCancelDeletePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteOrganizationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteOrganization mutation and return a OrganizationDeletePayload
   *
   * @param input - required input to pass to deleteOrganization
   * @returns parsed response from DeleteOrganizationMutation
   */
  public async fetch(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload> {
    const response = await this._request<L.DeleteOrganizationMutation, L.DeleteOrganizationMutationVariables>(
      L.DeleteOrganizationDocument,
      {
        input,
      }
    );
    const data = response.organizationDelete;

    return new OrganizationDeletePayload(this._request, data);
  }
}

/**
 * A fetchable OrganizationDeleteChallenge Mutation
 *
 * @param request - function to call the graphql client
 */
export class OrganizationDeleteChallengeMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the OrganizationDeleteChallenge mutation and return a OrganizationDeletePayload
   *
   * @returns parsed response from OrganizationDeleteChallengeMutation
   */
  public async fetch(): LinearFetch<OrganizationDeletePayload> {
    const response = await this._request<
      L.OrganizationDeleteChallengeMutation,
      L.OrganizationDeleteChallengeMutationVariables
    >(L.OrganizationDeleteChallengeDocument, {});
    const data = response.organizationDeleteChallenge;

    return new OrganizationDeletePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteOrganizationDomain Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteOrganizationDomainMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteOrganizationDomain mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteOrganizationDomain
   * @returns parsed response from DeleteOrganizationDomainMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteOrganizationDomainMutation,
      L.DeleteOrganizationDomainMutationVariables
    >(L.DeleteOrganizationDomainDocument, {
      id,
    });
    const data = response.organizationDomainDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CreateOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateOrganizationInviteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateOrganizationInvite mutation and return a OrganizationInvitePayload
   *
   * @param input - required input to pass to createOrganizationInvite
   * @returns parsed response from CreateOrganizationInviteMutation
   */
  public async fetch(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload> {
    const response = await this._request<
      L.CreateOrganizationInviteMutation,
      L.CreateOrganizationInviteMutationVariables
    >(L.CreateOrganizationInviteDocument, {
      input,
    });
    const data = response.organizationInviteCreate;

    return new OrganizationInvitePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteOrganizationInviteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteOrganizationInvite mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteOrganizationInvite
   * @returns parsed response from DeleteOrganizationInviteMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteOrganizationInviteMutation,
      L.DeleteOrganizationInviteMutationVariables
    >(L.DeleteOrganizationInviteDocument, {
      id,
    });
    const data = response.organizationInviteDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateOrganizationInviteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateOrganizationInvite mutation and return a OrganizationInvitePayload
   *
   * @param id - required id to pass to updateOrganizationInvite
   * @param input - required input to pass to updateOrganizationInvite
   * @returns parsed response from UpdateOrganizationInviteMutation
   */
  public async fetch(id: string, input: L.OrganizationInviteUpdateInput): LinearFetch<OrganizationInvitePayload> {
    const response = await this._request<
      L.UpdateOrganizationInviteMutation,
      L.UpdateOrganizationInviteMutationVariables
    >(L.UpdateOrganizationInviteDocument, {
      id,
      input,
    });
    const data = response.organizationInviteUpdate;

    return new OrganizationInvitePayload(this._request, data);
  }
}

/**
 * A fetchable OrganizationStartTrial Mutation
 *
 * @param request - function to call the graphql client
 */
export class OrganizationStartTrialMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the OrganizationStartTrial mutation and return a OrganizationStartTrialPayload
   *
   * @returns parsed response from OrganizationStartTrialMutation
   */
  public async fetch(): LinearFetch<OrganizationStartTrialPayload> {
    const response = await this._request<L.OrganizationStartTrialMutation, L.OrganizationStartTrialMutationVariables>(
      L.OrganizationStartTrialDocument,
      {}
    );
    const data = response.organizationStartTrial;

    return new OrganizationStartTrialPayload(this._request, data);
  }
}

/**
 * A fetchable OrganizationStartTrialForPlan Mutation
 *
 * @param request - function to call the graphql client
 */
export class OrganizationStartTrialForPlanMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the OrganizationStartTrialForPlan mutation and return a OrganizationStartTrialPayload
   *
   * @param input - required input to pass to organizationStartTrialForPlan
   * @returns parsed response from OrganizationStartTrialForPlanMutation
   */
  public async fetch(input: L.OrganizationStartTrialInput): LinearFetch<OrganizationStartTrialPayload> {
    const response = await this._request<
      L.OrganizationStartTrialForPlanMutation,
      L.OrganizationStartTrialForPlanMutationVariables
    >(L.OrganizationStartTrialForPlanDocument, {
      input,
    });
    const data = response.organizationStartTrialForPlan;

    return new OrganizationStartTrialPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateOrganization Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateOrganizationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateOrganization mutation and return a OrganizationPayload
   *
   * @param input - required input to pass to updateOrganization
   * @returns parsed response from UpdateOrganizationMutation
   */
  public async fetch(input: L.OrganizationUpdateInput): LinearFetch<OrganizationPayload> {
    const response = await this._request<L.UpdateOrganizationMutation, L.UpdateOrganizationMutationVariables>(
      L.UpdateOrganizationDocument,
      {
        input,
      }
    );
    const data = response.organizationUpdate;

    return new OrganizationPayload(this._request, data);
  }
}

/**
 * A fetchable ProjectAddLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class ProjectAddLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectAddLabel mutation and return a ProjectPayload
   *
   * @param id - required id to pass to projectAddLabel
   * @param labelId - required labelId to pass to projectAddLabel
   * @returns parsed response from ProjectAddLabelMutation
   */
  public async fetch(id: string, labelId: string): LinearFetch<ProjectPayload> {
    const response = await this._request<L.ProjectAddLabelMutation, L.ProjectAddLabelMutationVariables>(
      L.ProjectAddLabelDocument,
      {
        id,
        labelId,
      }
    );
    const data = response.projectAddLabel;

    return new ProjectPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveProject mutation and return a ProjectArchivePayload
   *
   * @param id - required id to pass to archiveProject
   * @param variables - variables without 'id' to pass into the ArchiveProjectMutation
   * @returns parsed response from ArchiveProjectMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.ArchiveProjectMutationVariables, "id">
  ): LinearFetch<ProjectArchivePayload> {
    const response = await this._request<L.ArchiveProjectMutation, L.ArchiveProjectMutationVariables>(
      L.ArchiveProjectDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.projectArchive;

    return new ProjectArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProject mutation and return a ProjectPayload
   *
   * @param input - required input to pass to createProject
   * @param variables - variables without 'input' to pass into the CreateProjectMutation
   * @returns parsed response from CreateProjectMutation
   */
  public async fetch(
    input: L.ProjectCreateInput,
    variables?: Omit<L.CreateProjectMutationVariables, "input">
  ): LinearFetch<ProjectPayload> {
    const response = await this._request<L.CreateProjectMutation, L.CreateProjectMutationVariables>(
      L.CreateProjectDocument,
      {
        input,
        ...variables,
      }
    );
    const data = response.projectCreate;

    return new ProjectPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteProject mutation and return a ProjectArchivePayload
   *
   * @param id - required id to pass to deleteProject
   * @returns parsed response from DeleteProjectMutation
   */
  public async fetch(id: string): LinearFetch<ProjectArchivePayload> {
    const response = await this._request<L.DeleteProjectMutation, L.DeleteProjectMutationVariables>(
      L.DeleteProjectDocument,
      {
        id,
      }
    );
    const data = response.projectDelete;

    return new ProjectArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateProjectLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProjectLabel mutation and return a ProjectLabelPayload
   *
   * @param input - required input to pass to createProjectLabel
   * @returns parsed response from CreateProjectLabelMutation
   */
  public async fetch(input: L.ProjectLabelCreateInput): LinearFetch<ProjectLabelPayload> {
    const response = await this._request<L.CreateProjectLabelMutation, L.CreateProjectLabelMutationVariables>(
      L.CreateProjectLabelDocument,
      {
        input,
      }
    );
    const data = response.projectLabelCreate;

    return new ProjectLabelPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteProjectLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteProjectLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteProjectLabel mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteProjectLabel
   * @returns parsed response from DeleteProjectLabelMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteProjectLabelMutation, L.DeleteProjectLabelMutationVariables>(
      L.DeleteProjectLabelDocument,
      {
        id,
      }
    );
    const data = response.projectLabelDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateProjectLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateProjectLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateProjectLabel mutation and return a ProjectLabelPayload
   *
   * @param id - required id to pass to updateProjectLabel
   * @param input - required input to pass to updateProjectLabel
   * @returns parsed response from UpdateProjectLabelMutation
   */
  public async fetch(id: string, input: L.ProjectLabelUpdateInput): LinearFetch<ProjectLabelPayload> {
    const response = await this._request<L.UpdateProjectLabelMutation, L.UpdateProjectLabelMutationVariables>(
      L.UpdateProjectLabelDocument,
      {
        id,
        input,
      }
    );
    const data = response.projectLabelUpdate;

    return new ProjectLabelPayload(this._request, data);
  }
}

/**
 * A fetchable CreateProjectMilestone Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectMilestoneMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProjectMilestone mutation and return a ProjectMilestonePayload
   *
   * @param input - required input to pass to createProjectMilestone
   * @returns parsed response from CreateProjectMilestoneMutation
   */
  public async fetch(input: L.ProjectMilestoneCreateInput): LinearFetch<ProjectMilestonePayload> {
    const response = await this._request<L.CreateProjectMilestoneMutation, L.CreateProjectMilestoneMutationVariables>(
      L.CreateProjectMilestoneDocument,
      {
        input,
      }
    );
    const data = response.projectMilestoneCreate;

    return new ProjectMilestonePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteProjectMilestone Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteProjectMilestoneMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteProjectMilestone mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteProjectMilestone
   * @returns parsed response from DeleteProjectMilestoneMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteProjectMilestoneMutation, L.DeleteProjectMilestoneMutationVariables>(
      L.DeleteProjectMilestoneDocument,
      {
        id,
      }
    );
    const data = response.projectMilestoneDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateProjectMilestone Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateProjectMilestoneMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateProjectMilestone mutation and return a ProjectMilestonePayload
   *
   * @param id - required id to pass to updateProjectMilestone
   * @param input - required input to pass to updateProjectMilestone
   * @returns parsed response from UpdateProjectMilestoneMutation
   */
  public async fetch(id: string, input: L.ProjectMilestoneUpdateInput): LinearFetch<ProjectMilestonePayload> {
    const response = await this._request<L.UpdateProjectMilestoneMutation, L.UpdateProjectMilestoneMutationVariables>(
      L.UpdateProjectMilestoneDocument,
      {
        id,
        input,
      }
    );
    const data = response.projectMilestoneUpdate;

    return new ProjectMilestonePayload(this._request, data);
  }
}

/**
 * A fetchable CreateProjectRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProjectRelation mutation and return a ProjectRelationPayload
   *
   * @param input - required input to pass to createProjectRelation
   * @returns parsed response from CreateProjectRelationMutation
   */
  public async fetch(input: L.ProjectRelationCreateInput): LinearFetch<ProjectRelationPayload> {
    const response = await this._request<L.CreateProjectRelationMutation, L.CreateProjectRelationMutationVariables>(
      L.CreateProjectRelationDocument,
      {
        input,
      }
    );
    const data = response.projectRelationCreate;

    return new ProjectRelationPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteProjectRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteProjectRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteProjectRelation mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteProjectRelation
   * @returns parsed response from DeleteProjectRelationMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteProjectRelationMutation, L.DeleteProjectRelationMutationVariables>(
      L.DeleteProjectRelationDocument,
      {
        id,
      }
    );
    const data = response.projectRelationDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateProjectRelation Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateProjectRelationMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateProjectRelation mutation and return a ProjectRelationPayload
   *
   * @param id - required id to pass to updateProjectRelation
   * @param input - required input to pass to updateProjectRelation
   * @returns parsed response from UpdateProjectRelationMutation
   */
  public async fetch(id: string, input: L.ProjectRelationUpdateInput): LinearFetch<ProjectRelationPayload> {
    const response = await this._request<L.UpdateProjectRelationMutation, L.UpdateProjectRelationMutationVariables>(
      L.UpdateProjectRelationDocument,
      {
        id,
        input,
      }
    );
    const data = response.projectRelationUpdate;

    return new ProjectRelationPayload(this._request, data);
  }
}

/**
 * A fetchable ProjectRemoveLabel Mutation
 *
 * @param request - function to call the graphql client
 */
export class ProjectRemoveLabelMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ProjectRemoveLabel mutation and return a ProjectPayload
   *
   * @param id - required id to pass to projectRemoveLabel
   * @param labelId - required labelId to pass to projectRemoveLabel
   * @returns parsed response from ProjectRemoveLabelMutation
   */
  public async fetch(id: string, labelId: string): LinearFetch<ProjectPayload> {
    const response = await this._request<L.ProjectRemoveLabelMutation, L.ProjectRemoveLabelMutationVariables>(
      L.ProjectRemoveLabelDocument,
      {
        id,
        labelId,
      }
    );
    const data = response.projectRemoveLabel;

    return new ProjectPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveProjectStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveProjectStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveProjectStatus mutation and return a ProjectStatusArchivePayload
   *
   * @param id - required id to pass to archiveProjectStatus
   * @returns parsed response from ArchiveProjectStatusMutation
   */
  public async fetch(id: string): LinearFetch<ProjectStatusArchivePayload> {
    const response = await this._request<L.ArchiveProjectStatusMutation, L.ArchiveProjectStatusMutationVariables>(
      L.ArchiveProjectStatusDocument,
      {
        id,
      }
    );
    const data = response.projectStatusArchive;

    return new ProjectStatusArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateProjectStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProjectStatus mutation and return a ProjectStatusPayload
   *
   * @param input - required input to pass to createProjectStatus
   * @returns parsed response from CreateProjectStatusMutation
   */
  public async fetch(input: L.ProjectStatusCreateInput): LinearFetch<ProjectStatusPayload> {
    const response = await this._request<L.CreateProjectStatusMutation, L.CreateProjectStatusMutationVariables>(
      L.CreateProjectStatusDocument,
      {
        input,
      }
    );
    const data = response.projectStatusCreate;

    return new ProjectStatusPayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveProjectStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveProjectStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveProjectStatus mutation and return a ProjectStatusArchivePayload
   *
   * @param id - required id to pass to unarchiveProjectStatus
   * @returns parsed response from UnarchiveProjectStatusMutation
   */
  public async fetch(id: string): LinearFetch<ProjectStatusArchivePayload> {
    const response = await this._request<L.UnarchiveProjectStatusMutation, L.UnarchiveProjectStatusMutationVariables>(
      L.UnarchiveProjectStatusDocument,
      {
        id,
      }
    );
    const data = response.projectStatusUnarchive;

    return new ProjectStatusArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateProjectStatus Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateProjectStatusMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateProjectStatus mutation and return a ProjectStatusPayload
   *
   * @param id - required id to pass to updateProjectStatus
   * @param input - required input to pass to updateProjectStatus
   * @returns parsed response from UpdateProjectStatusMutation
   */
  public async fetch(id: string, input: L.ProjectStatusUpdateInput): LinearFetch<ProjectStatusPayload> {
    const response = await this._request<L.UpdateProjectStatusMutation, L.UpdateProjectStatusMutationVariables>(
      L.UpdateProjectStatusDocument,
      {
        id,
        input,
      }
    );
    const data = response.projectStatusUpdate;

    return new ProjectStatusPayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveProject mutation and return a ProjectArchivePayload
   *
   * @param id - required id to pass to unarchiveProject
   * @returns parsed response from UnarchiveProjectMutation
   */
  public async fetch(id: string): LinearFetch<ProjectArchivePayload> {
    const response = await this._request<L.UnarchiveProjectMutation, L.UnarchiveProjectMutationVariables>(
      L.UnarchiveProjectDocument,
      {
        id,
      }
    );
    const data = response.projectUnarchive;

    return new ProjectArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateProject mutation and return a ProjectPayload
   *
   * @param id - required id to pass to updateProject
   * @param input - required input to pass to updateProject
   * @returns parsed response from UpdateProjectMutation
   */
  public async fetch(id: string, input: L.ProjectUpdateInput): LinearFetch<ProjectPayload> {
    const response = await this._request<L.UpdateProjectMutation, L.UpdateProjectMutationVariables>(
      L.UpdateProjectDocument,
      {
        id,
        input,
      }
    );
    const data = response.projectUpdate;

    return new ProjectPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveProjectUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveProjectUpdate mutation and return a ProjectUpdateArchivePayload
   *
   * @param id - required id to pass to archiveProjectUpdate
   * @returns parsed response from ArchiveProjectUpdateMutation
   */
  public async fetch(id: string): LinearFetch<ProjectUpdateArchivePayload> {
    const response = await this._request<L.ArchiveProjectUpdateMutation, L.ArchiveProjectUpdateMutationVariables>(
      L.ArchiveProjectUpdateDocument,
      {
        id,
      }
    );
    const data = response.projectUpdateArchive;

    return new ProjectUpdateArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateProjectUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateProjectUpdate mutation and return a ProjectUpdatePayload
   *
   * @param input - required input to pass to createProjectUpdate
   * @returns parsed response from CreateProjectUpdateMutation
   */
  public async fetch(input: L.ProjectUpdateCreateInput): LinearFetch<ProjectUpdatePayload> {
    const response = await this._request<L.CreateProjectUpdateMutation, L.CreateProjectUpdateMutationVariables>(
      L.CreateProjectUpdateDocument,
      {
        input,
      }
    );
    const data = response.projectUpdateCreate;

    return new ProjectUpdatePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteProjectUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteProjectUpdate mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteProjectUpdate
   * @returns parsed response from DeleteProjectUpdateMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteProjectUpdateMutation, L.DeleteProjectUpdateMutationVariables>(
      L.DeleteProjectUpdateDocument,
      {
        id,
      }
    );
    const data = response.projectUpdateDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveProjectUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveProjectUpdate mutation and return a ProjectUpdateArchivePayload
   *
   * @param id - required id to pass to unarchiveProjectUpdate
   * @returns parsed response from UnarchiveProjectUpdateMutation
   */
  public async fetch(id: string): LinearFetch<ProjectUpdateArchivePayload> {
    const response = await this._request<L.UnarchiveProjectUpdateMutation, L.UnarchiveProjectUpdateMutationVariables>(
      L.UnarchiveProjectUpdateDocument,
      {
        id,
      }
    );
    const data = response.projectUpdateUnarchive;

    return new ProjectUpdateArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateProjectUpdate Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateProjectUpdateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateProjectUpdate mutation and return a ProjectUpdatePayload
   *
   * @param id - required id to pass to updateProjectUpdate
   * @param input - required input to pass to updateProjectUpdate
   * @returns parsed response from UpdateProjectUpdateMutation
   */
  public async fetch(id: string, input: L.ProjectUpdateUpdateInput): LinearFetch<ProjectUpdatePayload> {
    const response = await this._request<L.UpdateProjectUpdateMutation, L.UpdateProjectUpdateMutationVariables>(
      L.UpdateProjectUpdateDocument,
      {
        id,
        input,
      }
    );
    const data = response.projectUpdateUpdate;

    return new ProjectUpdatePayload(this._request, data);
  }
}

/**
 * A fetchable CreatePushSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreatePushSubscriptionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreatePushSubscription mutation and return a PushSubscriptionPayload
   *
   * @param input - required input to pass to createPushSubscription
   * @returns parsed response from CreatePushSubscriptionMutation
   */
  public async fetch(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload> {
    const response = await this._request<L.CreatePushSubscriptionMutation, L.CreatePushSubscriptionMutationVariables>(
      L.CreatePushSubscriptionDocument,
      {
        input,
      }
    );
    const data = response.pushSubscriptionCreate;

    return new PushSubscriptionPayload(this._request, data);
  }
}

/**
 * A fetchable DeletePushSubscription Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeletePushSubscriptionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeletePushSubscription mutation and return a PushSubscriptionPayload
   *
   * @param id - required id to pass to deletePushSubscription
   * @returns parsed response from DeletePushSubscriptionMutation
   */
  public async fetch(id: string): LinearFetch<PushSubscriptionPayload> {
    const response = await this._request<L.DeletePushSubscriptionMutation, L.DeletePushSubscriptionMutationVariables>(
      L.DeletePushSubscriptionDocument,
      {
        id,
      }
    );
    const data = response.pushSubscriptionDelete;

    return new PushSubscriptionPayload(this._request, data);
  }
}

/**
 * A fetchable CreateReaction Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateReactionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateReaction mutation and return a ReactionPayload
   *
   * @param input - required input to pass to createReaction
   * @returns parsed response from CreateReactionMutation
   */
  public async fetch(input: L.ReactionCreateInput): LinearFetch<ReactionPayload> {
    const response = await this._request<L.CreateReactionMutation, L.CreateReactionMutationVariables>(
      L.CreateReactionDocument,
      {
        input,
      }
    );
    const data = response.reactionCreate;

    return new ReactionPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteReaction Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteReactionMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteReaction mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteReaction
   * @returns parsed response from DeleteReactionMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteReactionMutation, L.DeleteReactionMutationVariables>(
      L.DeleteReactionDocument,
      {
        id,
      }
    );
    const data = response.reactionDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable RefreshGoogleSheetsData Mutation
 *
 * @param request - function to call the graphql client
 */
export class RefreshGoogleSheetsDataMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the RefreshGoogleSheetsData mutation and return a IntegrationPayload
   *
   * @param id - required id to pass to refreshGoogleSheetsData
   * @param variables - variables without 'id' to pass into the RefreshGoogleSheetsDataMutation
   * @returns parsed response from RefreshGoogleSheetsDataMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.RefreshGoogleSheetsDataMutationVariables, "id">
  ): LinearFetch<IntegrationPayload> {
    const response = await this._request<L.RefreshGoogleSheetsDataMutation, L.RefreshGoogleSheetsDataMutationVariables>(
      L.RefreshGoogleSheetsDataDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.refreshGoogleSheetsData;

    return new IntegrationPayload(this._request, data);
  }
}

/**
 * A fetchable ResendOrganizationInvite Mutation
 *
 * @param request - function to call the graphql client
 */
export class ResendOrganizationInviteMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ResendOrganizationInvite mutation and return a DeletePayload
   *
   * @param id - required id to pass to resendOrganizationInvite
   * @returns parsed response from ResendOrganizationInviteMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.ResendOrganizationInviteMutation,
      L.ResendOrganizationInviteMutationVariables
    >(L.ResendOrganizationInviteDocument, {
      id,
    });
    const data = response.resendOrganizationInvite;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable ResendOrganizationInviteByEmail Mutation
 *
 * @param request - function to call the graphql client
 */
export class ResendOrganizationInviteByEmailMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ResendOrganizationInviteByEmail mutation and return a DeletePayload
   *
   * @param email - required email to pass to resendOrganizationInviteByEmail
   * @returns parsed response from ResendOrganizationInviteByEmailMutation
   */
  public async fetch(email: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.ResendOrganizationInviteByEmailMutation,
      L.ResendOrganizationInviteByEmailMutationVariables
    >(L.ResendOrganizationInviteByEmailDocument, {
      email,
    });
    const data = response.resendOrganizationInviteByEmail;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveRoadmapMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveRoadmap mutation and return a RoadmapArchivePayload
   *
   * @param id - required id to pass to archiveRoadmap
   * @returns parsed response from ArchiveRoadmapMutation
   */
  public async fetch(id: string): LinearFetch<RoadmapArchivePayload> {
    const response = await this._request<L.ArchiveRoadmapMutation, L.ArchiveRoadmapMutationVariables>(
      L.ArchiveRoadmapDocument,
      {
        id,
      }
    );
    const data = response.roadmapArchive;

    return new RoadmapArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateRoadmapMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateRoadmap mutation and return a RoadmapPayload
   *
   * @param input - required input to pass to createRoadmap
   * @returns parsed response from CreateRoadmapMutation
   */
  public async fetch(input: L.RoadmapCreateInput): LinearFetch<RoadmapPayload> {
    const response = await this._request<L.CreateRoadmapMutation, L.CreateRoadmapMutationVariables>(
      L.CreateRoadmapDocument,
      {
        input,
      }
    );
    const data = response.roadmapCreate;

    return new RoadmapPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteRoadmapMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteRoadmap mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteRoadmap
   * @returns parsed response from DeleteRoadmapMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteRoadmapMutation, L.DeleteRoadmapMutationVariables>(
      L.DeleteRoadmapDocument,
      {
        id,
      }
    );
    const data = response.roadmapDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CreateRoadmapToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateRoadmapToProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateRoadmapToProject mutation and return a RoadmapToProjectPayload
   *
   * @param input - required input to pass to createRoadmapToProject
   * @returns parsed response from CreateRoadmapToProjectMutation
   */
  public async fetch(input: L.RoadmapToProjectCreateInput): LinearFetch<RoadmapToProjectPayload> {
    const response = await this._request<L.CreateRoadmapToProjectMutation, L.CreateRoadmapToProjectMutationVariables>(
      L.CreateRoadmapToProjectDocument,
      {
        input,
      }
    );
    const data = response.roadmapToProjectCreate;

    return new RoadmapToProjectPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteRoadmapToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteRoadmapToProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteRoadmapToProject mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteRoadmapToProject
   * @returns parsed response from DeleteRoadmapToProjectMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteRoadmapToProjectMutation, L.DeleteRoadmapToProjectMutationVariables>(
      L.DeleteRoadmapToProjectDocument,
      {
        id,
      }
    );
    const data = response.roadmapToProjectDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateRoadmapToProject Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateRoadmapToProjectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateRoadmapToProject mutation and return a RoadmapToProjectPayload
   *
   * @param id - required id to pass to updateRoadmapToProject
   * @param input - required input to pass to updateRoadmapToProject
   * @returns parsed response from UpdateRoadmapToProjectMutation
   */
  public async fetch(id: string, input: L.RoadmapToProjectUpdateInput): LinearFetch<RoadmapToProjectPayload> {
    const response = await this._request<L.UpdateRoadmapToProjectMutation, L.UpdateRoadmapToProjectMutationVariables>(
      L.UpdateRoadmapToProjectDocument,
      {
        id,
        input,
      }
    );
    const data = response.roadmapToProjectUpdate;

    return new RoadmapToProjectPayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveRoadmapMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveRoadmap mutation and return a RoadmapArchivePayload
   *
   * @param id - required id to pass to unarchiveRoadmap
   * @returns parsed response from UnarchiveRoadmapMutation
   */
  public async fetch(id: string): LinearFetch<RoadmapArchivePayload> {
    const response = await this._request<L.UnarchiveRoadmapMutation, L.UnarchiveRoadmapMutationVariables>(
      L.UnarchiveRoadmapDocument,
      {
        id,
      }
    );
    const data = response.roadmapUnarchive;

    return new RoadmapArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateRoadmap Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateRoadmapMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateRoadmap mutation and return a RoadmapPayload
   *
   * @param id - required id to pass to updateRoadmap
   * @param input - required input to pass to updateRoadmap
   * @returns parsed response from UpdateRoadmapMutation
   */
  public async fetch(id: string, input: L.RoadmapUpdateInput): LinearFetch<RoadmapPayload> {
    const response = await this._request<L.UpdateRoadmapMutation, L.UpdateRoadmapMutationVariables>(
      L.UpdateRoadmapDocument,
      {
        id,
        input,
      }
    );
    const data = response.roadmapUpdate;

    return new RoadmapPayload(this._request, data);
  }
}

/**
 * A fetchable SamlTokenUserAccountAuth Mutation
 *
 * @param request - function to call the graphql client
 */
export class SamlTokenUserAccountAuthMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the SamlTokenUserAccountAuth mutation and return a AuthResolverResponse
   *
   * @param input - required input to pass to samlTokenUserAccountAuth
   * @returns parsed response from SamlTokenUserAccountAuthMutation
   */
  public async fetch(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse> {
    const response = await this._request<
      L.SamlTokenUserAccountAuthMutation,
      L.SamlTokenUserAccountAuthMutationVariables
    >(L.SamlTokenUserAccountAuthDocument, {
      input,
    });
    const data = response.samlTokenUserAccountAuth;

    return new AuthResolverResponse(this._request, data);
  }
}

/**
 * A fetchable CreateTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateTeamMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateTeam mutation and return a TeamPayload
   *
   * @param input - required input to pass to createTeam
   * @param variables - variables without 'input' to pass into the CreateTeamMutation
   * @returns parsed response from CreateTeamMutation
   */
  public async fetch(
    input: L.TeamCreateInput,
    variables?: Omit<L.CreateTeamMutationVariables, "input">
  ): LinearFetch<TeamPayload> {
    const response = await this._request<L.CreateTeamMutation, L.CreateTeamMutationVariables>(L.CreateTeamDocument, {
      input,
      ...variables,
    });
    const data = response.teamCreate;

    return new TeamPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTeamCycles Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTeamCyclesMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTeamCycles mutation and return a TeamPayload
   *
   * @param id - required id to pass to deleteTeamCycles
   * @returns parsed response from DeleteTeamCyclesMutation
   */
  public async fetch(id: string): LinearFetch<TeamPayload> {
    const response = await this._request<L.DeleteTeamCyclesMutation, L.DeleteTeamCyclesMutationVariables>(
      L.DeleteTeamCyclesDocument,
      {
        id,
      }
    );
    const data = response.teamCyclesDelete;

    return new TeamPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTeamMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTeam mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteTeam
   * @returns parsed response from DeleteTeamMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteTeamMutation, L.DeleteTeamMutationVariables>(L.DeleteTeamDocument, {
      id,
    });
    const data = response.teamDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTeamKey Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTeamKeyMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTeamKey mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteTeamKey
   * @returns parsed response from DeleteTeamKeyMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteTeamKeyMutation, L.DeleteTeamKeyMutationVariables>(
      L.DeleteTeamKeyDocument,
      {
        id,
      }
    );
    const data = response.teamKeyDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable CreateTeamMembership Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateTeamMembershipMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateTeamMembership mutation and return a TeamMembershipPayload
   *
   * @param input - required input to pass to createTeamMembership
   * @returns parsed response from CreateTeamMembershipMutation
   */
  public async fetch(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload> {
    const response = await this._request<L.CreateTeamMembershipMutation, L.CreateTeamMembershipMutationVariables>(
      L.CreateTeamMembershipDocument,
      {
        input,
      }
    );
    const data = response.teamMembershipCreate;

    return new TeamMembershipPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTeamMembership Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTeamMembershipMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTeamMembership mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteTeamMembership
   * @param variables - variables without 'id' to pass into the DeleteTeamMembershipMutation
   * @returns parsed response from DeleteTeamMembershipMutation
   */
  public async fetch(
    id: string,
    variables?: Omit<L.DeleteTeamMembershipMutationVariables, "id">
  ): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteTeamMembershipMutation, L.DeleteTeamMembershipMutationVariables>(
      L.DeleteTeamMembershipDocument,
      {
        id,
        ...variables,
      }
    );
    const data = response.teamMembershipDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateTeamMembership Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateTeamMembershipMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateTeamMembership mutation and return a TeamMembershipPayload
   *
   * @param id - required id to pass to updateTeamMembership
   * @param input - required input to pass to updateTeamMembership
   * @returns parsed response from UpdateTeamMembershipMutation
   */
  public async fetch(id: string, input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload> {
    const response = await this._request<L.UpdateTeamMembershipMutation, L.UpdateTeamMembershipMutationVariables>(
      L.UpdateTeamMembershipDocument,
      {
        id,
        input,
      }
    );
    const data = response.teamMembershipUpdate;

    return new TeamMembershipPayload(this._request, data);
  }
}

/**
 * A fetchable UnarchiveTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnarchiveTeamMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnarchiveTeam mutation and return a TeamArchivePayload
   *
   * @param id - required id to pass to unarchiveTeam
   * @returns parsed response from UnarchiveTeamMutation
   */
  public async fetch(id: string): LinearFetch<TeamArchivePayload> {
    const response = await this._request<L.UnarchiveTeamMutation, L.UnarchiveTeamMutationVariables>(
      L.UnarchiveTeamDocument,
      {
        id,
      }
    );
    const data = response.teamUnarchive;

    return new TeamArchivePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateTeam Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateTeamMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateTeam mutation and return a TeamPayload
   *
   * @param id - required id to pass to updateTeam
   * @param input - required input to pass to updateTeam
   * @param variables - variables without 'id', 'input' to pass into the UpdateTeamMutation
   * @returns parsed response from UpdateTeamMutation
   */
  public async fetch(
    id: string,
    input: L.TeamUpdateInput,
    variables?: Omit<L.UpdateTeamMutationVariables, "id" | "input">
  ): LinearFetch<TeamPayload> {
    const response = await this._request<L.UpdateTeamMutation, L.UpdateTeamMutationVariables>(L.UpdateTeamDocument, {
      id,
      input,
      ...variables,
    });
    const data = response.teamUpdate;

    return new TeamPayload(this._request, data);
  }
}

/**
 * A fetchable CreateTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateTemplateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateTemplate mutation and return a TemplatePayload
   *
   * @param input - required input to pass to createTemplate
   * @returns parsed response from CreateTemplateMutation
   */
  public async fetch(input: L.TemplateCreateInput): LinearFetch<TemplatePayload> {
    const response = await this._request<L.CreateTemplateMutation, L.CreateTemplateMutationVariables>(
      L.CreateTemplateDocument,
      {
        input,
      }
    );
    const data = response.templateCreate;

    return new TemplatePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTemplateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTemplate mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteTemplate
   * @returns parsed response from DeleteTemplateMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteTemplateMutation, L.DeleteTemplateMutationVariables>(
      L.DeleteTemplateDocument,
      {
        id,
      }
    );
    const data = response.templateDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateTemplate Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateTemplateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateTemplate mutation and return a TemplatePayload
   *
   * @param id - required id to pass to updateTemplate
   * @param input - required input to pass to updateTemplate
   * @returns parsed response from UpdateTemplateMutation
   */
  public async fetch(id: string, input: L.TemplateUpdateInput): LinearFetch<TemplatePayload> {
    const response = await this._request<L.UpdateTemplateMutation, L.UpdateTemplateMutationVariables>(
      L.UpdateTemplateDocument,
      {
        id,
        input,
      }
    );
    const data = response.templateUpdate;

    return new TemplatePayload(this._request, data);
  }
}

/**
 * A fetchable CreateTimeSchedule Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateTimeScheduleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateTimeSchedule mutation and return a TimeSchedulePayload
   *
   * @param input - required input to pass to createTimeSchedule
   * @returns parsed response from CreateTimeScheduleMutation
   */
  public async fetch(input: L.TimeScheduleCreateInput): LinearFetch<TimeSchedulePayload> {
    const response = await this._request<L.CreateTimeScheduleMutation, L.CreateTimeScheduleMutationVariables>(
      L.CreateTimeScheduleDocument,
      {
        input,
      }
    );
    const data = response.timeScheduleCreate;

    return new TimeSchedulePayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTimeSchedule Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTimeScheduleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTimeSchedule mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteTimeSchedule
   * @returns parsed response from DeleteTimeScheduleMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteTimeScheduleMutation, L.DeleteTimeScheduleMutationVariables>(
      L.DeleteTimeScheduleDocument,
      {
        id,
      }
    );
    const data = response.timeScheduleDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable TimeScheduleRefreshIntegrationSchedule Mutation
 *
 * @param request - function to call the graphql client
 */
export class TimeScheduleRefreshIntegrationScheduleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TimeScheduleRefreshIntegrationSchedule mutation and return a TimeSchedulePayload
   *
   * @param id - required id to pass to timeScheduleRefreshIntegrationSchedule
   * @returns parsed response from TimeScheduleRefreshIntegrationScheduleMutation
   */
  public async fetch(id: string): LinearFetch<TimeSchedulePayload> {
    const response = await this._request<
      L.TimeScheduleRefreshIntegrationScheduleMutation,
      L.TimeScheduleRefreshIntegrationScheduleMutationVariables
    >(L.TimeScheduleRefreshIntegrationScheduleDocument, {
      id,
    });
    const data = response.timeScheduleRefreshIntegrationSchedule;

    return new TimeSchedulePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateTimeSchedule Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateTimeScheduleMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateTimeSchedule mutation and return a TimeSchedulePayload
   *
   * @param id - required id to pass to updateTimeSchedule
   * @param input - required input to pass to updateTimeSchedule
   * @returns parsed response from UpdateTimeScheduleMutation
   */
  public async fetch(id: string, input: L.TimeScheduleUpdateInput): LinearFetch<TimeSchedulePayload> {
    const response = await this._request<L.UpdateTimeScheduleMutation, L.UpdateTimeScheduleMutationVariables>(
      L.UpdateTimeScheduleDocument,
      {
        id,
        input,
      }
    );
    const data = response.timeScheduleUpdate;

    return new TimeSchedulePayload(this._request, data);
  }
}

/**
 * A fetchable TimeScheduleUpsertExternal Mutation
 *
 * @param request - function to call the graphql client
 */
export class TimeScheduleUpsertExternalMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the TimeScheduleUpsertExternal mutation and return a TimeSchedulePayload
   *
   * @param externalId - required externalId to pass to timeScheduleUpsertExternal
   * @param input - required input to pass to timeScheduleUpsertExternal
   * @returns parsed response from TimeScheduleUpsertExternalMutation
   */
  public async fetch(externalId: string, input: L.TimeScheduleUpdateInput): LinearFetch<TimeSchedulePayload> {
    const response = await this._request<
      L.TimeScheduleUpsertExternalMutation,
      L.TimeScheduleUpsertExternalMutationVariables
    >(L.TimeScheduleUpsertExternalDocument, {
      externalId,
      input,
    });
    const data = response.timeScheduleUpsertExternal;

    return new TimeSchedulePayload(this._request, data);
  }
}

/**
 * A fetchable CreateTriageResponsibility Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateTriageResponsibilityMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateTriageResponsibility mutation and return a TriageResponsibilityPayload
   *
   * @param input - required input to pass to createTriageResponsibility
   * @returns parsed response from CreateTriageResponsibilityMutation
   */
  public async fetch(input: L.TriageResponsibilityCreateInput): LinearFetch<TriageResponsibilityPayload> {
    const response = await this._request<
      L.CreateTriageResponsibilityMutation,
      L.CreateTriageResponsibilityMutationVariables
    >(L.CreateTriageResponsibilityDocument, {
      input,
    });
    const data = response.triageResponsibilityCreate;

    return new TriageResponsibilityPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteTriageResponsibility Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteTriageResponsibilityMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteTriageResponsibility mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteTriageResponsibility
   * @returns parsed response from DeleteTriageResponsibilityMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<
      L.DeleteTriageResponsibilityMutation,
      L.DeleteTriageResponsibilityMutationVariables
    >(L.DeleteTriageResponsibilityDocument, {
      id,
    });
    const data = response.triageResponsibilityDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateTriageResponsibility Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateTriageResponsibilityMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateTriageResponsibility mutation and return a TriageResponsibilityPayload
   *
   * @param id - required id to pass to updateTriageResponsibility
   * @param input - required input to pass to updateTriageResponsibility
   * @returns parsed response from UpdateTriageResponsibilityMutation
   */
  public async fetch(id: string, input: L.TriageResponsibilityUpdateInput): LinearFetch<TriageResponsibilityPayload> {
    const response = await this._request<
      L.UpdateTriageResponsibilityMutation,
      L.UpdateTriageResponsibilityMutationVariables
    >(L.UpdateTriageResponsibilityDocument, {
      id,
      input,
    });
    const data = response.triageResponsibilityUpdate;

    return new TriageResponsibilityPayload(this._request, data);
  }
}

/**
 * A fetchable UserDemoteAdmin Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserDemoteAdminMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserDemoteAdmin mutation and return a UserAdminPayload
   *
   * @param id - required id to pass to userDemoteAdmin
   * @returns parsed response from UserDemoteAdminMutation
   */
  public async fetch(id: string): LinearFetch<UserAdminPayload> {
    const response = await this._request<L.UserDemoteAdminMutation, L.UserDemoteAdminMutationVariables>(
      L.UserDemoteAdminDocument,
      {
        id,
      }
    );
    const data = response.userDemoteAdmin;

    return new UserAdminPayload(this._request, data);
  }
}

/**
 * A fetchable UserDemoteMember Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserDemoteMemberMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserDemoteMember mutation and return a UserAdminPayload
   *
   * @param id - required id to pass to userDemoteMember
   * @returns parsed response from UserDemoteMemberMutation
   */
  public async fetch(id: string): LinearFetch<UserAdminPayload> {
    const response = await this._request<L.UserDemoteMemberMutation, L.UserDemoteMemberMutationVariables>(
      L.UserDemoteMemberDocument,
      {
        id,
      }
    );
    const data = response.userDemoteMember;

    return new UserAdminPayload(this._request, data);
  }
}

/**
 * A fetchable UserDiscordConnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserDiscordConnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserDiscordConnect mutation and return a UserPayload
   *
   * @param code - required code to pass to userDiscordConnect
   * @param redirectUri - required redirectUri to pass to userDiscordConnect
   * @returns parsed response from UserDiscordConnectMutation
   */
  public async fetch(code: string, redirectUri: string): LinearFetch<UserPayload> {
    const response = await this._request<L.UserDiscordConnectMutation, L.UserDiscordConnectMutationVariables>(
      L.UserDiscordConnectDocument,
      {
        code,
        redirectUri,
      }
    );
    const data = response.userDiscordConnect;

    return new UserPayload(this._request, data);
  }
}

/**
 * A fetchable UserExternalUserDisconnect Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserExternalUserDisconnectMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserExternalUserDisconnect mutation and return a UserPayload
   *
   * @param service - required service to pass to userExternalUserDisconnect
   * @returns parsed response from UserExternalUserDisconnectMutation
   */
  public async fetch(service: string): LinearFetch<UserPayload> {
    const response = await this._request<
      L.UserExternalUserDisconnectMutation,
      L.UserExternalUserDisconnectMutationVariables
    >(L.UserExternalUserDisconnectDocument, {
      service,
    });
    const data = response.userExternalUserDisconnect;

    return new UserPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateUserFlag Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateUserFlagMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateUserFlag mutation and return a UserSettingsFlagPayload
   *
   * @param flag - required flag to pass to updateUserFlag
   * @param operation - required operation to pass to updateUserFlag
   * @returns parsed response from UpdateUserFlagMutation
   */
  public async fetch(flag: L.UserFlagType, operation: L.UserFlagUpdateOperation): LinearFetch<UserSettingsFlagPayload> {
    const response = await this._request<L.UpdateUserFlagMutation, L.UpdateUserFlagMutationVariables>(
      L.UpdateUserFlagDocument,
      {
        flag,
        operation,
      }
    );
    const data = response.userFlagUpdate;

    return new UserSettingsFlagPayload(this._request, data);
  }
}

/**
 * A fetchable UserPromoteAdmin Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserPromoteAdminMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserPromoteAdmin mutation and return a UserAdminPayload
   *
   * @param id - required id to pass to userPromoteAdmin
   * @returns parsed response from UserPromoteAdminMutation
   */
  public async fetch(id: string): LinearFetch<UserAdminPayload> {
    const response = await this._request<L.UserPromoteAdminMutation, L.UserPromoteAdminMutationVariables>(
      L.UserPromoteAdminDocument,
      {
        id,
      }
    );
    const data = response.userPromoteAdmin;

    return new UserAdminPayload(this._request, data);
  }
}

/**
 * A fetchable UserPromoteMember Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserPromoteMemberMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserPromoteMember mutation and return a UserAdminPayload
   *
   * @param id - required id to pass to userPromoteMember
   * @returns parsed response from UserPromoteMemberMutation
   */
  public async fetch(id: string): LinearFetch<UserAdminPayload> {
    const response = await this._request<L.UserPromoteMemberMutation, L.UserPromoteMemberMutationVariables>(
      L.UserPromoteMemberDocument,
      {
        id,
      }
    );
    const data = response.userPromoteMember;

    return new UserAdminPayload(this._request, data);
  }
}

/**
 * A fetchable UserSettingsFlagsReset Mutation
 *
 * @param request - function to call the graphql client
 */
export class UserSettingsFlagsResetMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettingsFlagsReset mutation and return a UserSettingsFlagsResetPayload
   *
   * @param variables - variables to pass into the UserSettingsFlagsResetMutation
   * @returns parsed response from UserSettingsFlagsResetMutation
   */
  public async fetch(
    variables?: L.UserSettingsFlagsResetMutationVariables
  ): LinearFetch<UserSettingsFlagsResetPayload> {
    const response = await this._request<L.UserSettingsFlagsResetMutation, L.UserSettingsFlagsResetMutationVariables>(
      L.UserSettingsFlagsResetDocument,
      variables
    );
    const data = response.userSettingsFlagsReset;

    return new UserSettingsFlagsResetPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateUserSettings Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateUserSettingsMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateUserSettings mutation and return a UserSettingsPayload
   *
   * @param id - required id to pass to updateUserSettings
   * @param input - required input to pass to updateUserSettings
   * @returns parsed response from UpdateUserSettingsMutation
   */
  public async fetch(id: string, input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload> {
    const response = await this._request<L.UpdateUserSettingsMutation, L.UpdateUserSettingsMutationVariables>(
      L.UpdateUserSettingsDocument,
      {
        id,
        input,
      }
    );
    const data = response.userSettingsUpdate;

    return new UserSettingsPayload(this._request, data);
  }
}

/**
 * A fetchable SuspendUser Mutation
 *
 * @param request - function to call the graphql client
 */
export class SuspendUserMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the SuspendUser mutation and return a UserAdminPayload
   *
   * @param id - required id to pass to suspendUser
   * @returns parsed response from SuspendUserMutation
   */
  public async fetch(id: string): LinearFetch<UserAdminPayload> {
    const response = await this._request<L.SuspendUserMutation, L.SuspendUserMutationVariables>(L.SuspendUserDocument, {
      id,
    });
    const data = response.userSuspend;

    return new UserAdminPayload(this._request, data);
  }
}

/**
 * A fetchable UnsuspendUser Mutation
 *
 * @param request - function to call the graphql client
 */
export class UnsuspendUserMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UnsuspendUser mutation and return a UserAdminPayload
   *
   * @param id - required id to pass to unsuspendUser
   * @returns parsed response from UnsuspendUserMutation
   */
  public async fetch(id: string): LinearFetch<UserAdminPayload> {
    const response = await this._request<L.UnsuspendUserMutation, L.UnsuspendUserMutationVariables>(
      L.UnsuspendUserDocument,
      {
        id,
      }
    );
    const data = response.userUnsuspend;

    return new UserAdminPayload(this._request, data);
  }
}

/**
 * A fetchable UpdateUser Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateUserMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateUser mutation and return a UserPayload
   *
   * @param id - required id to pass to updateUser
   * @param input - required input to pass to updateUser
   * @returns parsed response from UpdateUserMutation
   */
  public async fetch(id: string, input: L.UserUpdateInput): LinearFetch<UserPayload> {
    const response = await this._request<L.UpdateUserMutation, L.UpdateUserMutationVariables>(L.UpdateUserDocument, {
      id,
      input,
    });
    const data = response.userUpdate;

    return new UserPayload(this._request, data);
  }
}

/**
 * A fetchable CreateViewPreferences Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateViewPreferencesMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateViewPreferences mutation and return a ViewPreferencesPayload
   *
   * @param input - required input to pass to createViewPreferences
   * @returns parsed response from CreateViewPreferencesMutation
   */
  public async fetch(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload> {
    const response = await this._request<L.CreateViewPreferencesMutation, L.CreateViewPreferencesMutationVariables>(
      L.CreateViewPreferencesDocument,
      {
        input,
      }
    );
    const data = response.viewPreferencesCreate;

    return new ViewPreferencesPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteViewPreferences Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteViewPreferencesMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteViewPreferences mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteViewPreferences
   * @returns parsed response from DeleteViewPreferencesMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteViewPreferencesMutation, L.DeleteViewPreferencesMutationVariables>(
      L.DeleteViewPreferencesDocument,
      {
        id,
      }
    );
    const data = response.viewPreferencesDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateViewPreferences Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateViewPreferencesMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateViewPreferences mutation and return a ViewPreferencesPayload
   *
   * @param id - required id to pass to updateViewPreferences
   * @param input - required input to pass to updateViewPreferences
   * @returns parsed response from UpdateViewPreferencesMutation
   */
  public async fetch(id: string, input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload> {
    const response = await this._request<L.UpdateViewPreferencesMutation, L.UpdateViewPreferencesMutationVariables>(
      L.UpdateViewPreferencesDocument,
      {
        id,
        input,
      }
    );
    const data = response.viewPreferencesUpdate;

    return new ViewPreferencesPayload(this._request, data);
  }
}

/**
 * A fetchable CreateWebhook Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateWebhookMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateWebhook mutation and return a WebhookPayload
   *
   * @param input - required input to pass to createWebhook
   * @returns parsed response from CreateWebhookMutation
   */
  public async fetch(input: L.WebhookCreateInput): LinearFetch<WebhookPayload> {
    const response = await this._request<L.CreateWebhookMutation, L.CreateWebhookMutationVariables>(
      L.CreateWebhookDocument,
      {
        input,
      }
    );
    const data = response.webhookCreate;

    return new WebhookPayload(this._request, data);
  }
}

/**
 * A fetchable DeleteWebhook Mutation
 *
 * @param request - function to call the graphql client
 */
export class DeleteWebhookMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the DeleteWebhook mutation and return a DeletePayload
   *
   * @param id - required id to pass to deleteWebhook
   * @returns parsed response from DeleteWebhookMutation
   */
  public async fetch(id: string): LinearFetch<DeletePayload> {
    const response = await this._request<L.DeleteWebhookMutation, L.DeleteWebhookMutationVariables>(
      L.DeleteWebhookDocument,
      {
        id,
      }
    );
    const data = response.webhookDelete;

    return new DeletePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateWebhook Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateWebhookMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateWebhook mutation and return a WebhookPayload
   *
   * @param id - required id to pass to updateWebhook
   * @param input - required input to pass to updateWebhook
   * @returns parsed response from UpdateWebhookMutation
   */
  public async fetch(id: string, input: L.WebhookUpdateInput): LinearFetch<WebhookPayload> {
    const response = await this._request<L.UpdateWebhookMutation, L.UpdateWebhookMutationVariables>(
      L.UpdateWebhookDocument,
      {
        id,
        input,
      }
    );
    const data = response.webhookUpdate;

    return new WebhookPayload(this._request, data);
  }
}

/**
 * A fetchable ArchiveWorkflowState Mutation
 *
 * @param request - function to call the graphql client
 */
export class ArchiveWorkflowStateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the ArchiveWorkflowState mutation and return a WorkflowStateArchivePayload
   *
   * @param id - required id to pass to archiveWorkflowState
   * @returns parsed response from ArchiveWorkflowStateMutation
   */
  public async fetch(id: string): LinearFetch<WorkflowStateArchivePayload> {
    const response = await this._request<L.ArchiveWorkflowStateMutation, L.ArchiveWorkflowStateMutationVariables>(
      L.ArchiveWorkflowStateDocument,
      {
        id,
      }
    );
    const data = response.workflowStateArchive;

    return new WorkflowStateArchivePayload(this._request, data);
  }
}

/**
 * A fetchable CreateWorkflowState Mutation
 *
 * @param request - function to call the graphql client
 */
export class CreateWorkflowStateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the CreateWorkflowState mutation and return a WorkflowStatePayload
   *
   * @param input - required input to pass to createWorkflowState
   * @returns parsed response from CreateWorkflowStateMutation
   */
  public async fetch(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload> {
    const response = await this._request<L.CreateWorkflowStateMutation, L.CreateWorkflowStateMutationVariables>(
      L.CreateWorkflowStateDocument,
      {
        input,
      }
    );
    const data = response.workflowStateCreate;

    return new WorkflowStatePayload(this._request, data);
  }
}

/**
 * A fetchable UpdateWorkflowState Mutation
 *
 * @param request - function to call the graphql client
 */
export class UpdateWorkflowStateMutation extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UpdateWorkflowState mutation and return a WorkflowStatePayload
   *
   * @param id - required id to pass to updateWorkflowState
   * @param input - required input to pass to updateWorkflowState
   * @returns parsed response from UpdateWorkflowStateMutation
   */
  public async fetch(id: string, input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload> {
    const response = await this._request<L.UpdateWorkflowStateMutation, L.UpdateWorkflowStateMutationVariables>(
      L.UpdateWorkflowStateDocument,
      {
        id,
        input,
      }
    );
    const data = response.workflowStateUpdate;

    return new WorkflowStatePayload(this._request, data);
  }
}

/**
 * A fetchable AgentSession_Activities Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to agentSession
 * @param variables - variables without 'id' to pass into the AgentSession_ActivitiesQuery
 */
export class AgentSession_ActivitiesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AgentSession_ActivitiesQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AgentSession_ActivitiesQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AgentSession_Activities query and return a AgentActivityConnection
   *
   * @param variables - variables without 'id' to pass into the AgentSession_ActivitiesQuery
   * @returns parsed response from AgentSession_ActivitiesQuery
   */
  public async fetch(
    variables?: Omit<L.AgentSession_ActivitiesQueryVariables, "id">
  ): LinearFetch<AgentActivityConnection> {
    const response = await this._request<L.AgentSession_ActivitiesQuery, L.AgentSession_ActivitiesQueryVariables>(
      L.AgentSession_ActivitiesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.agentSession.activities;

    return new AgentActivityConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_AttachmentsQuery
 */
export class AttachmentIssue_AttachmentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Attachments query and return a AttachmentConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_AttachmentsQuery
   * @returns parsed response from AttachmentIssue_AttachmentsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_AttachmentsQueryVariables, "id">
  ): LinearFetch<AttachmentConnection> {
    const response = await this._request<
      L.AttachmentIssue_AttachmentsQuery,
      L.AttachmentIssue_AttachmentsQueryVariables
    >(L.AttachmentIssue_AttachmentsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.attachmentIssue.attachments;

    return new AttachmentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_BotActor Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 */
export class AttachmentIssue_BotActorQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the AttachmentIssue_BotActor query and return a ActorBot
   *
   * @returns parsed response from AttachmentIssue_BotActorQuery
   */
  public async fetch(): LinearFetch<ActorBot | undefined> {
    const response = await this._request<L.AttachmentIssue_BotActorQuery, L.AttachmentIssue_BotActorQueryVariables>(
      L.AttachmentIssue_BotActorDocument,
      {
        id: this._id,
      }
    );
    const data = response.attachmentIssue.botActor;

    return data ? new ActorBot(this._request, data) : undefined;
  }
}

/**
 * A fetchable AttachmentIssue_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_ChildrenQuery
 */
export class AttachmentIssue_ChildrenQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Children query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_ChildrenQuery
   * @returns parsed response from AttachmentIssue_ChildrenQuery
   */
  public async fetch(variables?: Omit<L.AttachmentIssue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.AttachmentIssue_ChildrenQuery, L.AttachmentIssue_ChildrenQueryVariables>(
      L.AttachmentIssue_ChildrenDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.attachmentIssue.children;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_CommentsQuery
 */
export class AttachmentIssue_CommentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_CommentsQuery
   * @returns parsed response from AttachmentIssue_CommentsQuery
   */
  public async fetch(variables?: Omit<L.AttachmentIssue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection> {
    const response = await this._request<L.AttachmentIssue_CommentsQuery, L.AttachmentIssue_CommentsQueryVariables>(
      L.AttachmentIssue_CommentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.attachmentIssue.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_FormerAttachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_FormerAttachmentsQuery
 */
export class AttachmentIssue_FormerAttachmentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_FormerAttachmentsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_FormerAttachmentsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_FormerAttachments query and return a AttachmentConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_FormerAttachmentsQuery
   * @returns parsed response from AttachmentIssue_FormerAttachmentsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_FormerAttachmentsQueryVariables, "id">
  ): LinearFetch<AttachmentConnection> {
    const response = await this._request<
      L.AttachmentIssue_FormerAttachmentsQuery,
      L.AttachmentIssue_FormerAttachmentsQueryVariables
    >(L.AttachmentIssue_FormerAttachmentsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.attachmentIssue.formerAttachments;

    return new AttachmentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_FormerNeeds Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_FormerNeedsQuery
 */
export class AttachmentIssue_FormerNeedsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_FormerNeedsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_FormerNeedsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_FormerNeeds query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_FormerNeedsQuery
   * @returns parsed response from AttachmentIssue_FormerNeedsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_FormerNeedsQueryVariables, "id">
  ): LinearFetch<CustomerNeedConnection> {
    const response = await this._request<
      L.AttachmentIssue_FormerNeedsQuery,
      L.AttachmentIssue_FormerNeedsQueryVariables
    >(L.AttachmentIssue_FormerNeedsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.attachmentIssue.formerNeeds;

    return new CustomerNeedConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_HistoryQuery
 */
export class AttachmentIssue_HistoryQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_History query and return a IssueHistoryConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_HistoryQuery
   * @returns parsed response from AttachmentIssue_HistoryQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_HistoryQueryVariables, "id">
  ): LinearFetch<IssueHistoryConnection> {
    const response = await this._request<L.AttachmentIssue_HistoryQuery, L.AttachmentIssue_HistoryQueryVariables>(
      L.AttachmentIssue_HistoryDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.attachmentIssue.history;

    return new IssueHistoryConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_InverseRelationsQuery
 */
export class AttachmentIssue_InverseRelationsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_InverseRelations query and return a IssueRelationConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_InverseRelationsQuery
   * @returns parsed response from AttachmentIssue_InverseRelationsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_InverseRelationsQueryVariables, "id">
  ): LinearFetch<IssueRelationConnection> {
    const response = await this._request<
      L.AttachmentIssue_InverseRelationsQuery,
      L.AttachmentIssue_InverseRelationsQueryVariables
    >(L.AttachmentIssue_InverseRelationsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.attachmentIssue.inverseRelations;

    return new IssueRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_LabelsQuery
 */
export class AttachmentIssue_LabelsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Labels query and return a IssueLabelConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_LabelsQuery
   * @returns parsed response from AttachmentIssue_LabelsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_LabelsQueryVariables, "id">
  ): LinearFetch<IssueLabelConnection> {
    const response = await this._request<L.AttachmentIssue_LabelsQuery, L.AttachmentIssue_LabelsQueryVariables>(
      L.AttachmentIssue_LabelsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.attachmentIssue.labels;

    return new IssueLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_Needs Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_NeedsQuery
 */
export class AttachmentIssue_NeedsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_NeedsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_NeedsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Needs query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_NeedsQuery
   * @returns parsed response from AttachmentIssue_NeedsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_NeedsQueryVariables, "id">
  ): LinearFetch<CustomerNeedConnection> {
    const response = await this._request<L.AttachmentIssue_NeedsQuery, L.AttachmentIssue_NeedsQueryVariables>(
      L.AttachmentIssue_NeedsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.attachmentIssue.needs;

    return new CustomerNeedConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_RelationsQuery
 */
export class AttachmentIssue_RelationsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Relations query and return a IssueRelationConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_RelationsQuery
   * @returns parsed response from AttachmentIssue_RelationsQuery
   */
  public async fetch(
    variables?: Omit<L.AttachmentIssue_RelationsQueryVariables, "id">
  ): LinearFetch<IssueRelationConnection> {
    const response = await this._request<L.AttachmentIssue_RelationsQuery, L.AttachmentIssue_RelationsQueryVariables>(
      L.AttachmentIssue_RelationsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.attachmentIssue.relations;

    return new IssueRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable AttachmentIssue_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to attachmentIssue
 * @param variables - variables without 'id' to pass into the AttachmentIssue_SubscribersQuery
 */
export class AttachmentIssue_SubscribersQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the AttachmentIssue_Subscribers query and return a UserConnection
   *
   * @param variables - variables without 'id' to pass into the AttachmentIssue_SubscribersQuery
   * @returns parsed response from AttachmentIssue_SubscribersQuery
   */
  public async fetch(variables?: Omit<L.AttachmentIssue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection> {
    const response = await this._request<
      L.AttachmentIssue_SubscribersQuery,
      L.AttachmentIssue_SubscribersQueryVariables
    >(L.AttachmentIssue_SubscribersDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.attachmentIssue.subscribers;

    return new UserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Comment_BotActor Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Comment_BotActorQuery
 */
export class Comment_BotActorQuery extends Request {
  private _variables?: L.Comment_BotActorQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Comment_BotActorQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Comment_BotActor query and return a ActorBot
   *
   * @param variables - variables to pass into the Comment_BotActorQuery
   * @returns parsed response from Comment_BotActorQuery
   */
  public async fetch(variables?: L.Comment_BotActorQueryVariables): LinearFetch<ActorBot | undefined> {
    const response = await this._request<L.Comment_BotActorQuery, L.Comment_BotActorQueryVariables>(
      L.Comment_BotActorDocument,
      variables
    );
    const data = response.comment.botActor;

    return data ? new ActorBot(this._request, data) : undefined;
  }
}

/**
 * A fetchable Comment_Children Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Comment_ChildrenQuery
 */
export class Comment_ChildrenQuery extends Request {
  private _variables?: L.Comment_ChildrenQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Comment_ChildrenQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Comment_Children query and return a CommentConnection
   *
   * @param variables - variables to pass into the Comment_ChildrenQuery
   * @returns parsed response from Comment_ChildrenQuery
   */
  public async fetch(variables?: L.Comment_ChildrenQueryVariables): LinearFetch<CommentConnection> {
    const response = await this._request<L.Comment_ChildrenQuery, L.Comment_ChildrenQueryVariables>(
      L.Comment_ChildrenDocument,
      variables
    );
    const data = response.comment.children;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Comment_DocumentContent Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Comment_DocumentContentQuery
 */
export class Comment_DocumentContentQuery extends Request {
  private _variables?: L.Comment_DocumentContentQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Comment_DocumentContentQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Comment_DocumentContent query and return a DocumentContent
   *
   * @param variables - variables to pass into the Comment_DocumentContentQuery
   * @returns parsed response from Comment_DocumentContentQuery
   */
  public async fetch(variables?: L.Comment_DocumentContentQueryVariables): LinearFetch<DocumentContent | undefined> {
    const response = await this._request<L.Comment_DocumentContentQuery, L.Comment_DocumentContentQueryVariables>(
      L.Comment_DocumentContentDocument,
      variables
    );
    const data = response.comment.documentContent;

    return data ? new DocumentContent(this._request, data) : undefined;
  }
}

/**
 * A fetchable Comment_ExternalThread Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Comment_ExternalThreadQuery
 */
export class Comment_ExternalThreadQuery extends Request {
  private _variables?: L.Comment_ExternalThreadQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Comment_ExternalThreadQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Comment_ExternalThread query and return a SyncedExternalThread
   *
   * @param variables - variables to pass into the Comment_ExternalThreadQuery
   * @returns parsed response from Comment_ExternalThreadQuery
   */
  public async fetch(
    variables?: L.Comment_ExternalThreadQueryVariables
  ): LinearFetch<SyncedExternalThread | undefined> {
    const response = await this._request<L.Comment_ExternalThreadQuery, L.Comment_ExternalThreadQueryVariables>(
      L.Comment_ExternalThreadDocument,
      variables
    );
    const data = response.comment.externalThread;

    return data ? new SyncedExternalThread(this._request, data) : undefined;
  }
}

/**
 * A fetchable CustomView_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView
 * @param variables - variables without 'id' to pass into the CustomView_IssuesQuery
 */
export class CustomView_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.CustomView_IssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.CustomView_IssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the CustomView_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the CustomView_IssuesQuery
   * @returns parsed response from CustomView_IssuesQuery
   */
  public async fetch(variables?: Omit<L.CustomView_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.CustomView_IssuesQuery, L.CustomView_IssuesQueryVariables>(
      L.CustomView_IssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.customView.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable CustomView_OrganizationViewPreferences Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView
 */
export class CustomView_OrganizationViewPreferencesQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the CustomView_OrganizationViewPreferences query and return a ViewPreferences
   *
   * @returns parsed response from CustomView_OrganizationViewPreferencesQuery
   */
  public async fetch(): LinearFetch<ViewPreferences | undefined> {
    const response = await this._request<
      L.CustomView_OrganizationViewPreferencesQuery,
      L.CustomView_OrganizationViewPreferencesQueryVariables
    >(L.CustomView_OrganizationViewPreferencesDocument, {
      id: this._id,
    });
    const data = response.customView.organizationViewPreferences;

    return data ? new ViewPreferences(this._request, data) : undefined;
  }
}

/**
 * A fetchable CustomView_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView
 * @param variables - variables without 'id' to pass into the CustomView_ProjectsQuery
 */
export class CustomView_ProjectsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.CustomView_ProjectsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.CustomView_ProjectsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the CustomView_Projects query and return a ProjectConnection
   *
   * @param variables - variables without 'id' to pass into the CustomView_ProjectsQuery
   * @returns parsed response from CustomView_ProjectsQuery
   */
  public async fetch(variables?: Omit<L.CustomView_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection> {
    const response = await this._request<L.CustomView_ProjectsQuery, L.CustomView_ProjectsQueryVariables>(
      L.CustomView_ProjectsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.customView.projects;

    return new ProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable CustomView_UserViewPreferences Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView
 */
export class CustomView_UserViewPreferencesQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the CustomView_UserViewPreferences query and return a ViewPreferences
   *
   * @returns parsed response from CustomView_UserViewPreferencesQuery
   */
  public async fetch(): LinearFetch<ViewPreferences | undefined> {
    const response = await this._request<
      L.CustomView_UserViewPreferencesQuery,
      L.CustomView_UserViewPreferencesQueryVariables
    >(L.CustomView_UserViewPreferencesDocument, {
      id: this._id,
    });
    const data = response.customView.userViewPreferences;

    return data ? new ViewPreferences(this._request, data) : undefined;
  }
}

/**
 * A fetchable CustomView_ViewPreferencesValues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView
 */
export class CustomView_ViewPreferencesValuesQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the CustomView_ViewPreferencesValues query and return a ViewPreferencesValues
   *
   * @returns parsed response from CustomView_ViewPreferencesValuesQuery
   */
  public async fetch(): LinearFetch<ViewPreferencesValues | undefined> {
    const response = await this._request<
      L.CustomView_ViewPreferencesValuesQuery,
      L.CustomView_ViewPreferencesValuesQueryVariables
    >(L.CustomView_ViewPreferencesValuesDocument, {
      id: this._id,
    });
    const data = response.customView.viewPreferencesValues;

    return data ? new ViewPreferencesValues(this._request, data) : undefined;
  }
}

/**
 * A fetchable CustomView_OrganizationViewPreferences_Preferences Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView_organizationViewPreferences
 */
export class CustomView_OrganizationViewPreferences_PreferencesQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the CustomView_OrganizationViewPreferences_Preferences query and return a ViewPreferencesValues
   *
   * @returns parsed response from CustomView_OrganizationViewPreferences_PreferencesQuery
   */
  public async fetch(): LinearFetch<ViewPreferencesValues | undefined> {
    const response = await this._request<
      L.CustomView_OrganizationViewPreferences_PreferencesQuery,
      L.CustomView_OrganizationViewPreferences_PreferencesQueryVariables
    >(L.CustomView_OrganizationViewPreferences_PreferencesDocument, {
      id: this._id,
    });
    const data = response.customView.organizationViewPreferences?.preferences;

    return data ? new ViewPreferencesValues(this._request, data) : undefined;
  }
}

/**
 * A fetchable CustomView_UserViewPreferences_Preferences Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to customView_userViewPreferences
 */
export class CustomView_UserViewPreferences_PreferencesQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the CustomView_UserViewPreferences_Preferences query and return a ViewPreferencesValues
   *
   * @returns parsed response from CustomView_UserViewPreferences_PreferencesQuery
   */
  public async fetch(): LinearFetch<ViewPreferencesValues | undefined> {
    const response = await this._request<
      L.CustomView_UserViewPreferences_PreferencesQuery,
      L.CustomView_UserViewPreferences_PreferencesQueryVariables
    >(L.CustomView_UserViewPreferences_PreferencesDocument, {
      id: this._id,
    });
    const data = response.customView.userViewPreferences?.preferences;

    return data ? new ViewPreferencesValues(this._request, data) : undefined;
  }
}

/**
 * A fetchable Cycle_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to cycle
 * @param variables - variables without 'id' to pass into the Cycle_IssuesQuery
 */
export class Cycle_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Cycle_IssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Cycle_IssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Cycle_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the Cycle_IssuesQuery
   * @returns parsed response from Cycle_IssuesQuery
   */
  public async fetch(variables?: Omit<L.Cycle_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.Cycle_IssuesQuery, L.Cycle_IssuesQueryVariables>(L.Cycle_IssuesDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.cycle.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Cycle_UncompletedIssuesUponClose Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to cycle
 * @param variables - variables without 'id' to pass into the Cycle_UncompletedIssuesUponCloseQuery
 */
export class Cycle_UncompletedIssuesUponCloseQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Cycle_UncompletedIssuesUponClose query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the Cycle_UncompletedIssuesUponCloseQuery
   * @returns parsed response from Cycle_UncompletedIssuesUponCloseQuery
   */
  public async fetch(
    variables?: Omit<L.Cycle_UncompletedIssuesUponCloseQueryVariables, "id">
  ): LinearFetch<IssueConnection> {
    const response = await this._request<
      L.Cycle_UncompletedIssuesUponCloseQuery,
      L.Cycle_UncompletedIssuesUponCloseQueryVariables
    >(L.Cycle_UncompletedIssuesUponCloseDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.cycle.uncompletedIssuesUponClose;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Document_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to document
 * @param variables - variables without 'id' to pass into the Document_CommentsQuery
 */
export class Document_CommentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Document_CommentsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Document_CommentsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Document_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'id' to pass into the Document_CommentsQuery
   * @returns parsed response from Document_CommentsQuery
   */
  public async fetch(variables?: Omit<L.Document_CommentsQueryVariables, "id">): LinearFetch<CommentConnection> {
    const response = await this._request<L.Document_CommentsQuery, L.Document_CommentsQueryVariables>(
      L.Document_CommentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.document.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable EmailIntakeAddress_SesDomainIdentity Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to emailIntakeAddress
 */
export class EmailIntakeAddress_SesDomainIdentityQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the EmailIntakeAddress_SesDomainIdentity query and return a SesDomainIdentity
   *
   * @returns parsed response from EmailIntakeAddress_SesDomainIdentityQuery
   */
  public async fetch(): LinearFetch<SesDomainIdentity | undefined> {
    const response = await this._request<
      L.EmailIntakeAddress_SesDomainIdentityQuery,
      L.EmailIntakeAddress_SesDomainIdentityQueryVariables
    >(L.EmailIntakeAddress_SesDomainIdentityDocument, {
      id: this._id,
    });
    const data = response.emailIntakeAddress.sesDomainIdentity;

    return data ? new SesDomainIdentity(this._request, data) : undefined;
  }
}

/**
 * A fetchable Favorite_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to favorite
 * @param variables - variables without 'id' to pass into the Favorite_ChildrenQuery
 */
export class Favorite_ChildrenQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Favorite_Children query and return a FavoriteConnection
   *
   * @param variables - variables without 'id' to pass into the Favorite_ChildrenQuery
   * @returns parsed response from Favorite_ChildrenQuery
   */
  public async fetch(variables?: Omit<L.Favorite_ChildrenQueryVariables, "id">): LinearFetch<FavoriteConnection> {
    const response = await this._request<L.Favorite_ChildrenQuery, L.Favorite_ChildrenQueryVariables>(
      L.Favorite_ChildrenDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.favorite.children;

    return new FavoriteConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiative_DocumentContent Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiative
 */
export class Initiative_DocumentContentQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the Initiative_DocumentContent query and return a DocumentContent
   *
   * @returns parsed response from Initiative_DocumentContentQuery
   */
  public async fetch(): LinearFetch<DocumentContent | undefined> {
    const response = await this._request<L.Initiative_DocumentContentQuery, L.Initiative_DocumentContentQueryVariables>(
      L.Initiative_DocumentContentDocument,
      {
        id: this._id,
      }
    );
    const data = response.initiative.documentContent;

    return data ? new DocumentContent(this._request, data) : undefined;
  }
}

/**
 * A fetchable Initiative_Documents Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiative
 * @param variables - variables without 'id' to pass into the Initiative_DocumentsQuery
 */
export class Initiative_DocumentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Initiative_DocumentsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Initiative_DocumentsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Initiative_Documents query and return a DocumentConnection
   *
   * @param variables - variables without 'id' to pass into the Initiative_DocumentsQuery
   * @returns parsed response from Initiative_DocumentsQuery
   */
  public async fetch(variables?: Omit<L.Initiative_DocumentsQueryVariables, "id">): LinearFetch<DocumentConnection> {
    const response = await this._request<L.Initiative_DocumentsQuery, L.Initiative_DocumentsQueryVariables>(
      L.Initiative_DocumentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.initiative.documents;

    return new DocumentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiative_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiative
 * @param variables - variables without 'id' to pass into the Initiative_HistoryQuery
 */
export class Initiative_HistoryQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Initiative_HistoryQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Initiative_HistoryQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Initiative_History query and return a InitiativeHistoryConnection
   *
   * @param variables - variables without 'id' to pass into the Initiative_HistoryQuery
   * @returns parsed response from Initiative_HistoryQuery
   */
  public async fetch(
    variables?: Omit<L.Initiative_HistoryQueryVariables, "id">
  ): LinearFetch<InitiativeHistoryConnection> {
    const response = await this._request<L.Initiative_HistoryQuery, L.Initiative_HistoryQueryVariables>(
      L.Initiative_HistoryDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.initiative.history;

    return new InitiativeHistoryConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiative_Links Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiative
 * @param variables - variables without 'id' to pass into the Initiative_LinksQuery
 */
export class Initiative_LinksQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Initiative_LinksQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Initiative_LinksQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Initiative_Links query and return a EntityExternalLinkConnection
   *
   * @param variables - variables without 'id' to pass into the Initiative_LinksQuery
   * @returns parsed response from Initiative_LinksQuery
   */
  public async fetch(
    variables?: Omit<L.Initiative_LinksQueryVariables, "id">
  ): LinearFetch<EntityExternalLinkConnection> {
    const response = await this._request<L.Initiative_LinksQuery, L.Initiative_LinksQueryVariables>(
      L.Initiative_LinksDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.initiative.links;

    return new EntityExternalLinkConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiative_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiative
 * @param variables - variables without 'id' to pass into the Initiative_ProjectsQuery
 */
export class Initiative_ProjectsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Initiative_ProjectsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Initiative_ProjectsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Initiative_Projects query and return a ProjectConnection
   *
   * @param variables - variables without 'id' to pass into the Initiative_ProjectsQuery
   * @returns parsed response from Initiative_ProjectsQuery
   */
  public async fetch(variables?: Omit<L.Initiative_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection> {
    const response = await this._request<L.Initiative_ProjectsQuery, L.Initiative_ProjectsQueryVariables>(
      L.Initiative_ProjectsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.initiative.projects;

    return new ProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Initiative_SubInitiatives Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiative
 * @param variables - variables without 'id' to pass into the Initiative_SubInitiativesQuery
 */
export class Initiative_SubInitiativesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Initiative_SubInitiativesQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Initiative_SubInitiativesQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Initiative_SubInitiatives query and return a InitiativeConnection
   *
   * @param variables - variables without 'id' to pass into the Initiative_SubInitiativesQuery
   * @returns parsed response from Initiative_SubInitiativesQuery
   */
  public async fetch(
    variables?: Omit<L.Initiative_SubInitiativesQueryVariables, "id">
  ): LinearFetch<InitiativeConnection> {
    const response = await this._request<L.Initiative_SubInitiativesQuery, L.Initiative_SubInitiativesQueryVariables>(
      L.Initiative_SubInitiativesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.initiative.subInitiatives;

    return new InitiativeConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable InitiativeUpdate_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to initiativeUpdate
 * @param variables - variables without 'id' to pass into the InitiativeUpdate_CommentsQuery
 */
export class InitiativeUpdate_CommentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.InitiativeUpdate_CommentsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.InitiativeUpdate_CommentsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the InitiativeUpdate_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'id' to pass into the InitiativeUpdate_CommentsQuery
   * @returns parsed response from InitiativeUpdate_CommentsQuery
   */
  public async fetch(
    variables?: Omit<L.InitiativeUpdate_CommentsQueryVariables, "id">
  ): LinearFetch<CommentConnection> {
    const response = await this._request<L.InitiativeUpdate_CommentsQuery, L.InitiativeUpdate_CommentsQueryVariables>(
      L.InitiativeUpdate_CommentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.initiativeUpdate.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_AttachmentsQuery
 */
export class Issue_AttachmentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Attachments query and return a AttachmentConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_AttachmentsQuery
   * @returns parsed response from Issue_AttachmentsQuery
   */
  public async fetch(variables?: Omit<L.Issue_AttachmentsQueryVariables, "id">): LinearFetch<AttachmentConnection> {
    const response = await this._request<L.Issue_AttachmentsQuery, L.Issue_AttachmentsQueryVariables>(
      L.Issue_AttachmentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.attachments;

    return new AttachmentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_BotActor Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 */
export class Issue_BotActorQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the Issue_BotActor query and return a ActorBot
   *
   * @returns parsed response from Issue_BotActorQuery
   */
  public async fetch(): LinearFetch<ActorBot | undefined> {
    const response = await this._request<L.Issue_BotActorQuery, L.Issue_BotActorQueryVariables>(
      L.Issue_BotActorDocument,
      {
        id: this._id,
      }
    );
    const data = response.issue.botActor;

    return data ? new ActorBot(this._request, data) : undefined;
  }
}

/**
 * A fetchable Issue_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_ChildrenQuery
 */
export class Issue_ChildrenQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_ChildrenQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_ChildrenQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Children query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_ChildrenQuery
   * @returns parsed response from Issue_ChildrenQuery
   */
  public async fetch(variables?: Omit<L.Issue_ChildrenQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.Issue_ChildrenQuery, L.Issue_ChildrenQueryVariables>(
      L.Issue_ChildrenDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.children;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_CommentsQuery
 */
export class Issue_CommentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_CommentsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_CommentsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_CommentsQuery
   * @returns parsed response from Issue_CommentsQuery
   */
  public async fetch(variables?: Omit<L.Issue_CommentsQueryVariables, "id">): LinearFetch<CommentConnection> {
    const response = await this._request<L.Issue_CommentsQuery, L.Issue_CommentsQueryVariables>(
      L.Issue_CommentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_FormerAttachments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_FormerAttachmentsQuery
 */
export class Issue_FormerAttachmentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_FormerAttachmentsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Issue_FormerAttachmentsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_FormerAttachments query and return a AttachmentConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_FormerAttachmentsQuery
   * @returns parsed response from Issue_FormerAttachmentsQuery
   */
  public async fetch(
    variables?: Omit<L.Issue_FormerAttachmentsQueryVariables, "id">
  ): LinearFetch<AttachmentConnection> {
    const response = await this._request<L.Issue_FormerAttachmentsQuery, L.Issue_FormerAttachmentsQueryVariables>(
      L.Issue_FormerAttachmentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.formerAttachments;

    return new AttachmentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_FormerNeeds Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_FormerNeedsQuery
 */
export class Issue_FormerNeedsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_FormerNeedsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_FormerNeedsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_FormerNeeds query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_FormerNeedsQuery
   * @returns parsed response from Issue_FormerNeedsQuery
   */
  public async fetch(variables?: Omit<L.Issue_FormerNeedsQueryVariables, "id">): LinearFetch<CustomerNeedConnection> {
    const response = await this._request<L.Issue_FormerNeedsQuery, L.Issue_FormerNeedsQueryVariables>(
      L.Issue_FormerNeedsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.formerNeeds;

    return new CustomerNeedConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_HistoryQuery
 */
export class Issue_HistoryQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_HistoryQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_HistoryQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_History query and return a IssueHistoryConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_HistoryQuery
   * @returns parsed response from Issue_HistoryQuery
   */
  public async fetch(variables?: Omit<L.Issue_HistoryQueryVariables, "id">): LinearFetch<IssueHistoryConnection> {
    const response = await this._request<L.Issue_HistoryQuery, L.Issue_HistoryQueryVariables>(L.Issue_HistoryDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.issue.history;

    return new IssueHistoryConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_InverseRelationsQuery
 */
export class Issue_InverseRelationsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_InverseRelations query and return a IssueRelationConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_InverseRelationsQuery
   * @returns parsed response from Issue_InverseRelationsQuery
   */
  public async fetch(
    variables?: Omit<L.Issue_InverseRelationsQueryVariables, "id">
  ): LinearFetch<IssueRelationConnection> {
    const response = await this._request<L.Issue_InverseRelationsQuery, L.Issue_InverseRelationsQueryVariables>(
      L.Issue_InverseRelationsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.inverseRelations;

    return new IssueRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_LabelsQuery
 */
export class Issue_LabelsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_LabelsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_LabelsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Labels query and return a IssueLabelConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_LabelsQuery
   * @returns parsed response from Issue_LabelsQuery
   */
  public async fetch(variables?: Omit<L.Issue_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection> {
    const response = await this._request<L.Issue_LabelsQuery, L.Issue_LabelsQueryVariables>(L.Issue_LabelsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.issue.labels;

    return new IssueLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_Needs Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_NeedsQuery
 */
export class Issue_NeedsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_NeedsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_NeedsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Needs query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_NeedsQuery
   * @returns parsed response from Issue_NeedsQuery
   */
  public async fetch(variables?: Omit<L.Issue_NeedsQueryVariables, "id">): LinearFetch<CustomerNeedConnection> {
    const response = await this._request<L.Issue_NeedsQuery, L.Issue_NeedsQueryVariables>(L.Issue_NeedsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.issue.needs;

    return new CustomerNeedConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_RelationsQuery
 */
export class Issue_RelationsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_RelationsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_RelationsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Relations query and return a IssueRelationConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_RelationsQuery
   * @returns parsed response from Issue_RelationsQuery
   */
  public async fetch(variables?: Omit<L.Issue_RelationsQueryVariables, "id">): LinearFetch<IssueRelationConnection> {
    const response = await this._request<L.Issue_RelationsQuery, L.Issue_RelationsQueryVariables>(
      L.Issue_RelationsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.relations;

    return new IssueRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Issue_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issue
 * @param variables - variables without 'id' to pass into the Issue_SubscribersQuery
 */
export class Issue_SubscribersQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Issue_SubscribersQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Issue_SubscribersQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Issue_Subscribers query and return a UserConnection
   *
   * @param variables - variables without 'id' to pass into the Issue_SubscribersQuery
   * @returns parsed response from Issue_SubscribersQuery
   */
  public async fetch(variables?: Omit<L.Issue_SubscribersQueryVariables, "id">): LinearFetch<UserConnection> {
    const response = await this._request<L.Issue_SubscribersQuery, L.Issue_SubscribersQueryVariables>(
      L.Issue_SubscribersDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issue.subscribers;

    return new UserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssueLabel_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issueLabel
 * @param variables - variables without 'id' to pass into the IssueLabel_ChildrenQuery
 */
export class IssueLabel_ChildrenQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the IssueLabel_Children query and return a IssueLabelConnection
   *
   * @param variables - variables without 'id' to pass into the IssueLabel_ChildrenQuery
   * @returns parsed response from IssueLabel_ChildrenQuery
   */
  public async fetch(variables?: Omit<L.IssueLabel_ChildrenQueryVariables, "id">): LinearFetch<IssueLabelConnection> {
    const response = await this._request<L.IssueLabel_ChildrenQuery, L.IssueLabel_ChildrenQueryVariables>(
      L.IssueLabel_ChildrenDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issueLabel.children;

    return new IssueLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssueLabel_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to issueLabel
 * @param variables - variables without 'id' to pass into the IssueLabel_IssuesQuery
 */
export class IssueLabel_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the IssueLabel_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the IssueLabel_IssuesQuery
   * @returns parsed response from IssueLabel_IssuesQuery
   */
  public async fetch(variables?: Omit<L.IssueLabel_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.IssueLabel_IssuesQuery, L.IssueLabel_IssuesQueryVariables>(
      L.IssueLabel_IssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issueLabel.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Attachments Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_AttachmentsQuery
 */
export class IssueVcsBranchSearch_AttachmentsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_AttachmentsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_AttachmentsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Attachments query and return a AttachmentConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_AttachmentsQuery
   * @returns parsed response from IssueVcsBranchSearch_AttachmentsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_AttachmentsQueryVariables, "branchName">
  ): LinearFetch<AttachmentConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_AttachmentsQuery,
      L.IssueVcsBranchSearch_AttachmentsQueryVariables
    >(L.IssueVcsBranchSearch_AttachmentsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.attachments;
    if (data) {
      return new AttachmentConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_BotActor Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 */
export class IssueVcsBranchSearch_BotActorQuery extends Request {
  private _branchName: string;

  public constructor(request: LinearRequest, branchName: string) {
    super(request);
    this._branchName = branchName;
  }

  /**
   * Call the IssueVcsBranchSearch_BotActor query and return a ActorBot
   *
   * @returns parsed response from IssueVcsBranchSearch_BotActorQuery
   */
  public async fetch(): LinearFetch<ActorBot | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_BotActorQuery,
      L.IssueVcsBranchSearch_BotActorQueryVariables
    >(L.IssueVcsBranchSearch_BotActorDocument, {
      branchName: this._branchName,
    });
    const data = response.issueVcsBranchSearch?.botActor;

    return data ? new ActorBot(this._request, data) : undefined;
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Children Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_ChildrenQuery
 */
export class IssueVcsBranchSearch_ChildrenQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_ChildrenQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_ChildrenQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Children query and return a IssueConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_ChildrenQuery
   * @returns parsed response from IssueVcsBranchSearch_ChildrenQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_ChildrenQueryVariables, "branchName">
  ): LinearFetch<IssueConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_ChildrenQuery,
      L.IssueVcsBranchSearch_ChildrenQueryVariables
    >(L.IssueVcsBranchSearch_ChildrenDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.children;
    if (data) {
      return new IssueConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Comments Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_CommentsQuery
 */
export class IssueVcsBranchSearch_CommentsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_CommentsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_CommentsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_CommentsQuery
   * @returns parsed response from IssueVcsBranchSearch_CommentsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_CommentsQueryVariables, "branchName">
  ): LinearFetch<CommentConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_CommentsQuery,
      L.IssueVcsBranchSearch_CommentsQueryVariables
    >(L.IssueVcsBranchSearch_CommentsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.comments;
    if (data) {
      return new CommentConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_FormerAttachments Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_FormerAttachmentsQuery
 */
export class IssueVcsBranchSearch_FormerAttachmentsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_FormerAttachmentsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_FormerAttachmentsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_FormerAttachments query and return a AttachmentConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_FormerAttachmentsQuery
   * @returns parsed response from IssueVcsBranchSearch_FormerAttachmentsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_FormerAttachmentsQueryVariables, "branchName">
  ): LinearFetch<AttachmentConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_FormerAttachmentsQuery,
      L.IssueVcsBranchSearch_FormerAttachmentsQueryVariables
    >(L.IssueVcsBranchSearch_FormerAttachmentsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.formerAttachments;
    if (data) {
      return new AttachmentConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_FormerNeeds Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_FormerNeedsQuery
 */
export class IssueVcsBranchSearch_FormerNeedsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_FormerNeedsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_FormerNeedsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_FormerNeeds query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_FormerNeedsQuery
   * @returns parsed response from IssueVcsBranchSearch_FormerNeedsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_FormerNeedsQueryVariables, "branchName">
  ): LinearFetch<CustomerNeedConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_FormerNeedsQuery,
      L.IssueVcsBranchSearch_FormerNeedsQueryVariables
    >(L.IssueVcsBranchSearch_FormerNeedsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.formerNeeds;
    if (data) {
      return new CustomerNeedConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_History Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_HistoryQuery
 */
export class IssueVcsBranchSearch_HistoryQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_HistoryQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_HistoryQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_History query and return a IssueHistoryConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_HistoryQuery
   * @returns parsed response from IssueVcsBranchSearch_HistoryQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_HistoryQueryVariables, "branchName">
  ): LinearFetch<IssueHistoryConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_HistoryQuery,
      L.IssueVcsBranchSearch_HistoryQueryVariables
    >(L.IssueVcsBranchSearch_HistoryDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.history;
    if (data) {
      return new IssueHistoryConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_InverseRelationsQuery
 */
export class IssueVcsBranchSearch_InverseRelationsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_InverseRelationsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_InverseRelationsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_InverseRelations query and return a IssueRelationConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_InverseRelationsQuery
   * @returns parsed response from IssueVcsBranchSearch_InverseRelationsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_InverseRelationsQueryVariables, "branchName">
  ): LinearFetch<IssueRelationConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_InverseRelationsQuery,
      L.IssueVcsBranchSearch_InverseRelationsQueryVariables
    >(L.IssueVcsBranchSearch_InverseRelationsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.inverseRelations;
    if (data) {
      return new IssueRelationConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Labels Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_LabelsQuery
 */
export class IssueVcsBranchSearch_LabelsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_LabelsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_LabelsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Labels query and return a IssueLabelConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_LabelsQuery
   * @returns parsed response from IssueVcsBranchSearch_LabelsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_LabelsQueryVariables, "branchName">
  ): LinearFetch<IssueLabelConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_LabelsQuery,
      L.IssueVcsBranchSearch_LabelsQueryVariables
    >(L.IssueVcsBranchSearch_LabelsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.labels;
    if (data) {
      return new IssueLabelConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Needs Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_NeedsQuery
 */
export class IssueVcsBranchSearch_NeedsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_NeedsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_NeedsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Needs query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_NeedsQuery
   * @returns parsed response from IssueVcsBranchSearch_NeedsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_NeedsQueryVariables, "branchName">
  ): LinearFetch<CustomerNeedConnection | undefined> {
    const response = await this._request<L.IssueVcsBranchSearch_NeedsQuery, L.IssueVcsBranchSearch_NeedsQueryVariables>(
      L.IssueVcsBranchSearch_NeedsDocument,
      {
        branchName: this._branchName,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.issueVcsBranchSearch?.needs;
    if (data) {
      return new CustomerNeedConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Relations Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_RelationsQuery
 */
export class IssueVcsBranchSearch_RelationsQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_RelationsQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_RelationsQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Relations query and return a IssueRelationConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_RelationsQuery
   * @returns parsed response from IssueVcsBranchSearch_RelationsQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_RelationsQueryVariables, "branchName">
  ): LinearFetch<IssueRelationConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_RelationsQuery,
      L.IssueVcsBranchSearch_RelationsQueryVariables
    >(L.IssueVcsBranchSearch_RelationsDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.relations;
    if (data) {
      return new IssueRelationConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable IssueVcsBranchSearch_Subscribers Query
 *
 * @param request - function to call the graphql client
 * @param branchName - required branchName to pass to issueVcsBranchSearch
 * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_SubscribersQuery
 */
export class IssueVcsBranchSearch_SubscribersQuery extends Request {
  private _branchName: string;
  private _variables?: Omit<L.IssueVcsBranchSearch_SubscribersQueryVariables, "branchName">;

  public constructor(
    request: LinearRequest,
    branchName: string,
    variables?: Omit<L.IssueVcsBranchSearch_SubscribersQueryVariables, "branchName">
  ) {
    super(request);
    this._branchName = branchName;
    this._variables = variables;
  }

  /**
   * Call the IssueVcsBranchSearch_Subscribers query and return a UserConnection
   *
   * @param variables - variables without 'branchName' to pass into the IssueVcsBranchSearch_SubscribersQuery
   * @returns parsed response from IssueVcsBranchSearch_SubscribersQuery
   */
  public async fetch(
    variables?: Omit<L.IssueVcsBranchSearch_SubscribersQueryVariables, "branchName">
  ): LinearFetch<UserConnection | undefined> {
    const response = await this._request<
      L.IssueVcsBranchSearch_SubscribersQuery,
      L.IssueVcsBranchSearch_SubscribersQueryVariables
    >(L.IssueVcsBranchSearch_SubscribersDocument, {
      branchName: this._branchName,
      ...this._variables,
      ...variables,
    });
    const data = response.issueVcsBranchSearch?.subscribers;
    if (data) {
      return new UserConnection(
        this._request,
        connection =>
          this.fetch(
            defaultConnection({
              ...this._variables,
              ...variables,
              ...connection,
            })
          ),
        data
      );
    } else {
      return undefined;
    }
  }
}

/**
 * A fetchable Organization_Integrations Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_IntegrationsQuery
 */
export class Organization_IntegrationsQuery extends Request {
  private _variables?: L.Organization_IntegrationsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Organization_IntegrationsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Organization_Integrations query and return a IntegrationConnection
   *
   * @param variables - variables to pass into the Organization_IntegrationsQuery
   * @returns parsed response from Organization_IntegrationsQuery
   */
  public async fetch(variables?: L.Organization_IntegrationsQueryVariables): LinearFetch<IntegrationConnection> {
    const response = await this._request<L.Organization_IntegrationsQuery, L.Organization_IntegrationsQueryVariables>(
      L.Organization_IntegrationsDocument,
      variables
    );
    const data = response.organization.integrations;

    return new IntegrationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Organization_Labels Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_LabelsQuery
 */
export class Organization_LabelsQuery extends Request {
  private _variables?: L.Organization_LabelsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Organization_LabelsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Organization_Labels query and return a IssueLabelConnection
   *
   * @param variables - variables to pass into the Organization_LabelsQuery
   * @returns parsed response from Organization_LabelsQuery
   */
  public async fetch(variables?: L.Organization_LabelsQueryVariables): LinearFetch<IssueLabelConnection> {
    const response = await this._request<L.Organization_LabelsQuery, L.Organization_LabelsQueryVariables>(
      L.Organization_LabelsDocument,
      variables
    );
    const data = response.organization.labels;

    return new IssueLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Organization_ProjectLabels Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_ProjectLabelsQuery
 */
export class Organization_ProjectLabelsQuery extends Request {
  private _variables?: L.Organization_ProjectLabelsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Organization_ProjectLabelsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Organization_ProjectLabels query and return a ProjectLabelConnection
   *
   * @param variables - variables to pass into the Organization_ProjectLabelsQuery
   * @returns parsed response from Organization_ProjectLabelsQuery
   */
  public async fetch(variables?: L.Organization_ProjectLabelsQueryVariables): LinearFetch<ProjectLabelConnection> {
    const response = await this._request<L.Organization_ProjectLabelsQuery, L.Organization_ProjectLabelsQueryVariables>(
      L.Organization_ProjectLabelsDocument,
      variables
    );
    const data = response.organization.projectLabels;

    return new ProjectLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Organization_Subscription Query
 *
 * @param request - function to call the graphql client
 */
export class Organization_SubscriptionQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the Organization_Subscription query and return a PaidSubscription
   *
   * @returns parsed response from Organization_SubscriptionQuery
   */
  public async fetch(): LinearFetch<PaidSubscription | undefined> {
    const response = await this._request<L.Organization_SubscriptionQuery, L.Organization_SubscriptionQueryVariables>(
      L.Organization_SubscriptionDocument,
      {}
    );
    const data = response.organization.subscription;

    return data ? new PaidSubscription(this._request, data) : undefined;
  }
}

/**
 * A fetchable Organization_Teams Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_TeamsQuery
 */
export class Organization_TeamsQuery extends Request {
  private _variables?: L.Organization_TeamsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Organization_TeamsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Organization_Teams query and return a TeamConnection
   *
   * @param variables - variables to pass into the Organization_TeamsQuery
   * @returns parsed response from Organization_TeamsQuery
   */
  public async fetch(variables?: L.Organization_TeamsQueryVariables): LinearFetch<TeamConnection> {
    const response = await this._request<L.Organization_TeamsQuery, L.Organization_TeamsQueryVariables>(
      L.Organization_TeamsDocument,
      variables
    );
    const data = response.organization.teams;

    return new TeamConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Organization_Templates Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_TemplatesQuery
 */
export class Organization_TemplatesQuery extends Request {
  private _variables?: L.Organization_TemplatesQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Organization_TemplatesQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Organization_Templates query and return a TemplateConnection
   *
   * @param variables - variables to pass into the Organization_TemplatesQuery
   * @returns parsed response from Organization_TemplatesQuery
   */
  public async fetch(variables?: L.Organization_TemplatesQueryVariables): LinearFetch<TemplateConnection> {
    const response = await this._request<L.Organization_TemplatesQuery, L.Organization_TemplatesQueryVariables>(
      L.Organization_TemplatesDocument,
      variables
    );
    const data = response.organization.templates;

    return new TemplateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Organization_Users Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Organization_UsersQuery
 */
export class Organization_UsersQuery extends Request {
  private _variables?: L.Organization_UsersQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Organization_UsersQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Organization_Users query and return a UserConnection
   *
   * @param variables - variables to pass into the Organization_UsersQuery
   * @returns parsed response from Organization_UsersQuery
   */
  public async fetch(variables?: L.Organization_UsersQueryVariables): LinearFetch<UserConnection> {
    const response = await this._request<L.Organization_UsersQuery, L.Organization_UsersQueryVariables>(
      L.Organization_UsersDocument,
      variables
    );
    const data = response.organization.users;

    return new UserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_CommentsQuery
 */
export class Project_CommentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_CommentsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_CommentsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'id' to pass into the Project_CommentsQuery
   * @returns parsed response from Project_CommentsQuery
   */
  public async fetch(variables?: Omit<L.Project_CommentsQueryVariables, "id">): LinearFetch<CommentConnection> {
    const response = await this._request<L.Project_CommentsQuery, L.Project_CommentsQueryVariables>(
      L.Project_CommentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_DocumentContent Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 */
export class Project_DocumentContentQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the Project_DocumentContent query and return a DocumentContent
   *
   * @returns parsed response from Project_DocumentContentQuery
   */
  public async fetch(): LinearFetch<DocumentContent | undefined> {
    const response = await this._request<L.Project_DocumentContentQuery, L.Project_DocumentContentQueryVariables>(
      L.Project_DocumentContentDocument,
      {
        id: this._id,
      }
    );
    const data = response.project.documentContent;

    return data ? new DocumentContent(this._request, data) : undefined;
  }
}

/**
 * A fetchable Project_Documents Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_DocumentsQuery
 */
export class Project_DocumentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_DocumentsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_DocumentsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Documents query and return a DocumentConnection
   *
   * @param variables - variables without 'id' to pass into the Project_DocumentsQuery
   * @returns parsed response from Project_DocumentsQuery
   */
  public async fetch(variables?: Omit<L.Project_DocumentsQueryVariables, "id">): LinearFetch<DocumentConnection> {
    const response = await this._request<L.Project_DocumentsQuery, L.Project_DocumentsQueryVariables>(
      L.Project_DocumentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.documents;

    return new DocumentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_ExternalLinks Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_ExternalLinksQuery
 */
export class Project_ExternalLinksQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_ExternalLinksQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Project_ExternalLinksQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_ExternalLinks query and return a EntityExternalLinkConnection
   *
   * @param variables - variables without 'id' to pass into the Project_ExternalLinksQuery
   * @returns parsed response from Project_ExternalLinksQuery
   */
  public async fetch(
    variables?: Omit<L.Project_ExternalLinksQueryVariables, "id">
  ): LinearFetch<EntityExternalLinkConnection> {
    const response = await this._request<L.Project_ExternalLinksQuery, L.Project_ExternalLinksQueryVariables>(
      L.Project_ExternalLinksDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.externalLinks;

    return new EntityExternalLinkConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_History Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_HistoryQuery
 */
export class Project_HistoryQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_HistoryQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_HistoryQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_History query and return a ProjectHistoryConnection
   *
   * @param variables - variables without 'id' to pass into the Project_HistoryQuery
   * @returns parsed response from Project_HistoryQuery
   */
  public async fetch(variables?: Omit<L.Project_HistoryQueryVariables, "id">): LinearFetch<ProjectHistoryConnection> {
    const response = await this._request<L.Project_HistoryQuery, L.Project_HistoryQueryVariables>(
      L.Project_HistoryDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.history;

    return new ProjectHistoryConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Initiatives Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_InitiativesQuery
 */
export class Project_InitiativesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_InitiativesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_InitiativesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Initiatives query and return a InitiativeConnection
   *
   * @param variables - variables without 'id' to pass into the Project_InitiativesQuery
   * @returns parsed response from Project_InitiativesQuery
   */
  public async fetch(variables?: Omit<L.Project_InitiativesQueryVariables, "id">): LinearFetch<InitiativeConnection> {
    const response = await this._request<L.Project_InitiativesQuery, L.Project_InitiativesQueryVariables>(
      L.Project_InitiativesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.initiatives;

    return new InitiativeConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_InverseRelations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_InverseRelationsQuery
 */
export class Project_InverseRelationsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_InverseRelationsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Project_InverseRelationsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_InverseRelations query and return a ProjectRelationConnection
   *
   * @param variables - variables without 'id' to pass into the Project_InverseRelationsQuery
   * @returns parsed response from Project_InverseRelationsQuery
   */
  public async fetch(
    variables?: Omit<L.Project_InverseRelationsQueryVariables, "id">
  ): LinearFetch<ProjectRelationConnection> {
    const response = await this._request<L.Project_InverseRelationsQuery, L.Project_InverseRelationsQueryVariables>(
      L.Project_InverseRelationsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.inverseRelations;

    return new ProjectRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_IssuesQuery
 */
export class Project_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_IssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_IssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the Project_IssuesQuery
   * @returns parsed response from Project_IssuesQuery
   */
  public async fetch(variables?: Omit<L.Project_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.Project_IssuesQuery, L.Project_IssuesQueryVariables>(
      L.Project_IssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_LabelsQuery
 */
export class Project_LabelsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_LabelsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_LabelsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Labels query and return a ProjectLabelConnection
   *
   * @param variables - variables without 'id' to pass into the Project_LabelsQuery
   * @returns parsed response from Project_LabelsQuery
   */
  public async fetch(variables?: Omit<L.Project_LabelsQueryVariables, "id">): LinearFetch<ProjectLabelConnection> {
    const response = await this._request<L.Project_LabelsQuery, L.Project_LabelsQueryVariables>(
      L.Project_LabelsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.labels;

    return new ProjectLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Members Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_MembersQuery
 */
export class Project_MembersQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_MembersQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_MembersQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Members query and return a UserConnection
   *
   * @param variables - variables without 'id' to pass into the Project_MembersQuery
   * @returns parsed response from Project_MembersQuery
   */
  public async fetch(variables?: Omit<L.Project_MembersQueryVariables, "id">): LinearFetch<UserConnection> {
    const response = await this._request<L.Project_MembersQuery, L.Project_MembersQueryVariables>(
      L.Project_MembersDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.members;

    return new UserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Needs Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_NeedsQuery
 */
export class Project_NeedsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_NeedsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_NeedsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Needs query and return a CustomerNeedConnection
   *
   * @param variables - variables without 'id' to pass into the Project_NeedsQuery
   * @returns parsed response from Project_NeedsQuery
   */
  public async fetch(variables?: Omit<L.Project_NeedsQueryVariables, "id">): LinearFetch<CustomerNeedConnection> {
    const response = await this._request<L.Project_NeedsQuery, L.Project_NeedsQueryVariables>(L.Project_NeedsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.project.needs;

    return new CustomerNeedConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_ProjectMilestones Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_ProjectMilestonesQuery
 */
export class Project_ProjectMilestonesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_ProjectMilestones query and return a ProjectMilestoneConnection
   *
   * @param variables - variables without 'id' to pass into the Project_ProjectMilestonesQuery
   * @returns parsed response from Project_ProjectMilestonesQuery
   */
  public async fetch(
    variables?: Omit<L.Project_ProjectMilestonesQueryVariables, "id">
  ): LinearFetch<ProjectMilestoneConnection> {
    const response = await this._request<L.Project_ProjectMilestonesQuery, L.Project_ProjectMilestonesQueryVariables>(
      L.Project_ProjectMilestonesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.projectMilestones;

    return new ProjectMilestoneConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_ProjectUpdates Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_ProjectUpdatesQuery
 */
export class Project_ProjectUpdatesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_ProjectUpdates query and return a ProjectUpdateConnection
   *
   * @param variables - variables without 'id' to pass into the Project_ProjectUpdatesQuery
   * @returns parsed response from Project_ProjectUpdatesQuery
   */
  public async fetch(
    variables?: Omit<L.Project_ProjectUpdatesQueryVariables, "id">
  ): LinearFetch<ProjectUpdateConnection> {
    const response = await this._request<L.Project_ProjectUpdatesQuery, L.Project_ProjectUpdatesQueryVariables>(
      L.Project_ProjectUpdatesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.projectUpdates;

    return new ProjectUpdateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Relations Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_RelationsQuery
 */
export class Project_RelationsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_RelationsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_RelationsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Relations query and return a ProjectRelationConnection
   *
   * @param variables - variables without 'id' to pass into the Project_RelationsQuery
   * @returns parsed response from Project_RelationsQuery
   */
  public async fetch(
    variables?: Omit<L.Project_RelationsQueryVariables, "id">
  ): LinearFetch<ProjectRelationConnection> {
    const response = await this._request<L.Project_RelationsQuery, L.Project_RelationsQueryVariables>(
      L.Project_RelationsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.project.relations;

    return new ProjectRelationConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Project_Teams Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to project
 * @param variables - variables without 'id' to pass into the Project_TeamsQuery
 */
export class Project_TeamsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Project_TeamsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Project_TeamsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Project_Teams query and return a TeamConnection
   *
   * @param variables - variables without 'id' to pass into the Project_TeamsQuery
   * @returns parsed response from Project_TeamsQuery
   */
  public async fetch(variables?: Omit<L.Project_TeamsQueryVariables, "id">): LinearFetch<TeamConnection> {
    const response = await this._request<L.Project_TeamsQuery, L.Project_TeamsQueryVariables>(L.Project_TeamsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.project.teams;

    return new TeamConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectLabel_Children Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to projectLabel
 * @param variables - variables without 'id' to pass into the ProjectLabel_ChildrenQuery
 */
export class ProjectLabel_ChildrenQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.ProjectLabel_ChildrenQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.ProjectLabel_ChildrenQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the ProjectLabel_Children query and return a ProjectLabelConnection
   *
   * @param variables - variables without 'id' to pass into the ProjectLabel_ChildrenQuery
   * @returns parsed response from ProjectLabel_ChildrenQuery
   */
  public async fetch(
    variables?: Omit<L.ProjectLabel_ChildrenQueryVariables, "id">
  ): LinearFetch<ProjectLabelConnection> {
    const response = await this._request<L.ProjectLabel_ChildrenQuery, L.ProjectLabel_ChildrenQueryVariables>(
      L.ProjectLabel_ChildrenDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.projectLabel.children;

    return new ProjectLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectLabel_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to projectLabel
 * @param variables - variables without 'id' to pass into the ProjectLabel_ProjectsQuery
 */
export class ProjectLabel_ProjectsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.ProjectLabel_ProjectsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.ProjectLabel_ProjectsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the ProjectLabel_Projects query and return a ProjectConnection
   *
   * @param variables - variables without 'id' to pass into the ProjectLabel_ProjectsQuery
   * @returns parsed response from ProjectLabel_ProjectsQuery
   */
  public async fetch(variables?: Omit<L.ProjectLabel_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection> {
    const response = await this._request<L.ProjectLabel_ProjectsQuery, L.ProjectLabel_ProjectsQueryVariables>(
      L.ProjectLabel_ProjectsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.projectLabel.projects;

    return new ProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectMilestone_DocumentContent Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to projectMilestone
 */
export class ProjectMilestone_DocumentContentQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the ProjectMilestone_DocumentContent query and return a DocumentContent
   *
   * @returns parsed response from ProjectMilestone_DocumentContentQuery
   */
  public async fetch(): LinearFetch<DocumentContent | undefined> {
    const response = await this._request<
      L.ProjectMilestone_DocumentContentQuery,
      L.ProjectMilestone_DocumentContentQueryVariables
    >(L.ProjectMilestone_DocumentContentDocument, {
      id: this._id,
    });
    const data = response.projectMilestone.documentContent;

    return data ? new DocumentContent(this._request, data) : undefined;
  }
}

/**
 * A fetchable ProjectMilestone_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to projectMilestone
 * @param variables - variables without 'id' to pass into the ProjectMilestone_IssuesQuery
 */
export class ProjectMilestone_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.ProjectMilestone_IssuesQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.ProjectMilestone_IssuesQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the ProjectMilestone_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the ProjectMilestone_IssuesQuery
   * @returns parsed response from ProjectMilestone_IssuesQuery
   */
  public async fetch(variables?: Omit<L.ProjectMilestone_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.ProjectMilestone_IssuesQuery, L.ProjectMilestone_IssuesQueryVariables>(
      L.ProjectMilestone_IssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.projectMilestone.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable ProjectUpdate_Comments Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to projectUpdate
 * @param variables - variables without 'id' to pass into the ProjectUpdate_CommentsQuery
 */
export class ProjectUpdate_CommentsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.ProjectUpdate_CommentsQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.ProjectUpdate_CommentsQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the ProjectUpdate_Comments query and return a CommentConnection
   *
   * @param variables - variables without 'id' to pass into the ProjectUpdate_CommentsQuery
   * @returns parsed response from ProjectUpdate_CommentsQuery
   */
  public async fetch(variables?: Omit<L.ProjectUpdate_CommentsQueryVariables, "id">): LinearFetch<CommentConnection> {
    const response = await this._request<L.ProjectUpdate_CommentsQuery, L.ProjectUpdate_CommentsQueryVariables>(
      L.ProjectUpdate_CommentsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.projectUpdate.comments;

    return new CommentConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Roadmap_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to roadmap
 * @param variables - variables without 'id' to pass into the Roadmap_ProjectsQuery
 */
export class Roadmap_ProjectsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Roadmap_Projects query and return a ProjectConnection
   *
   * @param variables - variables without 'id' to pass into the Roadmap_ProjectsQuery
   * @returns parsed response from Roadmap_ProjectsQuery
   */
  public async fetch(variables?: Omit<L.Roadmap_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection> {
    const response = await this._request<L.Roadmap_ProjectsQuery, L.Roadmap_ProjectsQueryVariables>(
      L.Roadmap_ProjectsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.roadmap.projects;

    return new ProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable SearchDocuments_ArchivePayload Query
 *
 * @param request - function to call the graphql client
 * @param term - required term to pass to searchDocuments
 * @param variables - variables without 'term' to pass into the SearchDocuments_ArchivePayloadQuery
 */
export class SearchDocuments_ArchivePayloadQuery extends Request {
  private _term: string;
  private _variables?: Omit<L.SearchDocuments_ArchivePayloadQueryVariables, "term">;

  public constructor(
    request: LinearRequest,
    term: string,
    variables?: Omit<L.SearchDocuments_ArchivePayloadQueryVariables, "term">
  ) {
    super(request);
    this._term = term;
    this._variables = variables;
  }

  /**
   * Call the SearchDocuments_ArchivePayload query and return a ArchiveResponse
   *
   * @param variables - variables without 'term' to pass into the SearchDocuments_ArchivePayloadQuery
   * @returns parsed response from SearchDocuments_ArchivePayloadQuery
   */
  public async fetch(
    variables?: Omit<L.SearchDocuments_ArchivePayloadQueryVariables, "term">
  ): LinearFetch<ArchiveResponse> {
    const response = await this._request<
      L.SearchDocuments_ArchivePayloadQuery,
      L.SearchDocuments_ArchivePayloadQueryVariables
    >(L.SearchDocuments_ArchivePayloadDocument, {
      term: this._term,
      ...this._variables,
      ...variables,
    });
    const data = response.searchDocuments.archivePayload;

    return new ArchiveResponse(this._request, data);
  }
}

/**
 * A fetchable SearchIssues_ArchivePayload Query
 *
 * @param request - function to call the graphql client
 * @param term - required term to pass to searchIssues
 * @param variables - variables without 'term' to pass into the SearchIssues_ArchivePayloadQuery
 */
export class SearchIssues_ArchivePayloadQuery extends Request {
  private _term: string;
  private _variables?: Omit<L.SearchIssues_ArchivePayloadQueryVariables, "term">;

  public constructor(
    request: LinearRequest,
    term: string,
    variables?: Omit<L.SearchIssues_ArchivePayloadQueryVariables, "term">
  ) {
    super(request);
    this._term = term;
    this._variables = variables;
  }

  /**
   * Call the SearchIssues_ArchivePayload query and return a ArchiveResponse
   *
   * @param variables - variables without 'term' to pass into the SearchIssues_ArchivePayloadQuery
   * @returns parsed response from SearchIssues_ArchivePayloadQuery
   */
  public async fetch(
    variables?: Omit<L.SearchIssues_ArchivePayloadQueryVariables, "term">
  ): LinearFetch<ArchiveResponse> {
    const response = await this._request<
      L.SearchIssues_ArchivePayloadQuery,
      L.SearchIssues_ArchivePayloadQueryVariables
    >(L.SearchIssues_ArchivePayloadDocument, {
      term: this._term,
      ...this._variables,
      ...variables,
    });
    const data = response.searchIssues.archivePayload;

    return new ArchiveResponse(this._request, data);
  }
}

/**
 * A fetchable SearchProjects_ArchivePayload Query
 *
 * @param request - function to call the graphql client
 * @param term - required term to pass to searchProjects
 * @param variables - variables without 'term' to pass into the SearchProjects_ArchivePayloadQuery
 */
export class SearchProjects_ArchivePayloadQuery extends Request {
  private _term: string;
  private _variables?: Omit<L.SearchProjects_ArchivePayloadQueryVariables, "term">;

  public constructor(
    request: LinearRequest,
    term: string,
    variables?: Omit<L.SearchProjects_ArchivePayloadQueryVariables, "term">
  ) {
    super(request);
    this._term = term;
    this._variables = variables;
  }

  /**
   * Call the SearchProjects_ArchivePayload query and return a ArchiveResponse
   *
   * @param variables - variables without 'term' to pass into the SearchProjects_ArchivePayloadQuery
   * @returns parsed response from SearchProjects_ArchivePayloadQuery
   */
  public async fetch(
    variables?: Omit<L.SearchProjects_ArchivePayloadQueryVariables, "term">
  ): LinearFetch<ArchiveResponse> {
    const response = await this._request<
      L.SearchProjects_ArchivePayloadQuery,
      L.SearchProjects_ArchivePayloadQueryVariables
    >(L.SearchProjects_ArchivePayloadDocument, {
      term: this._term,
      ...this._variables,
      ...variables,
    });
    const data = response.searchProjects.archivePayload;

    return new ArchiveResponse(this._request, data);
  }
}

/**
 * A fetchable Team_Cycles Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_CyclesQuery
 */
export class Team_CyclesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_CyclesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_CyclesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Cycles query and return a CycleConnection
   *
   * @param variables - variables without 'id' to pass into the Team_CyclesQuery
   * @returns parsed response from Team_CyclesQuery
   */
  public async fetch(variables?: Omit<L.Team_CyclesQueryVariables, "id">): LinearFetch<CycleConnection> {
    const response = await this._request<L.Team_CyclesQuery, L.Team_CyclesQueryVariables>(L.Team_CyclesDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.cycles;

    return new CycleConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_GitAutomationStates Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_GitAutomationStatesQuery
 */
export class Team_GitAutomationStatesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_GitAutomationStatesQueryVariables, "id">;

  public constructor(
    request: LinearRequest,
    id: string,
    variables?: Omit<L.Team_GitAutomationStatesQueryVariables, "id">
  ) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_GitAutomationStates query and return a GitAutomationStateConnection
   *
   * @param variables - variables without 'id' to pass into the Team_GitAutomationStatesQuery
   * @returns parsed response from Team_GitAutomationStatesQuery
   */
  public async fetch(
    variables?: Omit<L.Team_GitAutomationStatesQueryVariables, "id">
  ): LinearFetch<GitAutomationStateConnection> {
    const response = await this._request<L.Team_GitAutomationStatesQuery, L.Team_GitAutomationStatesQueryVariables>(
      L.Team_GitAutomationStatesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.team.gitAutomationStates;

    return new GitAutomationStateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_IssuesQuery
 */
export class Team_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_IssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_IssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the Team_IssuesQuery
   * @returns parsed response from Team_IssuesQuery
   */
  public async fetch(variables?: Omit<L.Team_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.Team_IssuesQuery, L.Team_IssuesQueryVariables>(L.Team_IssuesDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Labels Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_LabelsQuery
 */
export class Team_LabelsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_LabelsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_LabelsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Labels query and return a IssueLabelConnection
   *
   * @param variables - variables without 'id' to pass into the Team_LabelsQuery
   * @returns parsed response from Team_LabelsQuery
   */
  public async fetch(variables?: Omit<L.Team_LabelsQueryVariables, "id">): LinearFetch<IssueLabelConnection> {
    const response = await this._request<L.Team_LabelsQuery, L.Team_LabelsQueryVariables>(L.Team_LabelsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.labels;

    return new IssueLabelConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Members Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_MembersQuery
 */
export class Team_MembersQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_MembersQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_MembersQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Members query and return a UserConnection
   *
   * @param variables - variables without 'id' to pass into the Team_MembersQuery
   * @returns parsed response from Team_MembersQuery
   */
  public async fetch(variables?: Omit<L.Team_MembersQueryVariables, "id">): LinearFetch<UserConnection> {
    const response = await this._request<L.Team_MembersQuery, L.Team_MembersQueryVariables>(L.Team_MembersDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.members;

    return new UserConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Memberships Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_MembershipsQuery
 */
export class Team_MembershipsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_MembershipsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_MembershipsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Memberships query and return a TeamMembershipConnection
   *
   * @param variables - variables without 'id' to pass into the Team_MembershipsQuery
   * @returns parsed response from Team_MembershipsQuery
   */
  public async fetch(variables?: Omit<L.Team_MembershipsQueryVariables, "id">): LinearFetch<TeamMembershipConnection> {
    const response = await this._request<L.Team_MembershipsQuery, L.Team_MembershipsQueryVariables>(
      L.Team_MembershipsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.team.memberships;

    return new TeamMembershipConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Projects Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_ProjectsQuery
 */
export class Team_ProjectsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_ProjectsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_ProjectsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Projects query and return a ProjectConnection
   *
   * @param variables - variables without 'id' to pass into the Team_ProjectsQuery
   * @returns parsed response from Team_ProjectsQuery
   */
  public async fetch(variables?: Omit<L.Team_ProjectsQueryVariables, "id">): LinearFetch<ProjectConnection> {
    const response = await this._request<L.Team_ProjectsQuery, L.Team_ProjectsQueryVariables>(L.Team_ProjectsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.projects;

    return new ProjectConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_States Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_StatesQuery
 */
export class Team_StatesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_StatesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_StatesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_States query and return a WorkflowStateConnection
   *
   * @param variables - variables without 'id' to pass into the Team_StatesQuery
   * @returns parsed response from Team_StatesQuery
   */
  public async fetch(variables?: Omit<L.Team_StatesQueryVariables, "id">): LinearFetch<WorkflowStateConnection> {
    const response = await this._request<L.Team_StatesQuery, L.Team_StatesQueryVariables>(L.Team_StatesDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.states;

    return new WorkflowStateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Templates Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_TemplatesQuery
 */
export class Team_TemplatesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_TemplatesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_TemplatesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Templates query and return a TemplateConnection
   *
   * @param variables - variables without 'id' to pass into the Team_TemplatesQuery
   * @returns parsed response from Team_TemplatesQuery
   */
  public async fetch(variables?: Omit<L.Team_TemplatesQueryVariables, "id">): LinearFetch<TemplateConnection> {
    const response = await this._request<L.Team_TemplatesQuery, L.Team_TemplatesQueryVariables>(
      L.Team_TemplatesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.team.templates;

    return new TemplateConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Team_Webhooks Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to team
 * @param variables - variables without 'id' to pass into the Team_WebhooksQuery
 */
export class Team_WebhooksQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.Team_WebhooksQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.Team_WebhooksQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the Team_Webhooks query and return a WebhookConnection
   *
   * @param variables - variables without 'id' to pass into the Team_WebhooksQuery
   * @returns parsed response from Team_WebhooksQuery
   */
  public async fetch(variables?: Omit<L.Team_WebhooksQueryVariables, "id">): LinearFetch<WebhookConnection> {
    const response = await this._request<L.Team_WebhooksQuery, L.Team_WebhooksQueryVariables>(L.Team_WebhooksDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.team.webhooks;

    return new WebhookConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable TriageResponsibility_ManualSelection Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to triageResponsibility
 */
export class TriageResponsibility_ManualSelectionQuery extends Request {
  private _id: string;

  public constructor(request: LinearRequest, id: string) {
    super(request);
    this._id = id;
  }

  /**
   * Call the TriageResponsibility_ManualSelection query and return a TriageResponsibilityManualSelection
   *
   * @returns parsed response from TriageResponsibility_ManualSelectionQuery
   */
  public async fetch(): LinearFetch<TriageResponsibilityManualSelection | undefined> {
    const response = await this._request<
      L.TriageResponsibility_ManualSelectionQuery,
      L.TriageResponsibility_ManualSelectionQueryVariables
    >(L.TriageResponsibility_ManualSelectionDocument, {
      id: this._id,
    });
    const data = response.triageResponsibility.manualSelection;

    return data ? new TriageResponsibilityManualSelection(this._request, data) : undefined;
  }
}

/**
 * A fetchable User_AssignedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_AssignedIssuesQuery
 */
export class User_AssignedIssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the User_AssignedIssues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the User_AssignedIssuesQuery
   * @returns parsed response from User_AssignedIssuesQuery
   */
  public async fetch(variables?: Omit<L.User_AssignedIssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.User_AssignedIssuesQuery, L.User_AssignedIssuesQueryVariables>(
      L.User_AssignedIssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.user.assignedIssues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable User_CreatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_CreatedIssuesQuery
 */
export class User_CreatedIssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the User_CreatedIssues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the User_CreatedIssuesQuery
   * @returns parsed response from User_CreatedIssuesQuery
   */
  public async fetch(variables?: Omit<L.User_CreatedIssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.User_CreatedIssuesQuery, L.User_CreatedIssuesQueryVariables>(
      L.User_CreatedIssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.user.createdIssues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable User_DelegatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_DelegatedIssuesQuery
 */
export class User_DelegatedIssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.User_DelegatedIssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.User_DelegatedIssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the User_DelegatedIssues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the User_DelegatedIssuesQuery
   * @returns parsed response from User_DelegatedIssuesQuery
   */
  public async fetch(variables?: Omit<L.User_DelegatedIssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.User_DelegatedIssuesQuery, L.User_DelegatedIssuesQueryVariables>(
      L.User_DelegatedIssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.user.delegatedIssues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable User_Drafts Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_DraftsQuery
 */
export class User_DraftsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.User_DraftsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.User_DraftsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the User_Drafts query and return a DraftConnection
   *
   * @param variables - variables without 'id' to pass into the User_DraftsQuery
   * @returns parsed response from User_DraftsQuery
   */
  public async fetch(variables?: Omit<L.User_DraftsQueryVariables, "id">): LinearFetch<DraftConnection> {
    const response = await this._request<L.User_DraftsQuery, L.User_DraftsQueryVariables>(L.User_DraftsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.user.drafts;

    return new DraftConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable User_TeamMemberships Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_TeamMembershipsQuery
 */
export class User_TeamMembershipsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the User_TeamMemberships query and return a TeamMembershipConnection
   *
   * @param variables - variables without 'id' to pass into the User_TeamMembershipsQuery
   * @returns parsed response from User_TeamMembershipsQuery
   */
  public async fetch(
    variables?: Omit<L.User_TeamMembershipsQueryVariables, "id">
  ): LinearFetch<TeamMembershipConnection> {
    const response = await this._request<L.User_TeamMembershipsQuery, L.User_TeamMembershipsQueryVariables>(
      L.User_TeamMembershipsDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.user.teamMemberships;

    return new TeamMembershipConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable User_Teams Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to user
 * @param variables - variables without 'id' to pass into the User_TeamsQuery
 */
export class User_TeamsQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.User_TeamsQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.User_TeamsQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the User_Teams query and return a TeamConnection
   *
   * @param variables - variables without 'id' to pass into the User_TeamsQuery
   * @returns parsed response from User_TeamsQuery
   */
  public async fetch(variables?: Omit<L.User_TeamsQueryVariables, "id">): LinearFetch<TeamConnection> {
    const response = await this._request<L.User_TeamsQuery, L.User_TeamsQueryVariables>(L.User_TeamsDocument, {
      id: this._id,
      ...this._variables,
      ...variables,
    });
    const data = response.user.teams;

    return new TeamConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferencesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences query and return a NotificationCategoryPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferencesQuery
   */
  public async fetch(): LinearFetch<NotificationCategoryPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferencesQuery,
      L.UserSettings_NotificationCategoryPreferencesQueryVariables
    >(L.UserSettings_NotificationCategoryPreferencesDocument, {});
    const data = response.userSettings.notificationCategoryPreferences;

    return new NotificationCategoryPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationChannelPreferences Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationChannelPreferencesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationChannelPreferences query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationChannelPreferencesQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationChannelPreferencesQuery,
      L.UserSettings_NotificationChannelPreferencesQueryVariables
    >(L.UserSettings_NotificationChannelPreferencesDocument, {});
    const data = response.userSettings.notificationChannelPreferences;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferencesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences query and return a NotificationDeliveryPreferences
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferencesQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferencesQuery,
      L.UserSettings_NotificationDeliveryPreferencesQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferencesDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences;

    return new NotificationDeliveryPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_AppsAndIntegrations Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_AppsAndIntegrationsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_AppsAndIntegrations query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_AppsAndIntegrationsQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_AppsAndIntegrationsQuery,
      L.UserSettings_NotificationCategoryPreferences_AppsAndIntegrationsQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_AppsAndIntegrationsDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.appsAndIntegrations;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Assignments Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_AssignmentsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Assignments query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_AssignmentsQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_AssignmentsQuery,
      L.UserSettings_NotificationCategoryPreferences_AssignmentsQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_AssignmentsDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.assignments;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_CommentsAndReplies Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_CommentsAndRepliesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_CommentsAndReplies query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_CommentsAndRepliesQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_CommentsAndRepliesQuery,
      L.UserSettings_NotificationCategoryPreferences_CommentsAndRepliesQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_CommentsAndRepliesDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.commentsAndReplies;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Customers Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_CustomersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Customers query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_CustomersQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_CustomersQuery,
      L.UserSettings_NotificationCategoryPreferences_CustomersQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_CustomersDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.customers;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_DocumentChanges Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_DocumentChangesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_DocumentChanges query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_DocumentChangesQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_DocumentChangesQuery,
      L.UserSettings_NotificationCategoryPreferences_DocumentChangesQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_DocumentChangesDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.documentChanges;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Feed Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_FeedQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Feed query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_FeedQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_FeedQuery,
      L.UserSettings_NotificationCategoryPreferences_FeedQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_FeedDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.feed;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Mentions Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_MentionsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Mentions query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_MentionsQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_MentionsQuery,
      L.UserSettings_NotificationCategoryPreferences_MentionsQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_MentionsDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.mentions;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_PostsAndUpdates Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_PostsAndUpdatesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_PostsAndUpdates query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_PostsAndUpdatesQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_PostsAndUpdatesQuery,
      L.UserSettings_NotificationCategoryPreferences_PostsAndUpdatesQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_PostsAndUpdatesDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.postsAndUpdates;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Reactions Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_ReactionsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Reactions query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_ReactionsQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_ReactionsQuery,
      L.UserSettings_NotificationCategoryPreferences_ReactionsQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_ReactionsDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.reactions;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Reminders Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_RemindersQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Reminders query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_RemindersQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_RemindersQuery,
      L.UserSettings_NotificationCategoryPreferences_RemindersQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_RemindersDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.reminders;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Reviews Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_ReviewsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Reviews query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_ReviewsQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_ReviewsQuery,
      L.UserSettings_NotificationCategoryPreferences_ReviewsQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_ReviewsDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.reviews;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_StatusChanges Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_StatusChangesQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_StatusChanges query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_StatusChangesQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_StatusChangesQuery,
      L.UserSettings_NotificationCategoryPreferences_StatusChangesQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_StatusChangesDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.statusChanges;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Subscriptions Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_SubscriptionsQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Subscriptions query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_SubscriptionsQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_SubscriptionsQuery,
      L.UserSettings_NotificationCategoryPreferences_SubscriptionsQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_SubscriptionsDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.subscriptions;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_System Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_SystemQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_System query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_SystemQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_SystemQuery,
      L.UserSettings_NotificationCategoryPreferences_SystemQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_SystemDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.system;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationCategoryPreferences_Triage Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationCategoryPreferences_TriageQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationCategoryPreferences_Triage query and return a NotificationChannelPreferences
   *
   * @returns parsed response from UserSettings_NotificationCategoryPreferences_TriageQuery
   */
  public async fetch(): LinearFetch<NotificationChannelPreferences> {
    const response = await this._request<
      L.UserSettings_NotificationCategoryPreferences_TriageQuery,
      L.UserSettings_NotificationCategoryPreferences_TriageQueryVariables
    >(L.UserSettings_NotificationCategoryPreferences_TriageDocument, {});
    const data = response.userSettings.notificationCategoryPreferences.triage;

    return new NotificationChannelPreferences(this._request, data);
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_MobileQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile query and return a NotificationDeliveryPreferencesChannel
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_MobileQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesChannel | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_MobileQuery,
      L.UserSettings_NotificationDeliveryPreferences_MobileQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_MobileDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile;

    return data ? new NotificationDeliveryPreferencesChannel(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_ScheduleQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule query and return a NotificationDeliveryPreferencesSchedule
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_ScheduleQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesSchedule | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_ScheduleQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_ScheduleQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_ScheduleDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule;

    return data ? new NotificationDeliveryPreferencesSchedule(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Friday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_FridayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Friday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_FridayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_FridayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_FridayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_FridayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.friday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Monday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_MondayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Monday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_MondayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_MondayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_MondayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_MondayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.monday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Saturday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SaturdayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Saturday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SaturdayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SaturdayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SaturdayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SaturdayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.saturday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Sunday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SundayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Sunday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SundayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SundayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SundayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_SundayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.sunday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Thursday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_ThursdayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Thursday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_ThursdayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_ThursdayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_ThursdayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_ThursdayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.thursday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Tuesday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_TuesdayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Tuesday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_TuesdayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_TuesdayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_TuesdayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_TuesdayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.tuesday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Wednesday Query
 *
 * @param request - function to call the graphql client
 */
export class UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_WednesdayQuery extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * Call the UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_Wednesday query and return a NotificationDeliveryPreferencesDay
   *
   * @returns parsed response from UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_WednesdayQuery
   */
  public async fetch(): LinearFetch<NotificationDeliveryPreferencesDay | undefined> {
    const response = await this._request<
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_WednesdayQuery,
      L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_WednesdayQueryVariables
    >(L.UserSettings_NotificationDeliveryPreferences_Mobile_Schedule_WednesdayDocument, {});
    const data = response.userSettings.notificationDeliveryPreferences.mobile?.schedule?.wednesday;

    return data ? new NotificationDeliveryPreferencesDay(this._request, data) : undefined;
  }
}

/**
 * A fetchable Viewer_AssignedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_AssignedIssuesQuery
 */
export class Viewer_AssignedIssuesQuery extends Request {
  private _variables?: L.Viewer_AssignedIssuesQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Viewer_AssignedIssuesQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Viewer_AssignedIssues query and return a IssueConnection
   *
   * @param variables - variables to pass into the Viewer_AssignedIssuesQuery
   * @returns parsed response from Viewer_AssignedIssuesQuery
   */
  public async fetch(variables?: L.Viewer_AssignedIssuesQueryVariables): LinearFetch<IssueConnection> {
    const response = await this._request<L.Viewer_AssignedIssuesQuery, L.Viewer_AssignedIssuesQueryVariables>(
      L.Viewer_AssignedIssuesDocument,
      variables
    );
    const data = response.viewer.assignedIssues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Viewer_CreatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_CreatedIssuesQuery
 */
export class Viewer_CreatedIssuesQuery extends Request {
  private _variables?: L.Viewer_CreatedIssuesQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Viewer_CreatedIssuesQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Viewer_CreatedIssues query and return a IssueConnection
   *
   * @param variables - variables to pass into the Viewer_CreatedIssuesQuery
   * @returns parsed response from Viewer_CreatedIssuesQuery
   */
  public async fetch(variables?: L.Viewer_CreatedIssuesQueryVariables): LinearFetch<IssueConnection> {
    const response = await this._request<L.Viewer_CreatedIssuesQuery, L.Viewer_CreatedIssuesQueryVariables>(
      L.Viewer_CreatedIssuesDocument,
      variables
    );
    const data = response.viewer.createdIssues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Viewer_DelegatedIssues Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_DelegatedIssuesQuery
 */
export class Viewer_DelegatedIssuesQuery extends Request {
  private _variables?: L.Viewer_DelegatedIssuesQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Viewer_DelegatedIssuesQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Viewer_DelegatedIssues query and return a IssueConnection
   *
   * @param variables - variables to pass into the Viewer_DelegatedIssuesQuery
   * @returns parsed response from Viewer_DelegatedIssuesQuery
   */
  public async fetch(variables?: L.Viewer_DelegatedIssuesQueryVariables): LinearFetch<IssueConnection> {
    const response = await this._request<L.Viewer_DelegatedIssuesQuery, L.Viewer_DelegatedIssuesQueryVariables>(
      L.Viewer_DelegatedIssuesDocument,
      variables
    );
    const data = response.viewer.delegatedIssues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Viewer_Drafts Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_DraftsQuery
 */
export class Viewer_DraftsQuery extends Request {
  private _variables?: L.Viewer_DraftsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Viewer_DraftsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Viewer_Drafts query and return a DraftConnection
   *
   * @param variables - variables to pass into the Viewer_DraftsQuery
   * @returns parsed response from Viewer_DraftsQuery
   */
  public async fetch(variables?: L.Viewer_DraftsQueryVariables): LinearFetch<DraftConnection> {
    const response = await this._request<L.Viewer_DraftsQuery, L.Viewer_DraftsQueryVariables>(
      L.Viewer_DraftsDocument,
      variables
    );
    const data = response.viewer.drafts;

    return new DraftConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Viewer_TeamMemberships Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_TeamMembershipsQuery
 */
export class Viewer_TeamMembershipsQuery extends Request {
  private _variables?: L.Viewer_TeamMembershipsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Viewer_TeamMembershipsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Viewer_TeamMemberships query and return a TeamMembershipConnection
   *
   * @param variables - variables to pass into the Viewer_TeamMembershipsQuery
   * @returns parsed response from Viewer_TeamMembershipsQuery
   */
  public async fetch(variables?: L.Viewer_TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection> {
    const response = await this._request<L.Viewer_TeamMembershipsQuery, L.Viewer_TeamMembershipsQueryVariables>(
      L.Viewer_TeamMembershipsDocument,
      variables
    );
    const data = response.viewer.teamMemberships;

    return new TeamMembershipConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable Viewer_Teams Query
 *
 * @param request - function to call the graphql client
 * @param variables - variables to pass into the Viewer_TeamsQuery
 */
export class Viewer_TeamsQuery extends Request {
  private _variables?: L.Viewer_TeamsQueryVariables;

  public constructor(request: LinearRequest, variables?: L.Viewer_TeamsQueryVariables) {
    super(request);

    this._variables = variables;
  }

  /**
   * Call the Viewer_Teams query and return a TeamConnection
   *
   * @param variables - variables to pass into the Viewer_TeamsQuery
   * @returns parsed response from Viewer_TeamsQuery
   */
  public async fetch(variables?: L.Viewer_TeamsQueryVariables): LinearFetch<TeamConnection> {
    const response = await this._request<L.Viewer_TeamsQuery, L.Viewer_TeamsQueryVariables>(
      L.Viewer_TeamsDocument,
      variables
    );
    const data = response.viewer.teams;

    return new TeamConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * A fetchable WorkflowState_Issues Query
 *
 * @param request - function to call the graphql client
 * @param id - required id to pass to workflowState
 * @param variables - variables without 'id' to pass into the WorkflowState_IssuesQuery
 */
export class WorkflowState_IssuesQuery extends Request {
  private _id: string;
  private _variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">;

  public constructor(request: LinearRequest, id: string, variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">) {
    super(request);
    this._id = id;
    this._variables = variables;
  }

  /**
   * Call the WorkflowState_Issues query and return a IssueConnection
   *
   * @param variables - variables without 'id' to pass into the WorkflowState_IssuesQuery
   * @returns parsed response from WorkflowState_IssuesQuery
   */
  public async fetch(variables?: Omit<L.WorkflowState_IssuesQueryVariables, "id">): LinearFetch<IssueConnection> {
    const response = await this._request<L.WorkflowState_IssuesQuery, L.WorkflowState_IssuesQueryVariables>(
      L.WorkflowState_IssuesDocument,
      {
        id: this._id,
        ...this._variables,
        ...variables,
      }
    );
    const data = response.workflowState.issues;

    return new IssueConnection(
      this._request,
      connection =>
        this.fetch(
          defaultConnection({
            ...this._variables,
            ...variables,
            ...connection,
          })
        ),
      data
    );
  }
}

/**
 * The SDK class containing all root operations
 *
 * @param request - function to call the graphql client
 */
export class LinearSdk extends Request {
  public constructor(request: LinearRequest) {
    super(request);
  }

  /**
   * All teams you the user can administrate. Administrable teams are teams whose settings the user can change, but to whose issues the user doesn't necessarily have access to.
   *
   * @param variables - variables to pass into the AdministrableTeamsQuery
   * @returns TeamConnection
   */
  public administrableTeams(variables?: L.AdministrableTeamsQueryVariables): LinearFetch<TeamConnection> {
    return new AdministrableTeamsQuery(this._request).fetch(variables);
  }
  /**
   * All agent activities.
   *
   * @param variables - variables to pass into the AgentActivitiesQuery
   * @returns AgentActivityConnection
   */
  public agentActivities(variables?: L.AgentActivitiesQueryVariables): LinearFetch<AgentActivityConnection> {
    return new AgentActivitiesQuery(this._request).fetch(variables);
  }
  /**
   * A specific agent activity.
   *
   * @param id - required id to pass to agentActivity
   * @returns AgentActivity
   */
  public agentActivity(id: string): LinearFetch<AgentActivity> {
    return new AgentActivityQuery(this._request).fetch(id);
  }
  /**
   * A specific agent context.
   *
   * @param id - required id to pass to agentContext
   * @returns AgentContext
   */
  public agentContext(id: string): LinearFetch<AgentContext> {
    return new AgentContextQuery(this._request).fetch(id);
  }
  /**
   * All agent contexts.
   *
   * @param variables - variables to pass into the AgentContextsQuery
   * @returns AgentContextConnection
   */
  public agentContexts(variables?: L.AgentContextsQueryVariables): LinearFetch<AgentContextConnection> {
    return new AgentContextsQuery(this._request).fetch(variables);
  }
  /**
   * A specific agent session.
   *
   * @param id - required id to pass to agentSession
   * @returns AgentSession
   */
  public agentSession(id: string): LinearFetch<AgentSession> {
    return new AgentSessionQuery(this._request).fetch(id);
  }
  /**
   * All agent sessions.
   *
   * @param variables - variables to pass into the AgentSessionsQuery
   * @returns AgentSessionConnection
   */
  public agentSessions(variables?: L.AgentSessionsQueryVariables): LinearFetch<AgentSessionConnection> {
    return new AgentSessionsQuery(this._request).fetch(variables);
  }
  /**
   * All API keys for the user.
   *
   * @param variables - variables to pass into the ApiKeysQuery
   * @returns ApiKeyConnection
   */
  public apiKeys(variables?: L.ApiKeysQueryVariables): LinearFetch<ApiKeyConnection> {
    return new ApiKeysQuery(this._request).fetch(variables);
  }
  /**
   * Get basic information for an application.
   *
   * @param clientId - required clientId to pass to applicationInfo
   * @returns Application
   */
  public applicationInfo(clientId: string): LinearFetch<Application> {
    return new ApplicationInfoQuery(this._request).fetch(clientId);
  }
  /**
   * Get information for an application and whether a user has approved it for the given scopes.
   *
   * @param clientId - required clientId to pass to applicationWithAuthorization
   * @param scope - required scope to pass to applicationWithAuthorization
   * @param variables - variables without 'clientId', 'scope' to pass into the ApplicationWithAuthorizationQuery
   * @returns UserAuthorizedApplication
   */
  public applicationWithAuthorization(
    clientId: string,
    scope: string[],
    variables?: Omit<L.ApplicationWithAuthorizationQueryVariables, "clientId" | "scope">
  ): LinearFetch<UserAuthorizedApplication> {
    return new ApplicationWithAuthorizationQuery(this._request).fetch(clientId, scope, variables);
  }
  /**
   * One specific issue attachment.
   * [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
   *
   * @param id - required id to pass to attachment
   * @returns Attachment
   */
  public attachment(id: string): LinearFetch<Attachment> {
    return new AttachmentQuery(this._request).fetch(id);
  }
  /**
   * Query an issue by its associated attachment, and its id.
   *
   * @param id - required id to pass to attachmentIssue
   * @returns Issue
   */
  public attachmentIssue(id: string): LinearFetch<Issue> {
    return new AttachmentIssueQuery(this._request).fetch(id);
  }
  /**
   * All issue attachments.
   *
   * To get attachments for a given URL, use `attachmentsForURL` query.
   *
   * @param variables - variables to pass into the AttachmentsQuery
   * @returns AttachmentConnection
   */
  public attachments(variables?: L.AttachmentsQueryVariables): LinearFetch<AttachmentConnection> {
    return new AttachmentsQuery(this._request).fetch(variables);
  }
  /**
   * Returns issue attachments for a given `url`.
   *
   * @param url - required url to pass to attachmentsForURL
   * @param variables - variables without 'url' to pass into the AttachmentsForUrlQuery
   * @returns AttachmentConnection
   */
  public attachmentsForURL(
    url: string,
    variables?: Omit<L.AttachmentsForUrlQueryVariables, "url">
  ): LinearFetch<AttachmentConnection> {
    return new AttachmentsForUrlQuery(this._request).fetch(url, variables);
  }
  /**
   * All audit log entries.
   *
   * @param variables - variables to pass into the AuditEntriesQuery
   * @returns AuditEntryConnection
   */
  public auditEntries(variables?: L.AuditEntriesQueryVariables): LinearFetch<AuditEntryConnection> {
    return new AuditEntriesQuery(this._request).fetch(variables);
  }
  /**
   * List of audit entry types.
   *
   * @returns AuditEntryType[]
   */
  public get auditEntryTypes(): LinearFetch<AuditEntryType[]> {
    return new AuditEntryTypesQuery(this._request).fetch();
  }
  /**
   * User's active sessions.
   *
   * @returns AuthenticationSessionResponse[]
   */
  public get authenticationSessions(): LinearFetch<AuthenticationSessionResponse[]> {
    return new AuthenticationSessionsQuery(this._request).fetch();
  }
  /**
   * Fetch users belonging to this user account.
   *
   * @returns AuthResolverResponse
   */
  public get availableUsers(): LinearFetch<AuthResolverResponse> {
    return new AvailableUsersQuery(this._request).fetch();
  }
  /**
   * A specific comment.
   *
   * @param variables - variables to pass into the CommentQuery
   * @returns Comment
   */
  public comment(variables?: L.CommentQueryVariables): LinearFetch<Comment> {
    return new CommentQuery(this._request).fetch(variables);
  }
  /**
   * All comments.
   *
   * @param variables - variables to pass into the CommentsQuery
   * @returns CommentConnection
   */
  public comments(variables?: L.CommentsQueryVariables): LinearFetch<CommentConnection> {
    return new CommentsQuery(this._request).fetch(variables);
  }
  /**
   * One specific custom view.
   *
   * @param id - required id to pass to customView
   * @returns CustomView
   */
  public customView(id: string): LinearFetch<CustomView> {
    return new CustomViewQuery(this._request).fetch(id);
  }
  /**
   * Whether a custom view has other subscribers than the current user in the organization.
   *
   * @param id - required id to pass to customViewHasSubscribers
   * @returns CustomViewHasSubscribersPayload
   */
  public customViewHasSubscribers(id: string): LinearFetch<CustomViewHasSubscribersPayload> {
    return new CustomViewHasSubscribersQuery(this._request).fetch(id);
  }
  /**
   * Custom views for the user.
   *
   * @param variables - variables to pass into the CustomViewsQuery
   * @returns CustomViewConnection
   */
  public customViews(variables?: L.CustomViewsQueryVariables): LinearFetch<CustomViewConnection> {
    return new CustomViewsQuery(this._request).fetch(variables);
  }
  /**
   * One specific customer.
   *
   * @param id - required id to pass to customer
   * @returns Customer
   */
  public customer(id: string): LinearFetch<Customer> {
    return new CustomerQuery(this._request).fetch(id);
  }
  /**
   * One specific customer need
   *
   * @param variables - variables to pass into the CustomerNeedQuery
   * @returns CustomerNeed
   */
  public customerNeed(variables?: L.CustomerNeedQueryVariables): LinearFetch<CustomerNeed> {
    return new CustomerNeedQuery(this._request).fetch(variables);
  }
  /**
   * All customer needs.
   *
   * @param variables - variables to pass into the CustomerNeedsQuery
   * @returns CustomerNeedConnection
   */
  public customerNeeds(variables?: L.CustomerNeedsQueryVariables): LinearFetch<CustomerNeedConnection> {
    return new CustomerNeedsQuery(this._request).fetch(variables);
  }
  /**
   * One specific customer status.
   *
   * @param id - required id to pass to customerStatus
   * @returns CustomerStatus
   */
  public customerStatus(id: string): LinearFetch<CustomerStatus> {
    return new CustomerStatusQuery(this._request).fetch(id);
  }
  /**
   * All customer statuses.
   *
   * @param variables - variables to pass into the CustomerStatusesQuery
   * @returns CustomerStatusConnection
   */
  public customerStatuses(variables?: L.CustomerStatusesQueryVariables): LinearFetch<CustomerStatusConnection> {
    return new CustomerStatusesQuery(this._request).fetch(variables);
  }
  /**
   * One specific customer tier.
   *
   * @param id - required id to pass to customerTier
   * @returns CustomerTier
   */
  public customerTier(id: string): LinearFetch<CustomerTier> {
    return new CustomerTierQuery(this._request).fetch(id);
  }
  /**
   * All customer tiers.
   *
   * @param variables - variables to pass into the CustomerTiersQuery
   * @returns CustomerTierConnection
   */
  public customerTiers(variables?: L.CustomerTiersQueryVariables): LinearFetch<CustomerTierConnection> {
    return new CustomerTiersQuery(this._request).fetch(variables);
  }
  /**
   * All customers.
   *
   * @param variables - variables to pass into the CustomersQuery
   * @returns CustomerConnection
   */
  public customers(variables?: L.CustomersQueryVariables): LinearFetch<CustomerConnection> {
    return new CustomersQuery(this._request).fetch(variables);
  }
  /**
   * One specific cycle.
   *
   * @param id - required id to pass to cycle
   * @returns Cycle
   */
  public cycle(id: string): LinearFetch<Cycle> {
    return new CycleQuery(this._request).fetch(id);
  }
  /**
   * All cycles.
   *
   * @param variables - variables to pass into the CyclesQuery
   * @returns CycleConnection
   */
  public cycles(variables?: L.CyclesQueryVariables): LinearFetch<CycleConnection> {
    return new CyclesQuery(this._request).fetch(variables);
  }
  /**
   * One specific document.
   *
   * @param id - required id to pass to document
   * @returns Document
   */
  public document(id: string): LinearFetch<Document> {
    return new DocumentQuery(this._request).fetch(id);
  }
  /**
   * A collection of document content history entries.
   *
   * @param id - required id to pass to documentContentHistory
   * @returns DocumentContentHistoryPayload
   */
  public documentContentHistory(id: string): LinearFetch<DocumentContentHistoryPayload> {
    return new DocumentContentHistoryQuery(this._request).fetch(id);
  }
  /**
   * All documents in the workspace.
   *
   * @param variables - variables to pass into the DocumentsQuery
   * @returns DocumentConnection
   */
  public documents(variables?: L.DocumentsQueryVariables): LinearFetch<DocumentConnection> {
    return new DocumentsQuery(this._request).fetch(variables);
  }
  /**
   * One specific email intake address.
   *
   * @param id - required id to pass to emailIntakeAddress
   * @returns EmailIntakeAddress
   */
  public emailIntakeAddress(id: string): LinearFetch<EmailIntakeAddress> {
    return new EmailIntakeAddressQuery(this._request).fetch(id);
  }
  /**
   * A specific emoji.
   *
   * @param id - required id to pass to emoji
   * @returns Emoji
   */
  public emoji(id: string): LinearFetch<Emoji> {
    return new EmojiQuery(this._request).fetch(id);
  }
  /**
   * All custom emojis.
   *
   * @param variables - variables to pass into the EmojisQuery
   * @returns EmojiConnection
   */
  public emojis(variables?: L.EmojisQueryVariables): LinearFetch<EmojiConnection> {
    return new EmojisQuery(this._request).fetch(variables);
  }
  /**
   * One specific entity link.
   *
   * @param id - required id to pass to entityExternalLink
   * @returns EntityExternalLink
   */
  public entityExternalLink(id: string): LinearFetch<EntityExternalLink> {
    return new EntityExternalLinkQuery(this._request).fetch(id);
  }
  /**
   * One specific external user.
   *
   * @param id - required id to pass to externalUser
   * @returns ExternalUser
   */
  public externalUser(id: string): LinearFetch<ExternalUser> {
    return new ExternalUserQuery(this._request).fetch(id);
  }
  /**
   * All external users for the organization.
   *
   * @param variables - variables to pass into the ExternalUsersQuery
   * @returns ExternalUserConnection
   */
  public externalUsers(variables?: L.ExternalUsersQueryVariables): LinearFetch<ExternalUserConnection> {
    return new ExternalUsersQuery(this._request).fetch(variables);
  }
  /**
   * One specific favorite.
   *
   * @param id - required id to pass to favorite
   * @returns Favorite
   */
  public favorite(id: string): LinearFetch<Favorite> {
    return new FavoriteQuery(this._request).fetch(id);
  }
  /**
   * The user's favorites.
   *
   * @param variables - variables to pass into the FavoritesQuery
   * @returns FavoriteConnection
   */
  public favorites(variables?: L.FavoritesQueryVariables): LinearFetch<FavoriteConnection> {
    return new FavoritesQuery(this._request).fetch(variables);
  }
  /**
   * One specific initiative.
   *
   * @param id - required id to pass to initiative
   * @returns Initiative
   */
  public initiative(id: string): LinearFetch<Initiative> {
    return new InitiativeQuery(this._request).fetch(id);
  }
  /**
   * One specific initiative relation.
   *
   * @param id - required id to pass to initiativeRelation
   * @returns ProjectRelation
   */
  public initiativeRelation(id: string): LinearFetch<ProjectRelation> {
    return new InitiativeRelationQuery(this._request).fetch(id);
  }
  /**
   * All initiative relationships.
   *
   * @param variables - variables to pass into the InitiativeRelationsQuery
   * @returns InitiativeRelationConnection
   */
  public initiativeRelations(
    variables?: L.InitiativeRelationsQueryVariables
  ): LinearFetch<InitiativeRelationConnection> {
    return new InitiativeRelationsQuery(this._request).fetch(variables);
  }
  /**
   * One specific initiativeToProject.
   *
   * @param id - required id to pass to initiativeToProject
   * @returns InitiativeToProject
   */
  public initiativeToProject(id: string): LinearFetch<InitiativeToProject> {
    return new InitiativeToProjectQuery(this._request).fetch(id);
  }
  /**
   * returns a list of initiative to project entities.
   *
   * @param variables - variables to pass into the InitiativeToProjectsQuery
   * @returns InitiativeToProjectConnection
   */
  public initiativeToProjects(
    variables?: L.InitiativeToProjectsQueryVariables
  ): LinearFetch<InitiativeToProjectConnection> {
    return new InitiativeToProjectsQuery(this._request).fetch(variables);
  }
  /**
   * A specific  initiative update.
   *
   * @param id - required id to pass to initiativeUpdate
   * @returns InitiativeUpdate
   */
  public initiativeUpdate(id: string): LinearFetch<InitiativeUpdate> {
    return new InitiativeUpdateQuery(this._request).fetch(id);
  }
  /**
   * All  InitiativeUpdates.
   *
   * @param variables - variables to pass into the InitiativeUpdatesQuery
   * @returns InitiativeUpdateConnection
   */
  public initiativeUpdates(variables?: L.InitiativeUpdatesQueryVariables): LinearFetch<InitiativeUpdateConnection> {
    return new InitiativeUpdatesQuery(this._request).fetch(variables);
  }
  /**
   * All initiatives in the workspace.
   *
   * @param variables - variables to pass into the InitiativesQuery
   * @returns InitiativeConnection
   */
  public initiatives(variables?: L.InitiativesQueryVariables): LinearFetch<InitiativeConnection> {
    return new InitiativesQuery(this._request).fetch(variables);
  }
  /**
   * One specific integration.
   *
   * @param id - required id to pass to integration
   * @returns Integration
   */
  public integration(id: string): LinearFetch<Integration> {
    return new IntegrationQuery(this._request).fetch(id);
  }
  /**
   * Checks if the integration has all required scopes.
   *
   * @param integrationId - required integrationId to pass to integrationHasScopes
   * @param scopes - required scopes to pass to integrationHasScopes
   * @returns IntegrationHasScopesPayload
   */
  public integrationHasScopes(integrationId: string, scopes: string[]): LinearFetch<IntegrationHasScopesPayload> {
    return new IntegrationHasScopesQuery(this._request).fetch(integrationId, scopes);
  }
  /**
   * One specific integrationTemplate.
   *
   * @param id - required id to pass to integrationTemplate
   * @returns IntegrationTemplate
   */
  public integrationTemplate(id: string): LinearFetch<IntegrationTemplate> {
    return new IntegrationTemplateQuery(this._request).fetch(id);
  }
  /**
   * Template and integration connections.
   *
   * @param variables - variables to pass into the IntegrationTemplatesQuery
   * @returns IntegrationTemplateConnection
   */
  public integrationTemplates(
    variables?: L.IntegrationTemplatesQueryVariables
  ): LinearFetch<IntegrationTemplateConnection> {
    return new IntegrationTemplatesQuery(this._request).fetch(variables);
  }
  /**
   * All integrations.
   *
   * @param variables - variables to pass into the IntegrationsQuery
   * @returns IntegrationConnection
   */
  public integrations(variables?: L.IntegrationsQueryVariables): LinearFetch<IntegrationConnection> {
    return new IntegrationsQuery(this._request).fetch(variables);
  }
  /**
   * One specific set of settings.
   *
   * @param id - required id to pass to integrationsSettings
   * @returns IntegrationsSettings
   */
  public integrationsSettings(id: string): LinearFetch<IntegrationsSettings> {
    return new IntegrationsSettingsQuery(this._request).fetch(id);
  }
  /**
   * One specific issue.
   *
   * @param id - required id to pass to issue
   * @returns Issue
   */
  public issue(id: string): LinearFetch<Issue> {
    return new IssueQuery(this._request).fetch(id);
  }
  /**
   * Find issues that are related to a given Figma file key.
   *
   * @param fileKey - required fileKey to pass to issueFigmaFileKeySearch
   * @param variables - variables without 'fileKey' to pass into the IssueFigmaFileKeySearchQuery
   * @returns IssueConnection
   */
  public issueFigmaFileKeySearch(
    fileKey: string,
    variables?: Omit<L.IssueFigmaFileKeySearchQueryVariables, "fileKey">
  ): LinearFetch<IssueConnection> {
    return new IssueFigmaFileKeySearchQuery(this._request).fetch(fileKey, variables);
  }
  /**
   * Suggests filters for an issue view based on a text prompt.
   *
   * @param prompt - required prompt to pass to issueFilterSuggestion
   * @param variables - variables without 'prompt' to pass into the IssueFilterSuggestionQuery
   * @returns IssueFilterSuggestionPayload
   */
  public issueFilterSuggestion(
    prompt: string,
    variables?: Omit<L.IssueFilterSuggestionQueryVariables, "prompt">
  ): LinearFetch<IssueFilterSuggestionPayload> {
    return new IssueFilterSuggestionQuery(this._request).fetch(prompt, variables);
  }
  /**
   * Checks a CSV file validity against a specific import service.
   *
   * @param csvUrl - required csvUrl to pass to issueImportCheckCSV
   * @param service - required service to pass to issueImportCheckCSV
   * @returns IssueImportCheckPayload
   */
  public issueImportCheckCSV(csvUrl: string, service: string): LinearFetch<IssueImportCheckPayload> {
    return new IssueImportCheckCsvQuery(this._request).fetch(csvUrl, service);
  }
  /**
   * Checks whether it will be possible to setup sync for this project or repository at the end of import
   *
   * @param issueImportId - required issueImportId to pass to issueImportCheckSync
   * @returns IssueImportSyncCheckPayload
   */
  public issueImportCheckSync(issueImportId: string): LinearFetch<IssueImportSyncCheckPayload> {
    return new IssueImportCheckSyncQuery(this._request).fetch(issueImportId);
  }
  /**
   * Checks whether a custom JQL query is valid and can be used to filter issues of a Jira import
   *
   * @param jiraEmail - required jiraEmail to pass to issueImportJqlCheck
   * @param jiraHostname - required jiraHostname to pass to issueImportJqlCheck
   * @param jiraProject - required jiraProject to pass to issueImportJqlCheck
   * @param jiraToken - required jiraToken to pass to issueImportJqlCheck
   * @param jql - required jql to pass to issueImportJqlCheck
   * @returns IssueImportJqlCheckPayload
   */
  public issueImportJqlCheck(
    jiraEmail: string,
    jiraHostname: string,
    jiraProject: string,
    jiraToken: string,
    jql: string
  ): LinearFetch<IssueImportJqlCheckPayload> {
    return new IssueImportJqlCheckQuery(this._request).fetch(jiraEmail, jiraHostname, jiraProject, jiraToken, jql);
  }
  /**
   * One specific label.
   *
   * @param id - required id to pass to issueLabel
   * @returns IssueLabel
   */
  public issueLabel(id: string): LinearFetch<IssueLabel> {
    return new IssueLabelQuery(this._request).fetch(id);
  }
  /**
   * All issue labels.
   *
   * @param variables - variables to pass into the IssueLabelsQuery
   * @returns IssueLabelConnection
   */
  public issueLabels(variables?: L.IssueLabelsQueryVariables): LinearFetch<IssueLabelConnection> {
    return new IssueLabelsQuery(this._request).fetch(variables);
  }
  /**
   * Issue priority values and corresponding labels.
   *
   * @returns IssuePriorityValue[]
   */
  public get issuePriorityValues(): LinearFetch<IssuePriorityValue[]> {
    return new IssuePriorityValuesQuery(this._request).fetch();
  }
  /**
   * One specific issue relation.
   *
   * @param id - required id to pass to issueRelation
   * @returns IssueRelation
   */
  public issueRelation(id: string): LinearFetch<IssueRelation> {
    return new IssueRelationQuery(this._request).fetch(id);
  }
  /**
   * All issue relationships.
   *
   * @param variables - variables to pass into the IssueRelationsQuery
   * @returns IssueRelationConnection
   */
  public issueRelations(variables?: L.IssueRelationsQueryVariables): LinearFetch<IssueRelationConnection> {
    return new IssueRelationsQuery(this._request).fetch(variables);
  }
  /**
   * [DEPRECATED] Search issues. This endpoint is deprecated and will be removed in the future  use `searchIssues` instead.
   *
   * @param variables - variables to pass into the IssueSearchQuery
   * @returns IssueConnection
   */
  public issueSearch(variables?: L.IssueSearchQueryVariables): LinearFetch<IssueConnection> {
    return new IssueSearchQuery(this._request).fetch(variables);
  }
  /**
   * Suggests issue title based on a customer request.
   *
   * @param request - required request to pass to issueTitleSuggestionFromCustomerRequest
   * @returns IssueTitleSuggestionFromCustomerRequestPayload
   */
  public issueTitleSuggestionFromCustomerRequest(
    request: string
  ): LinearFetch<IssueTitleSuggestionFromCustomerRequestPayload> {
    return new IssueTitleSuggestionFromCustomerRequestQuery(this._request).fetch(request);
  }
  /**
   * Find issue based on the VCS branch name.
   *
   * @param branchName - required branchName to pass to issueVcsBranchSearch
   * @returns Issue
   */
  public issueVcsBranchSearch(branchName: string): LinearFetch<Issue | undefined> {
    return new IssueVcsBranchSearchQuery(this._request).fetch(branchName);
  }
  /**
   * All issues.
   *
   * @param variables - variables to pass into the IssuesQuery
   * @returns IssueConnection
   */
  public issues(variables?: L.IssuesQueryVariables): LinearFetch<IssueConnection> {
    return new IssuesQuery(this._request).fetch(variables);
  }
  /**
   * One specific notification.
   *
   * @param id - required id to pass to notification
   * @returns Notification
   */
  public notification(
    id: string
  ): LinearFetch<
    | CustomerNeedNotification
    | CustomerNotification
    | DocumentNotification
    | InitiativeNotification
    | IssueNotification
    | OauthClientApprovalNotification
    | PostNotification
    | ProjectNotification
    | PullRequestNotification
    | Notification
  > {
    return new NotificationQuery(this._request).fetch(id);
  }
  /**
   * One specific notification subscription.
   *
   * @param id - required id to pass to notificationSubscription
   * @returns NotificationSubscription
   */
  public notificationSubscription(
    id: string
  ): LinearFetch<
    | CustomViewNotificationSubscription
    | CustomerNotificationSubscription
    | CycleNotificationSubscription
    | InitiativeNotificationSubscription
    | LabelNotificationSubscription
    | ProjectNotificationSubscription
    | TeamNotificationSubscription
    | UserNotificationSubscription
    | NotificationSubscription
  > {
    return new NotificationSubscriptionQuery(this._request).fetch(id);
  }
  /**
   * The user's notification subscriptions.
   *
   * @param variables - variables to pass into the NotificationSubscriptionsQuery
   * @returns NotificationSubscriptionConnection
   */
  public notificationSubscriptions(
    variables?: L.NotificationSubscriptionsQueryVariables
  ): LinearFetch<NotificationSubscriptionConnection> {
    return new NotificationSubscriptionsQuery(this._request).fetch(variables);
  }
  /**
   * All notifications.
   *
   * @param variables - variables to pass into the NotificationsQuery
   * @returns NotificationConnection
   */
  public notifications(variables?: L.NotificationsQueryVariables): LinearFetch<NotificationConnection> {
    return new NotificationsQuery(this._request).fetch(variables);
  }
  /**
   * The user's organization.
   *
   * @returns Organization
   */
  public get organization(): LinearFetch<Organization> {
    return new OrganizationQuery(this._request).fetch();
  }
  /**
   * Does the organization exist.
   *
   * @param urlKey - required urlKey to pass to organizationExists
   * @returns OrganizationExistsPayload
   */
  public organizationExists(urlKey: string): LinearFetch<OrganizationExistsPayload> {
    return new OrganizationExistsQuery(this._request).fetch(urlKey);
  }
  /**
   * One specific organization invite.
   *
   * @param id - required id to pass to organizationInvite
   * @returns OrganizationInvite
   */
  public organizationInvite(id: string): LinearFetch<OrganizationInvite> {
    return new OrganizationInviteQuery(this._request).fetch(id);
  }
  /**
   * All invites for the organization.
   *
   * @param variables - variables to pass into the OrganizationInvitesQuery
   * @returns OrganizationInviteConnection
   */
  public organizationInvites(
    variables?: L.OrganizationInvitesQueryVariables
  ): LinearFetch<OrganizationInviteConnection> {
    return new OrganizationInvitesQuery(this._request).fetch(variables);
  }
  /**
   * One specific project.
   *
   * @param id - required id to pass to project
   * @returns Project
   */
  public project(id: string): LinearFetch<Project> {
    return new ProjectQuery(this._request).fetch(id);
  }
  /**
   * Suggests filters for a project view based on a text prompt.
   *
   * @param prompt - required prompt to pass to projectFilterSuggestion
   * @returns ProjectFilterSuggestionPayload
   */
  public projectFilterSuggestion(prompt: string): LinearFetch<ProjectFilterSuggestionPayload> {
    return new ProjectFilterSuggestionQuery(this._request).fetch(prompt);
  }
  /**
   * One specific label.
   *
   * @param id - required id to pass to projectLabel
   * @returns ProjectLabel
   */
  public projectLabel(id: string): LinearFetch<ProjectLabel> {
    return new ProjectLabelQuery(this._request).fetch(id);
  }
  /**
   * All project labels.
   *
   * @param variables - variables to pass into the ProjectLabelsQuery
   * @returns ProjectLabelConnection
   */
  public projectLabels(variables?: L.ProjectLabelsQueryVariables): LinearFetch<ProjectLabelConnection> {
    return new ProjectLabelsQuery(this._request).fetch(variables);
  }
  /**
   * One specific project milestone.
   *
   * @param id - required id to pass to projectMilestone
   * @returns ProjectMilestone
   */
  public projectMilestone(id: string): LinearFetch<ProjectMilestone> {
    return new ProjectMilestoneQuery(this._request).fetch(id);
  }
  /**
   * All milestones for the project.
   *
   * @param variables - variables to pass into the ProjectMilestonesQuery
   * @returns ProjectMilestoneConnection
   */
  public projectMilestones(variables?: L.ProjectMilestonesQueryVariables): LinearFetch<ProjectMilestoneConnection> {
    return new ProjectMilestonesQuery(this._request).fetch(variables);
  }
  /**
   * One specific project relation.
   *
   * @param id - required id to pass to projectRelation
   * @returns ProjectRelation
   */
  public projectRelation(id: string): LinearFetch<ProjectRelation> {
    return new ProjectRelationQuery(this._request).fetch(id);
  }
  /**
   * All project relationships.
   *
   * @param variables - variables to pass into the ProjectRelationsQuery
   * @returns ProjectRelationConnection
   */
  public projectRelations(variables?: L.ProjectRelationsQueryVariables): LinearFetch<ProjectRelationConnection> {
    return new ProjectRelationsQuery(this._request).fetch(variables);
  }
  /**
   * One specific project status.
   *
   * @param id - required id to pass to projectStatus
   * @returns ProjectStatus
   */
  public projectStatus(id: string): LinearFetch<ProjectStatus> {
    return new ProjectStatusQuery(this._request).fetch(id);
  }
  /**
   * All project statuses.
   *
   * @param variables - variables to pass into the ProjectStatusesQuery
   * @returns ProjectStatusConnection
   */
  public projectStatuses(variables?: L.ProjectStatusesQueryVariables): LinearFetch<ProjectStatusConnection> {
    return new ProjectStatusesQuery(this._request).fetch(variables);
  }
  /**
   * A specific project update.
   *
   * @param id - required id to pass to projectUpdate
   * @returns ProjectUpdate
   */
  public projectUpdate(id: string): LinearFetch<ProjectUpdate> {
    return new ProjectUpdateQuery(this._request).fetch(id);
  }
  /**
   * All project updates.
   *
   * @param variables - variables to pass into the ProjectUpdatesQuery
   * @returns ProjectUpdateConnection
   */
  public projectUpdates(variables?: L.ProjectUpdatesQueryVariables): LinearFetch<ProjectUpdateConnection> {
    return new ProjectUpdatesQuery(this._request).fetch(variables);
  }
  /**
   * All projects.
   *
   * @param variables - variables to pass into the ProjectsQuery
   * @returns ProjectConnection
   */
  public projects(variables?: L.ProjectsQueryVariables): LinearFetch<ProjectConnection> {
    return new ProjectsQuery(this._request).fetch(variables);
  }
  /**
   * Sends a test push message.
   *
   * @param variables - variables to pass into the PushSubscriptionTestQuery
   * @returns PushSubscriptionTestPayload
   */
  public pushSubscriptionTest(
    variables?: L.PushSubscriptionTestQueryVariables
  ): LinearFetch<PushSubscriptionTestPayload> {
    return new PushSubscriptionTestQuery(this._request).fetch(variables);
  }
  /**
   * The status of the rate limiter.
   *
   * @returns RateLimitPayload
   */
  public get rateLimitStatus(): LinearFetch<RateLimitPayload> {
    return new RateLimitStatusQuery(this._request).fetch();
  }
  /**
   * One specific roadmap.
   *
   * @param id - required id to pass to roadmap
   * @returns Roadmap
   */
  public roadmap(id: string): LinearFetch<Roadmap> {
    return new RoadmapQuery(this._request).fetch(id);
  }
  /**
   * One specific roadmapToProject.
   *
   * @param id - required id to pass to roadmapToProject
   * @returns RoadmapToProject
   */
  public roadmapToProject(id: string): LinearFetch<RoadmapToProject> {
    return new RoadmapToProjectQuery(this._request).fetch(id);
  }
  /**
   * Custom views for the user.
   *
   * @param variables - variables to pass into the RoadmapToProjectsQuery
   * @returns RoadmapToProjectConnection
   */
  public roadmapToProjects(variables?: L.RoadmapToProjectsQueryVariables): LinearFetch<RoadmapToProjectConnection> {
    return new RoadmapToProjectsQuery(this._request).fetch(variables);
  }
  /**
   * All roadmaps in the workspace.
   *
   * @param variables - variables to pass into the RoadmapsQuery
   * @returns RoadmapConnection
   */
  public roadmaps(variables?: L.RoadmapsQueryVariables): LinearFetch<RoadmapConnection> {
    return new RoadmapsQuery(this._request).fetch(variables);
  }
  /**
   * Search documents.
   *
   * @param term - required term to pass to searchDocuments
   * @param variables - variables without 'term' to pass into the SearchDocumentsQuery
   * @returns DocumentSearchPayload
   */
  public searchDocuments(
    term: string,
    variables?: Omit<L.SearchDocumentsQueryVariables, "term">
  ): LinearFetch<DocumentSearchPayload> {
    return new SearchDocumentsQuery(this._request).fetch(term, variables);
  }
  /**
   * Search issues.
   *
   * @param term - required term to pass to searchIssues
   * @param variables - variables without 'term' to pass into the SearchIssuesQuery
   * @returns IssueSearchPayload
   */
  public searchIssues(
    term: string,
    variables?: Omit<L.SearchIssuesQueryVariables, "term">
  ): LinearFetch<IssueSearchPayload> {
    return new SearchIssuesQuery(this._request).fetch(term, variables);
  }
  /**
   * Search projects.
   *
   * @param term - required term to pass to searchProjects
   * @param variables - variables without 'term' to pass into the SearchProjectsQuery
   * @returns ProjectSearchPayload
   */
  public searchProjects(
    term: string,
    variables?: Omit<L.SearchProjectsQueryVariables, "term">
  ): LinearFetch<ProjectSearchPayload> {
    return new SearchProjectsQuery(this._request).fetch(term, variables);
  }
  /**
   * Fetch SSO login URL for the email provided.
   *
   * @param email - required email to pass to ssoUrlFromEmail
   * @param variables - variables without 'email' to pass into the SsoUrlFromEmailQuery
   * @returns SsoUrlFromEmailResponse
   */
  public ssoUrlFromEmail(
    email: string,
    variables?: Omit<L.SsoUrlFromEmailQueryVariables, "email">
  ): LinearFetch<SsoUrlFromEmailResponse> {
    return new SsoUrlFromEmailQuery(this._request).fetch(email, variables);
  }
  /**
   * One specific team.
   *
   * @param id - required id to pass to team
   * @returns Team
   */
  public team(id: string): LinearFetch<Team> {
    return new TeamQuery(this._request).fetch(id);
  }
  /**
   * One specific team membership.
   *
   * @param id - required id to pass to teamMembership
   * @returns TeamMembership
   */
  public teamMembership(id: string): LinearFetch<TeamMembership> {
    return new TeamMembershipQuery(this._request).fetch(id);
  }
  /**
   * All team memberships.
   *
   * @param variables - variables to pass into the TeamMembershipsQuery
   * @returns TeamMembershipConnection
   */
  public teamMemberships(variables?: L.TeamMembershipsQueryVariables): LinearFetch<TeamMembershipConnection> {
    return new TeamMembershipsQuery(this._request).fetch(variables);
  }
  /**
   * All teams whose issues can be accessed by the user. This might be different from `administrableTeams`, which also includes teams whose settings can be changed by the user.
   *
   * @param variables - variables to pass into the TeamsQuery
   * @returns TeamConnection
   */
  public teams(variables?: L.TeamsQueryVariables): LinearFetch<TeamConnection> {
    return new TeamsQuery(this._request).fetch(variables);
  }
  /**
   * A specific template.
   *
   * @param id - required id to pass to template
   * @returns Template
   */
  public template(id: string): LinearFetch<Template> {
    return new TemplateQuery(this._request).fetch(id);
  }
  /**
   * All templates from all users.
   *
   * @returns Template[]
   */
  public get templates(): LinearFetch<Template[]> {
    return new TemplatesQuery(this._request).fetch();
  }
  /**
   * Returns all templates that are associated with the integration type.
   *
   * @param integrationType - required integrationType to pass to templatesForIntegration
   * @returns Template[]
   */
  public templatesForIntegration(integrationType: string): LinearFetch<Template[]> {
    return new TemplatesForIntegrationQuery(this._request).fetch(integrationType);
  }
  /**
   * A specific time schedule.
   *
   * @param id - required id to pass to timeSchedule
   * @returns TimeSchedule
   */
  public timeSchedule(id: string): LinearFetch<TimeSchedule> {
    return new TimeScheduleQuery(this._request).fetch(id);
  }
  /**
   * All time schedules.
   *
   * @param variables - variables to pass into the TimeSchedulesQuery
   * @returns TimeScheduleConnection
   */
  public timeSchedules(variables?: L.TimeSchedulesQueryVariables): LinearFetch<TimeScheduleConnection> {
    return new TimeSchedulesQuery(this._request).fetch(variables);
  }
  /**
   * All triage responsibilities.
   *
   * @param variables - variables to pass into the TriageResponsibilitiesQuery
   * @returns TriageResponsibilityConnection
   */
  public triageResponsibilities(
    variables?: L.TriageResponsibilitiesQueryVariables
  ): LinearFetch<TriageResponsibilityConnection> {
    return new TriageResponsibilitiesQuery(this._request).fetch(variables);
  }
  /**
   * A specific triage responsibility.
   *
   * @param id - required id to pass to triageResponsibility
   * @returns TriageResponsibility
   */
  public triageResponsibility(id: string): LinearFetch<TriageResponsibility> {
    return new TriageResponsibilityQuery(this._request).fetch(id);
  }
  /**
   * One specific user.
   *
   * @param id - required id to pass to user
   * @returns User
   */
  public user(id: string): LinearFetch<User> {
    return new UserQuery(this._request).fetch(id);
  }
  /**
   * The user's settings.
   *
   * @returns UserSettings
   */
  public get userSettings(): LinearFetch<UserSettings> {
    return new UserSettingsQuery(this._request).fetch();
  }
  /**
   * All users for the organization.
   *
   * @param variables - variables to pass into the UsersQuery
   * @returns UserConnection
   */
  public users(variables?: L.UsersQueryVariables): LinearFetch<UserConnection> {
    return new UsersQuery(this._request).fetch(variables);
  }
  /**
   * Verify that we received the correct response from the GitHub Enterprise Server.
   *
   * @returns GitHubEnterpriseServerInstallVerificationPayload
   */
  public get verifyGitHubEnterpriseServerInstallation(): LinearFetch<GitHubEnterpriseServerInstallVerificationPayload> {
    return new VerifyGitHubEnterpriseServerInstallationQuery(this._request).fetch();
  }
  /**
   * The currently authenticated user.
   *
   * @returns User
   */
  public get viewer(): LinearFetch<User> {
    return new ViewerQuery(this._request).fetch();
  }
  /**
   * A specific webhook.
   *
   * @param id - required id to pass to webhook
   * @returns Webhook
   */
  public webhook(id: string): LinearFetch<Webhook> {
    return new WebhookQuery(this._request).fetch(id);
  }
  /**
   * All webhooks.
   *
   * @param variables - variables to pass into the WebhooksQuery
   * @returns WebhookConnection
   */
  public webhooks(variables?: L.WebhooksQueryVariables): LinearFetch<WebhookConnection> {
    return new WebhooksQuery(this._request).fetch(variables);
  }
  /**
   * One specific state.
   *
   * @param id - required id to pass to workflowState
   * @returns WorkflowState
   */
  public workflowState(id: string): LinearFetch<WorkflowState> {
    return new WorkflowStateQuery(this._request).fetch(id);
  }
  /**
   * All issue workflow states.
   *
   * @param variables - variables to pass into the WorkflowStatesQuery
   * @returns WorkflowStateConnection
   */
  public workflowStates(variables?: L.WorkflowStatesQueryVariables): LinearFetch<WorkflowStateConnection> {
    return new WorkflowStatesQuery(this._request).fetch(variables);
  }
  /**
   * Creates an agent activity.
   *
   * @param input - required input to pass to createAgentActivity
   * @returns AgentActivityPayload
   */
  public createAgentActivity(input: L.AgentActivityCreateInput): LinearFetch<AgentActivityPayload> {
    return new CreateAgentActivityMutation(this._request).fetch(input);
  }
  /**
   * Creates an agent context.
   *
   * @param input - required input to pass to createAgentContext
   * @returns AgentContextPayload
   */
  public createAgentContext(input: L.AgentContextCreateInput): LinearFetch<AgentContextPayload> {
    return new CreateAgentContextMutation(this._request).fetch(input);
  }
  /**
   * Updates an agent context.
   *
   * @param id - required id to pass to updateAgentContext
   * @param input - required input to pass to updateAgentContext
   * @returns AgentContextPayload
   */
  public updateAgentContext(id: string, input: L.AgentContextUpdateInput): LinearFetch<AgentContextPayload> {
    return new UpdateAgentContextMutation(this._request).fetch(id, input);
  }
  /**
   * Creates an integration api key for Airbyte to connect with Linear.
   *
   * @param input - required input to pass to airbyteIntegrationConnect
   * @returns IntegrationPayload
   */
  public airbyteIntegrationConnect(input: L.AirbyteConfigurationInput): LinearFetch<IntegrationPayload> {
    return new AirbyteIntegrationConnectMutation(this._request).fetch(input);
  }
  /**
   * Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
   *
   * @param input - required input to pass to createAttachment
   * @returns AttachmentPayload
   */
  public createAttachment(input: L.AttachmentCreateInput): LinearFetch<AttachmentPayload> {
    return new CreateAttachmentMutation(this._request).fetch(input);
  }
  /**
   * Deletes an issue attachment.
   *
   * @param id - required id to pass to deleteAttachment
   * @returns DeletePayload
   */
  public deleteAttachment(id: string): LinearFetch<DeletePayload> {
    return new DeleteAttachmentMutation(this._request).fetch(id);
  }
  /**
   * Link an existing Discord message to an issue.
   *
   * @param channelId - required channelId to pass to attachmentLinkDiscord
   * @param issueId - required issueId to pass to attachmentLinkDiscord
   * @param messageId - required messageId to pass to attachmentLinkDiscord
   * @param url - required url to pass to attachmentLinkDiscord
   * @param variables - variables without 'channelId', 'issueId', 'messageId', 'url' to pass into the AttachmentLinkDiscordMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkDiscord(
    channelId: string,
    issueId: string,
    messageId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkDiscordMutationVariables, "channelId" | "issueId" | "messageId" | "url">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkDiscordMutation(this._request).fetch(channelId, issueId, messageId, url, variables);
  }
  /**
   * Link an existing Front conversation to an issue.
   *
   * @param conversationId - required conversationId to pass to attachmentLinkFront
   * @param issueId - required issueId to pass to attachmentLinkFront
   * @param variables - variables without 'conversationId', 'issueId' to pass into the AttachmentLinkFrontMutation
   * @returns FrontAttachmentPayload
   */
  public attachmentLinkFront(
    conversationId: string,
    issueId: string,
    variables?: Omit<L.AttachmentLinkFrontMutationVariables, "conversationId" | "issueId">
  ): LinearFetch<FrontAttachmentPayload> {
    return new AttachmentLinkFrontMutation(this._request).fetch(conversationId, issueId, variables);
  }
  /**
   * Link a GitHub issue to a Linear issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkGitHubIssue
   * @param url - required url to pass to attachmentLinkGitHubIssue
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkGitHubIssueMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkGitHubIssue(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkGitHubIssueMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkGitHubIssueMutation(this._request).fetch(issueId, url, variables);
  }
  /**
   * Link a GitHub pull request to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkGitHubPR
   * @param url - required url to pass to attachmentLinkGitHubPR
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkGitHubPrMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkGitHubPR(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkGitHubPrMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkGitHubPrMutation(this._request).fetch(issueId, url, variables);
  }
  /**
   * Link an existing GitLab MR to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkGitLabMR
   * @param number - required number to pass to attachmentLinkGitLabMR
   * @param projectPathWithNamespace - required projectPathWithNamespace to pass to attachmentLinkGitLabMR
   * @param url - required url to pass to attachmentLinkGitLabMR
   * @param variables - variables without 'issueId', 'number', 'projectPathWithNamespace', 'url' to pass into the AttachmentLinkGitLabMrMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkGitLabMR(
    issueId: string,
    number: number,
    projectPathWithNamespace: string,
    url: string,
    variables?: Omit<
      L.AttachmentLinkGitLabMrMutationVariables,
      "issueId" | "number" | "projectPathWithNamespace" | "url"
    >
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkGitLabMrMutation(this._request).fetch(
      issueId,
      number,
      projectPathWithNamespace,
      url,
      variables
    );
  }
  /**
   * Link an existing Intercom conversation to an issue.
   *
   * @param conversationId - required conversationId to pass to attachmentLinkIntercom
   * @param issueId - required issueId to pass to attachmentLinkIntercom
   * @param variables - variables without 'conversationId', 'issueId' to pass into the AttachmentLinkIntercomMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkIntercom(
    conversationId: string,
    issueId: string,
    variables?: Omit<L.AttachmentLinkIntercomMutationVariables, "conversationId" | "issueId">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkIntercomMutation(this._request).fetch(conversationId, issueId, variables);
  }
  /**
   * Link an existing Jira issue to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkJiraIssue
   * @param jiraIssueId - required jiraIssueId to pass to attachmentLinkJiraIssue
   * @param variables - variables without 'issueId', 'jiraIssueId' to pass into the AttachmentLinkJiraIssueMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkJiraIssue(
    issueId: string,
    jiraIssueId: string,
    variables?: Omit<L.AttachmentLinkJiraIssueMutationVariables, "issueId" | "jiraIssueId">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkJiraIssueMutation(this._request).fetch(issueId, jiraIssueId, variables);
  }
  /**
   * Link an existing Salesforce case to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkSalesforce
   * @param url - required url to pass to attachmentLinkSalesforce
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkSalesforceMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkSalesforce(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkSalesforceMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkSalesforceMutation(this._request).fetch(issueId, url, variables);
  }
  /**
   * Link an existing Slack message to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkSlack
   * @param url - required url to pass to attachmentLinkSlack
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkSlackMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkSlack(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkSlackMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkSlackMutation(this._request).fetch(issueId, url, variables);
  }
  /**
   * Link any url to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkURL
   * @param url - required url to pass to attachmentLinkURL
   * @param variables - variables without 'issueId', 'url' to pass into the AttachmentLinkUrlMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkURL(
    issueId: string,
    url: string,
    variables?: Omit<L.AttachmentLinkUrlMutationVariables, "issueId" | "url">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkUrlMutation(this._request).fetch(issueId, url, variables);
  }
  /**
   * Link an existing Zendesk ticket to an issue.
   *
   * @param issueId - required issueId to pass to attachmentLinkZendesk
   * @param ticketId - required ticketId to pass to attachmentLinkZendesk
   * @param variables - variables without 'issueId', 'ticketId' to pass into the AttachmentLinkZendeskMutation
   * @returns AttachmentPayload
   */
  public attachmentLinkZendesk(
    issueId: string,
    ticketId: string,
    variables?: Omit<L.AttachmentLinkZendeskMutationVariables, "issueId" | "ticketId">
  ): LinearFetch<AttachmentPayload> {
    return new AttachmentLinkZendeskMutation(this._request).fetch(issueId, ticketId, variables);
  }
  /**
   * Begin syncing the thread for an existing Slack message attachment with a comment thread on its issue.
   *
   * @param id - required id to pass to attachmentSyncToSlack
   * @returns AttachmentPayload
   */
  public attachmentSyncToSlack(id: string): LinearFetch<AttachmentPayload> {
    return new AttachmentSyncToSlackMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing issue attachment.
   *
   * @param id - required id to pass to updateAttachment
   * @param input - required input to pass to updateAttachment
   * @returns AttachmentPayload
   */
  public updateAttachment(id: string, input: L.AttachmentUpdateInput): LinearFetch<AttachmentPayload> {
    return new UpdateAttachmentMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new comment.
   *
   * @param input - required input to pass to createComment
   * @returns CommentPayload
   */
  public createComment(input: L.CommentCreateInput): LinearFetch<CommentPayload> {
    return new CreateCommentMutation(this._request).fetch(input);
  }
  /**
   * Deletes a comment.
   *
   * @param id - required id to pass to deleteComment
   * @returns DeletePayload
   */
  public deleteComment(id: string): LinearFetch<DeletePayload> {
    return new DeleteCommentMutation(this._request).fetch(id);
  }
  /**
   * Resolves a comment.
   *
   * @param id - required id to pass to commentResolve
   * @param variables - variables without 'id' to pass into the CommentResolveMutation
   * @returns CommentPayload
   */
  public commentResolve(
    id: string,
    variables?: Omit<L.CommentResolveMutationVariables, "id">
  ): LinearFetch<CommentPayload> {
    return new CommentResolveMutation(this._request).fetch(id, variables);
  }
  /**
   * Unresolves a comment.
   *
   * @param id - required id to pass to commentUnresolve
   * @returns CommentPayload
   */
  public commentUnresolve(id: string): LinearFetch<CommentPayload> {
    return new CommentUnresolveMutation(this._request).fetch(id);
  }
  /**
   * Updates a comment.
   *
   * @param id - required id to pass to updateComment
   * @param input - required input to pass to updateComment
   * @returns CommentPayload
   */
  public updateComment(id: string, input: L.CommentUpdateInput): LinearFetch<CommentPayload> {
    return new UpdateCommentMutation(this._request).fetch(id, input);
  }
  /**
   * Saves user message.
   *
   * @param input - required input to pass to createContact
   * @returns ContactPayload
   */
  public createContact(input: L.ContactCreateInput): LinearFetch<ContactPayload> {
    return new CreateContactMutation(this._request).fetch(input);
  }
  /**
   * Create CSV export report for the organization.
   *
   * @param variables - variables to pass into the CreateCsvExportReportMutation
   * @returns CreateCsvExportReportPayload
   */
  public createCsvExportReport(
    variables?: L.CreateCsvExportReportMutationVariables
  ): LinearFetch<CreateCsvExportReportPayload> {
    return new CreateCsvExportReportMutation(this._request).fetch(variables);
  }
  /**
   * Create a notification to remind a user about an initiative update.
   *
   * @param initiativeId - required initiativeId to pass to createInitiativeUpdateReminder
   * @param variables - variables without 'initiativeId' to pass into the CreateInitiativeUpdateReminderMutation
   * @returns InitiativeUpdateReminderPayload
   */
  public createInitiativeUpdateReminder(
    initiativeId: string,
    variables?: Omit<L.CreateInitiativeUpdateReminderMutationVariables, "initiativeId">
  ): LinearFetch<InitiativeUpdateReminderPayload> {
    return new CreateInitiativeUpdateReminderMutation(this._request).fetch(initiativeId, variables);
  }
  /**
   * Creates an organization from onboarding.
   *
   * @param input - required input to pass to createOrganizationFromOnboarding
   * @param variables - variables without 'input' to pass into the CreateOrganizationFromOnboardingMutation
   * @returns CreateOrJoinOrganizationResponse
   */
  public createOrganizationFromOnboarding(
    input: L.CreateOrganizationInput,
    variables?: Omit<L.CreateOrganizationFromOnboardingMutationVariables, "input">
  ): LinearFetch<CreateOrJoinOrganizationResponse> {
    return new CreateOrganizationFromOnboardingMutation(this._request).fetch(input, variables);
  }
  /**
   * Create a notification to remind a user about a project update.
   *
   * @param projectId - required projectId to pass to createProjectUpdateReminder
   * @param variables - variables without 'projectId' to pass into the CreateProjectUpdateReminderMutation
   * @returns ProjectUpdateReminderPayload
   */
  public createProjectUpdateReminder(
    projectId: string,
    variables?: Omit<L.CreateProjectUpdateReminderMutationVariables, "projectId">
  ): LinearFetch<ProjectUpdateReminderPayload> {
    return new CreateProjectUpdateReminderMutation(this._request).fetch(projectId, variables);
  }
  /**
   * Creates a new custom view.
   *
   * @param input - required input to pass to createCustomView
   * @returns CustomViewPayload
   */
  public createCustomView(input: L.CustomViewCreateInput): LinearFetch<CustomViewPayload> {
    return new CreateCustomViewMutation(this._request).fetch(input);
  }
  /**
   * Deletes a custom view.
   *
   * @param id - required id to pass to deleteCustomView
   * @returns DeletePayload
   */
  public deleteCustomView(id: string): LinearFetch<DeletePayload> {
    return new DeleteCustomViewMutation(this._request).fetch(id);
  }
  /**
   * Updates a custom view.
   *
   * @param id - required id to pass to updateCustomView
   * @param input - required input to pass to updateCustomView
   * @returns CustomViewPayload
   */
  public updateCustomView(id: string, input: L.CustomViewUpdateInput): LinearFetch<CustomViewPayload> {
    return new UpdateCustomViewMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new customer.
   *
   * @param input - required input to pass to createCustomer
   * @returns CustomerPayload
   */
  public createCustomer(input: L.CustomerCreateInput): LinearFetch<CustomerPayload> {
    return new CreateCustomerMutation(this._request).fetch(input);
  }
  /**
   * Deletes a customer.
   *
   * @param id - required id to pass to deleteCustomer
   * @returns DeletePayload
   */
  public deleteCustomer(id: string): LinearFetch<DeletePayload> {
    return new DeleteCustomerMutation(this._request).fetch(id);
  }
  /**
   * Merges two customers.
   *
   * @param sourceCustomerId - required sourceCustomerId to pass to customerMerge
   * @param targetCustomerId - required targetCustomerId to pass to customerMerge
   * @returns CustomerPayload
   */
  public customerMerge(sourceCustomerId: string, targetCustomerId: string): LinearFetch<CustomerPayload> {
    return new CustomerMergeMutation(this._request).fetch(sourceCustomerId, targetCustomerId);
  }
  /**
   * Archives a customer need.
   *
   * @param id - required id to pass to archiveCustomerNeed
   * @returns CustomerNeedArchivePayload
   */
  public archiveCustomerNeed(id: string): LinearFetch<CustomerNeedArchivePayload> {
    return new ArchiveCustomerNeedMutation(this._request).fetch(id);
  }
  /**
   * Creates a new customer need.
   *
   * @param input - required input to pass to createCustomerNeed
   * @returns CustomerNeedPayload
   */
  public createCustomerNeed(input: L.CustomerNeedCreateInput): LinearFetch<CustomerNeedPayload> {
    return new CreateCustomerNeedMutation(this._request).fetch(input);
  }
  /**
   * Creates a new customer need out of an attachment
   *
   * @param input - required input to pass to customerNeedCreateFromAttachment
   * @returns CustomerNeedPayload
   */
  public customerNeedCreateFromAttachment(
    input: L.CustomerNeedCreateFromAttachmentInput
  ): LinearFetch<CustomerNeedPayload> {
    return new CustomerNeedCreateFromAttachmentMutation(this._request).fetch(input);
  }
  /**
   * Deletes a customer need.
   *
   * @param id - required id to pass to deleteCustomerNeed
   * @param variables - variables without 'id' to pass into the DeleteCustomerNeedMutation
   * @returns DeletePayload
   */
  public deleteCustomerNeed(
    id: string,
    variables?: Omit<L.DeleteCustomerNeedMutationVariables, "id">
  ): LinearFetch<DeletePayload> {
    return new DeleteCustomerNeedMutation(this._request).fetch(id, variables);
  }
  /**
   * Unarchives a customer need.
   *
   * @param id - required id to pass to unarchiveCustomerNeed
   * @returns CustomerNeedArchivePayload
   */
  public unarchiveCustomerNeed(id: string): LinearFetch<CustomerNeedArchivePayload> {
    return new UnarchiveCustomerNeedMutation(this._request).fetch(id);
  }
  /**
   * Updates a customer need
   *
   * @param id - required id to pass to updateCustomerNeed
   * @param input - required input to pass to updateCustomerNeed
   * @returns CustomerNeedUpdatePayload
   */
  public updateCustomerNeed(id: string, input: L.CustomerNeedUpdateInput): LinearFetch<CustomerNeedUpdatePayload> {
    return new UpdateCustomerNeedMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new customer status.
   *
   * @param input - required input to pass to createCustomerStatus
   * @returns CustomerStatusPayload
   */
  public createCustomerStatus(input: L.CustomerStatusCreateInput): LinearFetch<CustomerStatusPayload> {
    return new CreateCustomerStatusMutation(this._request).fetch(input);
  }
  /**
   * Deletes a customer status.
   *
   * @param id - required id to pass to deleteCustomerStatus
   * @returns DeletePayload
   */
  public deleteCustomerStatus(id: string): LinearFetch<DeletePayload> {
    return new DeleteCustomerStatusMutation(this._request).fetch(id);
  }
  /**
   * Updates a customer status.
   *
   * @param id - required id to pass to updateCustomerStatus
   * @param input - required input to pass to updateCustomerStatus
   * @returns CustomerStatusPayload
   */
  public updateCustomerStatus(id: string, input: L.CustomerStatusUpdateInput): LinearFetch<CustomerStatusPayload> {
    return new UpdateCustomerStatusMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new customer tier.
   *
   * @param input - required input to pass to createCustomerTier
   * @returns CustomerTierPayload
   */
  public createCustomerTier(input: L.CustomerTierCreateInput): LinearFetch<CustomerTierPayload> {
    return new CreateCustomerTierMutation(this._request).fetch(input);
  }
  /**
   * Deletes a customer tier.
   *
   * @param id - required id to pass to deleteCustomerTier
   * @returns DeletePayload
   */
  public deleteCustomerTier(id: string): LinearFetch<DeletePayload> {
    return new DeleteCustomerTierMutation(this._request).fetch(id);
  }
  /**
   * Updates a customer tier.
   *
   * @param id - required id to pass to updateCustomerTier
   * @param input - required input to pass to updateCustomerTier
   * @returns CustomerTierPayload
   */
  public updateCustomerTier(id: string, input: L.CustomerTierUpdateInput): LinearFetch<CustomerTierPayload> {
    return new UpdateCustomerTierMutation(this._request).fetch(id, input);
  }
  /**
   * Updates a customer
   *
   * @param id - required id to pass to updateCustomer
   * @param input - required input to pass to updateCustomer
   * @returns CustomerPayload
   */
  public updateCustomer(id: string, input: L.CustomerUpdateInput): LinearFetch<CustomerPayload> {
    return new UpdateCustomerMutation(this._request).fetch(id, input);
  }
  /**
   * Upserts a customer, creating it if it doesn't exists, updating it otherwise. Matches against an existing customer with `id` or `externalId`
   *
   * @param input - required input to pass to customerUpsert
   * @returns CustomerPayload
   */
  public customerUpsert(input: L.CustomerUpsertInput): LinearFetch<CustomerPayload> {
    return new CustomerUpsertMutation(this._request).fetch(input);
  }
  /**
   * Archives a cycle.
   *
   * @param id - required id to pass to archiveCycle
   * @returns CycleArchivePayload
   */
  public archiveCycle(id: string): LinearFetch<CycleArchivePayload> {
    return new ArchiveCycleMutation(this._request).fetch(id);
  }
  /**
   * Creates a new cycle.
   *
   * @param input - required input to pass to createCycle
   * @returns CyclePayload
   */
  public createCycle(input: L.CycleCreateInput): LinearFetch<CyclePayload> {
    return new CreateCycleMutation(this._request).fetch(input);
  }
  /**
   * Shifts all cycles starts and ends by a certain number of days, starting from the provided cycle onwards.
   *
   * @param input - required input to pass to cycleShiftAll
   * @returns CyclePayload
   */
  public cycleShiftAll(input: L.CycleShiftAllInput): LinearFetch<CyclePayload> {
    return new CycleShiftAllMutation(this._request).fetch(input);
  }
  /**
   * Shifts all cycles starts and ends by a certain number of days, starting from the provided cycle onwards.
   *
   * @param id - required id to pass to cycleStartUpcomingCycleToday
   * @returns CyclePayload
   */
  public cycleStartUpcomingCycleToday(id: string): LinearFetch<CyclePayload> {
    return new CycleStartUpcomingCycleTodayMutation(this._request).fetch(id);
  }
  /**
   * Updates a cycle.
   *
   * @param id - required id to pass to updateCycle
   * @param input - required input to pass to updateCycle
   * @returns CyclePayload
   */
  public updateCycle(id: string, input: L.CycleUpdateInput): LinearFetch<CyclePayload> {
    return new UpdateCycleMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new document.
   *
   * @param input - required input to pass to createDocument
   * @returns DocumentPayload
   */
  public createDocument(input: L.DocumentCreateInput): LinearFetch<DocumentPayload> {
    return new CreateDocumentMutation(this._request).fetch(input);
  }
  /**
   * Deletes (trashes) a document.
   *
   * @param id - required id to pass to deleteDocument
   * @returns DocumentArchivePayload
   */
  public deleteDocument(id: string): LinearFetch<DocumentArchivePayload> {
    return new DeleteDocumentMutation(this._request).fetch(id);
  }
  /**
   * Restores a document.
   *
   * @param id - required id to pass to unarchiveDocument
   * @returns DocumentArchivePayload
   */
  public unarchiveDocument(id: string): LinearFetch<DocumentArchivePayload> {
    return new UnarchiveDocumentMutation(this._request).fetch(id);
  }
  /**
   * Updates a document.
   *
   * @param id - required id to pass to updateDocument
   * @param input - required input to pass to updateDocument
   * @returns DocumentPayload
   */
  public updateDocument(id: string, input: L.DocumentUpdateInput): LinearFetch<DocumentPayload> {
    return new UpdateDocumentMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new email intake address.
   *
   * @param input - required input to pass to createEmailIntakeAddress
   * @returns EmailIntakeAddressPayload
   */
  public createEmailIntakeAddress(input: L.EmailIntakeAddressCreateInput): LinearFetch<EmailIntakeAddressPayload> {
    return new CreateEmailIntakeAddressMutation(this._request).fetch(input);
  }
  /**
   * Deletes an email intake address object.
   *
   * @param id - required id to pass to deleteEmailIntakeAddress
   * @returns DeletePayload
   */
  public deleteEmailIntakeAddress(id: string): LinearFetch<DeletePayload> {
    return new DeleteEmailIntakeAddressMutation(this._request).fetch(id);
  }
  /**
   * Rotates an existing email intake address.
   *
   * @param id - required id to pass to emailIntakeAddressRotate
   * @returns EmailIntakeAddressPayload
   */
  public emailIntakeAddressRotate(id: string): LinearFetch<EmailIntakeAddressPayload> {
    return new EmailIntakeAddressRotateMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing email intake address.
   *
   * @param id - required id to pass to updateEmailIntakeAddress
   * @param input - required input to pass to updateEmailIntakeAddress
   * @returns EmailIntakeAddressPayload
   */
  public updateEmailIntakeAddress(
    id: string,
    input: L.EmailIntakeAddressUpdateInput
  ): LinearFetch<EmailIntakeAddressPayload> {
    return new UpdateEmailIntakeAddressMutation(this._request).fetch(id, input);
  }
  /**
   * Authenticates a user account via email and authentication token.
   *
   * @param input - required input to pass to emailTokenUserAccountAuth
   * @returns AuthResolverResponse
   */
  public emailTokenUserAccountAuth(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse> {
    return new EmailTokenUserAccountAuthMutation(this._request).fetch(input);
  }
  /**
   * Unsubscribes the user from one type of email.
   *
   * @param input - required input to pass to emailUnsubscribe
   * @returns EmailUnsubscribePayload
   */
  public emailUnsubscribe(input: L.EmailUnsubscribeInput): LinearFetch<EmailUnsubscribePayload> {
    return new EmailUnsubscribeMutation(this._request).fetch(input);
  }
  /**
   * Finds or creates a new user account by email and sends an email with token.
   *
   * @param input - required input to pass to emailUserAccountAuthChallenge
   * @returns EmailUserAccountAuthChallengeResponse
   */
  public emailUserAccountAuthChallenge(
    input: L.EmailUserAccountAuthChallengeInput
  ): LinearFetch<EmailUserAccountAuthChallengeResponse> {
    return new EmailUserAccountAuthChallengeMutation(this._request).fetch(input);
  }
  /**
   * Creates a custom emoji.
   *
   * @param input - required input to pass to createEmoji
   * @returns EmojiPayload
   */
  public createEmoji(input: L.EmojiCreateInput): LinearFetch<EmojiPayload> {
    return new CreateEmojiMutation(this._request).fetch(input);
  }
  /**
   * Deletes an emoji.
   *
   * @param id - required id to pass to deleteEmoji
   * @returns DeletePayload
   */
  public deleteEmoji(id: string): LinearFetch<DeletePayload> {
    return new DeleteEmojiMutation(this._request).fetch(id);
  }
  /**
   * Creates a new entity link.
   *
   * @param input - required input to pass to createEntityExternalLink
   * @returns EntityExternalLinkPayload
   */
  public createEntityExternalLink(input: L.EntityExternalLinkCreateInput): LinearFetch<EntityExternalLinkPayload> {
    return new CreateEntityExternalLinkMutation(this._request).fetch(input);
  }
  /**
   * Deletes an entity link.
   *
   * @param id - required id to pass to deleteEntityExternalLink
   * @returns DeletePayload
   */
  public deleteEntityExternalLink(id: string): LinearFetch<DeletePayload> {
    return new DeleteEntityExternalLinkMutation(this._request).fetch(id);
  }
  /**
   * Updates an entity link.
   *
   * @param id - required id to pass to updateEntityExternalLink
   * @param input - required input to pass to updateEntityExternalLink
   * @returns EntityExternalLinkPayload
   */
  public updateEntityExternalLink(
    id: string,
    input: L.EntityExternalLinkUpdateInput
  ): LinearFetch<EntityExternalLinkPayload> {
    return new UpdateEntityExternalLinkMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new favorite (project, cycle etc).
   *
   * @param input - required input to pass to createFavorite
   * @returns FavoritePayload
   */
  public createFavorite(input: L.FavoriteCreateInput): LinearFetch<FavoritePayload> {
    return new CreateFavoriteMutation(this._request).fetch(input);
  }
  /**
   * Deletes a favorite reference.
   *
   * @param id - required id to pass to deleteFavorite
   * @returns DeletePayload
   */
  public deleteFavorite(id: string): LinearFetch<DeletePayload> {
    return new DeleteFavoriteMutation(this._request).fetch(id);
  }
  /**
   * Updates a favorite.
   *
   * @param id - required id to pass to updateFavorite
   * @param input - required input to pass to updateFavorite
   * @returns FavoritePayload
   */
  public updateFavorite(id: string, input: L.FavoriteUpdateInput): LinearFetch<FavoritePayload> {
    return new UpdateFavoriteMutation(this._request).fetch(id, input);
  }
  /**
   * XHR request payload to upload an images, video and other attachments directly to Linear's cloud storage.
   *
   * @param contentType - required contentType to pass to fileUpload
   * @param filename - required filename to pass to fileUpload
   * @param size - required size to pass to fileUpload
   * @param variables - variables without 'contentType', 'filename', 'size' to pass into the FileUploadMutation
   * @returns UploadPayload
   */
  public fileUpload(
    contentType: string,
    filename: string,
    size: number,
    variables?: Omit<L.FileUploadMutationVariables, "contentType" | "filename" | "size">
  ): LinearFetch<UploadPayload> {
    return new FileUploadMutation(this._request).fetch(contentType, filename, size, variables);
  }
  /**
   * Creates a new automation state.
   *
   * @param input - required input to pass to createGitAutomationState
   * @returns GitAutomationStatePayload
   */
  public createGitAutomationState(input: L.GitAutomationStateCreateInput): LinearFetch<GitAutomationStatePayload> {
    return new CreateGitAutomationStateMutation(this._request).fetch(input);
  }
  /**
   * Archives an automation state.
   *
   * @param id - required id to pass to deleteGitAutomationState
   * @returns DeletePayload
   */
  public deleteGitAutomationState(id: string): LinearFetch<DeletePayload> {
    return new DeleteGitAutomationStateMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing state.
   *
   * @param id - required id to pass to updateGitAutomationState
   * @param input - required input to pass to updateGitAutomationState
   * @returns GitAutomationStatePayload
   */
  public updateGitAutomationState(
    id: string,
    input: L.GitAutomationStateUpdateInput
  ): LinearFetch<GitAutomationStatePayload> {
    return new UpdateGitAutomationStateMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a Git target branch automation.
   *
   * @param input - required input to pass to createGitAutomationTargetBranch
   * @returns GitAutomationTargetBranchPayload
   */
  public createGitAutomationTargetBranch(
    input: L.GitAutomationTargetBranchCreateInput
  ): LinearFetch<GitAutomationTargetBranchPayload> {
    return new CreateGitAutomationTargetBranchMutation(this._request).fetch(input);
  }
  /**
   * Archives a Git target branch automation.
   *
   * @param id - required id to pass to deleteGitAutomationTargetBranch
   * @returns DeletePayload
   */
  public deleteGitAutomationTargetBranch(id: string): LinearFetch<DeletePayload> {
    return new DeleteGitAutomationTargetBranchMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing Git target branch automation.
   *
   * @param id - required id to pass to updateGitAutomationTargetBranch
   * @param input - required input to pass to updateGitAutomationTargetBranch
   * @returns GitAutomationTargetBranchPayload
   */
  public updateGitAutomationTargetBranch(
    id: string,
    input: L.GitAutomationTargetBranchUpdateInput
  ): LinearFetch<GitAutomationTargetBranchPayload> {
    return new UpdateGitAutomationTargetBranchMutation(this._request).fetch(id, input);
  }
  /**
   * Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
   *
   * @param input - required input to pass to googleUserAccountAuth
   * @returns AuthResolverResponse
   */
  public googleUserAccountAuth(input: L.GoogleUserAccountAuthInput): LinearFetch<AuthResolverResponse> {
    return new GoogleUserAccountAuthMutation(this._request).fetch(input);
  }
  /**
   * Upload an image from an URL to Linear.
   *
   * @param url - required url to pass to imageUploadFromUrl
   * @returns ImageUploadFromUrlPayload
   */
  public imageUploadFromUrl(url: string): LinearFetch<ImageUploadFromUrlPayload> {
    return new ImageUploadFromUrlMutation(this._request).fetch(url);
  }
  /**
   * XHR request payload to upload a file for import, directly to Linear's cloud storage.
   *
   * @param contentType - required contentType to pass to importFileUpload
   * @param filename - required filename to pass to importFileUpload
   * @param size - required size to pass to importFileUpload
   * @param variables - variables without 'contentType', 'filename', 'size' to pass into the ImportFileUploadMutation
   * @returns UploadPayload
   */
  public importFileUpload(
    contentType: string,
    filename: string,
    size: number,
    variables?: Omit<L.ImportFileUploadMutationVariables, "contentType" | "filename" | "size">
  ): LinearFetch<UploadPayload> {
    return new ImportFileUploadMutation(this._request).fetch(contentType, filename, size, variables);
  }
  /**
   * Archives a initiative.
   *
   * @param id - required id to pass to archiveInitiative
   * @returns InitiativeArchivePayload
   */
  public archiveInitiative(id: string): LinearFetch<InitiativeArchivePayload> {
    return new ArchiveInitiativeMutation(this._request).fetch(id);
  }
  /**
   * Creates a new initiative.
   *
   * @param input - required input to pass to createInitiative
   * @returns InitiativePayload
   */
  public createInitiative(input: L.InitiativeCreateInput): LinearFetch<InitiativePayload> {
    return new CreateInitiativeMutation(this._request).fetch(input);
  }
  /**
   * Deletes (trashes) an initiative.
   *
   * @param id - required id to pass to deleteInitiative
   * @returns DeletePayload
   */
  public deleteInitiative(id: string): LinearFetch<DeletePayload> {
    return new DeleteInitiativeMutation(this._request).fetch(id);
  }
  /**
   * Creates a new initiative relation.
   *
   * @param input - required input to pass to createInitiativeRelation
   * @returns InitiativeRelationPayload
   */
  public createInitiativeRelation(input: L.InitiativeRelationCreateInput): LinearFetch<InitiativeRelationPayload> {
    return new CreateInitiativeRelationMutation(this._request).fetch(input);
  }
  /**
   * Deletes an initiative relation.
   *
   * @param id - required id to pass to deleteInitiativeRelation
   * @returns DeletePayload
   */
  public deleteInitiativeRelation(id: string): LinearFetch<DeletePayload> {
    return new DeleteInitiativeRelationMutation(this._request).fetch(id);
  }
  /**
   * Updates an initiative relation.
   *
   * @param id - required id to pass to updateInitiativeRelation
   * @param input - required input to pass to updateInitiativeRelation
   * @returns DeletePayload
   */
  public updateInitiativeRelation(id: string, input: L.InitiativeRelationUpdateInput): LinearFetch<DeletePayload> {
    return new UpdateInitiativeRelationMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new initiativeToProject join.
   *
   * @param input - required input to pass to createInitiativeToProject
   * @returns InitiativeToProjectPayload
   */
  public createInitiativeToProject(input: L.InitiativeToProjectCreateInput): LinearFetch<InitiativeToProjectPayload> {
    return new CreateInitiativeToProjectMutation(this._request).fetch(input);
  }
  /**
   * Deletes a initiativeToProject.
   *
   * @param id - required id to pass to deleteInitiativeToProject
   * @returns DeletePayload
   */
  public deleteInitiativeToProject(id: string): LinearFetch<DeletePayload> {
    return new DeleteInitiativeToProjectMutation(this._request).fetch(id);
  }
  /**
   * Updates a initiativeToProject.
   *
   * @param id - required id to pass to updateInitiativeToProject
   * @param input - required input to pass to updateInitiativeToProject
   * @returns InitiativeToProjectPayload
   */
  public updateInitiativeToProject(
    id: string,
    input: L.InitiativeToProjectUpdateInput
  ): LinearFetch<InitiativeToProjectPayload> {
    return new UpdateInitiativeToProjectMutation(this._request).fetch(id, input);
  }
  /**
   * Unarchives a initiative.
   *
   * @param id - required id to pass to unarchiveInitiative
   * @returns InitiativeArchivePayload
   */
  public unarchiveInitiative(id: string): LinearFetch<InitiativeArchivePayload> {
    return new UnarchiveInitiativeMutation(this._request).fetch(id);
  }
  /**
   * Updates a initiative.
   *
   * @param id - required id to pass to updateInitiative
   * @param input - required input to pass to updateInitiative
   * @returns InitiativePayload
   */
  public updateInitiative(id: string, input: L.InitiativeUpdateInput): LinearFetch<InitiativePayload> {
    return new UpdateInitiativeMutation(this._request).fetch(id, input);
  }
  /**
   * Archives an initiative update.
   *
   * @param id - required id to pass to archiveInitiativeUpdate
   * @returns InitiativeUpdateArchivePayload
   */
  public archiveInitiativeUpdate(id: string): LinearFetch<InitiativeUpdateArchivePayload> {
    return new ArchiveInitiativeUpdateMutation(this._request).fetch(id);
  }
  /**
   * Creates a initiative update.
   *
   * @param input - required input to pass to createInitiativeUpdate
   * @returns InitiativeUpdatePayload
   */
  public createInitiativeUpdate(input: L.InitiativeUpdateCreateInput): LinearFetch<InitiativeUpdatePayload> {
    return new CreateInitiativeUpdateMutation(this._request).fetch(input);
  }
  /**
   * Unarchives an initiative update.
   *
   * @param id - required id to pass to unarchiveInitiativeUpdate
   * @returns InitiativeUpdateArchivePayload
   */
  public unarchiveInitiativeUpdate(id: string): LinearFetch<InitiativeUpdateArchivePayload> {
    return new UnarchiveInitiativeUpdateMutation(this._request).fetch(id);
  }
  /**
   * Updates an update.
   *
   * @param id - required id to pass to updateInitiativeUpdate
   * @param input - required input to pass to updateInitiativeUpdate
   * @returns InitiativeUpdatePayload
   */
  public updateInitiativeUpdate(
    id: string,
    input: L.InitiativeUpdateUpdateInput
  ): LinearFetch<InitiativeUpdatePayload> {
    return new UpdateInitiativeUpdateMutation(this._request).fetch(id, input);
  }
  /**
   * Archives an integration.
   *
   * @param id - required id to pass to archiveIntegration
   * @returns DeletePayload
   */
  public archiveIntegration(id: string): LinearFetch<DeletePayload> {
    return new ArchiveIntegrationMutation(this._request).fetch(id);
  }
  /**
   * Connect a Slack channel to Asks.
   *
   * @param code - required code to pass to integrationAsksConnectChannel
   * @param redirectUri - required redirectUri to pass to integrationAsksConnectChannel
   * @returns AsksChannelConnectPayload
   */
  public integrationAsksConnectChannel(code: string, redirectUri: string): LinearFetch<AsksChannelConnectPayload> {
    return new IntegrationAsksConnectChannelMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Deletes an integration.
   *
   * @param id - required id to pass to deleteIntegration
   * @returns DeletePayload
   */
  public deleteIntegration(id: string): LinearFetch<DeletePayload> {
    return new DeleteIntegrationMutation(this._request).fetch(id);
  }
  /**
   * Integrates the organization with Discord.
   *
   * @param code - required code to pass to integrationDiscord
   * @param redirectUri - required redirectUri to pass to integrationDiscord
   * @returns IntegrationPayload
   */
  public integrationDiscord(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    return new IntegrationDiscordMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Integrates the organization with Figma.
   *
   * @param code - required code to pass to integrationFigma
   * @param redirectUri - required redirectUri to pass to integrationFigma
   * @returns IntegrationPayload
   */
  public integrationFigma(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    return new IntegrationFigmaMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Integrates the organization with Front.
   *
   * @param code - required code to pass to integrationFront
   * @param redirectUri - required redirectUri to pass to integrationFront
   * @returns IntegrationPayload
   */
  public integrationFront(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    return new IntegrationFrontMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Connects the organization with a GitHub Enterprise Server.
   *
   * @param githubUrl - required githubUrl to pass to integrationGitHubEnterpriseServerConnect
   * @param variables - variables without 'githubUrl' to pass into the IntegrationGitHubEnterpriseServerConnectMutation
   * @returns GitHubEnterpriseServerPayload
   */
  public integrationGitHubEnterpriseServerConnect(
    githubUrl: string,
    variables?: Omit<L.IntegrationGitHubEnterpriseServerConnectMutationVariables, "githubUrl">
  ): LinearFetch<GitHubEnterpriseServerPayload> {
    return new IntegrationGitHubEnterpriseServerConnectMutation(this._request).fetch(githubUrl, variables);
  }
  /**
   * Connect your GitHub account to Linear.
   *
   * @param code - required code to pass to integrationGitHubPersonal
   * @returns IntegrationPayload
   */
  public integrationGitHubPersonal(code: string): LinearFetch<IntegrationPayload> {
    return new IntegrationGitHubPersonalMutation(this._request).fetch(code);
  }
  /**
   * Generates a webhook for the GitHub commit integration.
   *
   * @returns GitHubCommitIntegrationPayload
   */
  public get createIntegrationGithubCommit(): LinearFetch<GitHubCommitIntegrationPayload> {
    return new CreateIntegrationGithubCommitMutation(this._request).fetch();
  }
  /**
   * Connects the organization with the GitHub App.
   *
   * @param code - required code to pass to integrationGithubConnect
   * @param installationId - required installationId to pass to integrationGithubConnect
   * @returns IntegrationPayload
   */
  public integrationGithubConnect(code: string, installationId: string): LinearFetch<IntegrationPayload> {
    return new IntegrationGithubConnectMutation(this._request).fetch(code, installationId);
  }
  /**
   * Connects the organization with the GitHub Import App.
   *
   * @param code - required code to pass to integrationGithubImportConnect
   * @param installationId - required installationId to pass to integrationGithubImportConnect
   * @returns IntegrationPayload
   */
  public integrationGithubImportConnect(code: string, installationId: string): LinearFetch<IntegrationPayload> {
    return new IntegrationGithubImportConnectMutation(this._request).fetch(code, installationId);
  }
  /**
   * Refreshes the data for a GitHub import integration.
   *
   * @param id - required id to pass to integrationGithubImportRefresh
   * @returns IntegrationPayload
   */
  public integrationGithubImportRefresh(id: string): LinearFetch<IntegrationPayload> {
    return new IntegrationGithubImportRefreshMutation(this._request).fetch(id);
  }
  /**
   * Connects the organization with a GitLab Access Token.
   *
   * @param accessToken - required accessToken to pass to integrationGitlabConnect
   * @param gitlabUrl - required gitlabUrl to pass to integrationGitlabConnect
   * @returns GitLabIntegrationCreatePayload
   */
  public integrationGitlabConnect(accessToken: string, gitlabUrl: string): LinearFetch<GitLabIntegrationCreatePayload> {
    return new IntegrationGitlabConnectMutation(this._request).fetch(accessToken, gitlabUrl);
  }
  /**
   * Integrates the organization with Google Sheets.
   *
   * @param code - required code to pass to integrationGoogleSheets
   * @returns IntegrationPayload
   */
  public integrationGoogleSheets(code: string): LinearFetch<IntegrationPayload> {
    return new IntegrationGoogleSheetsMutation(this._request).fetch(code);
  }
  /**
   * Integrates the organization with Intercom.
   *
   * @param code - required code to pass to integrationIntercom
   * @param redirectUri - required redirectUri to pass to integrationIntercom
   * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationIntercomMutation
   * @returns IntegrationPayload
   */
  public integrationIntercom(
    code: string,
    redirectUri: string,
    variables?: Omit<L.IntegrationIntercomMutationVariables, "code" | "redirectUri">
  ): LinearFetch<IntegrationPayload> {
    return new IntegrationIntercomMutation(this._request).fetch(code, redirectUri, variables);
  }
  /**
   * Disconnects the organization from Intercom.
   *
   * @returns IntegrationPayload
   */
  public get deleteIntegrationIntercom(): LinearFetch<IntegrationPayload> {
    return new DeleteIntegrationIntercomMutation(this._request).fetch();
  }
  /**
   * [DEPRECATED] Updates settings on the Intercom integration.
   *
   * @param input - required input to pass to updateIntegrationIntercomSettings
   * @returns IntegrationPayload
   */
  public updateIntegrationIntercomSettings(input: L.IntercomSettingsInput): LinearFetch<IntegrationPayload> {
    return new UpdateIntegrationIntercomSettingsMutation(this._request).fetch(input);
  }
  /**
   * Connect your Jira account to Linear.
   *
   * @param variables - variables to pass into the IntegrationJiraPersonalMutation
   * @returns IntegrationPayload
   */
  public integrationJiraPersonal(
    variables?: L.IntegrationJiraPersonalMutationVariables
  ): LinearFetch<IntegrationPayload> {
    return new IntegrationJiraPersonalMutation(this._request).fetch(variables);
  }
  /**
   * Enables Loom integration for the organization.
   *
   * @returns IntegrationPayload
   */
  public get integrationLoom(): LinearFetch<IntegrationPayload> {
    return new IntegrationLoomMutation(this._request).fetch();
  }
  /**
   * Requests a currently unavailable integration.
   *
   * @param input - required input to pass to integrationRequest
   * @returns IntegrationRequestPayload
   */
  public integrationRequest(input: L.IntegrationRequestInput): LinearFetch<IntegrationRequestPayload> {
    return new IntegrationRequestMutation(this._request).fetch(input);
  }
  /**
   * Integrates the organization with Salesforce.
   *
   * @param code - required code to pass to integrationSalesforce
   * @param redirectUri - required redirectUri to pass to integrationSalesforce
   * @param subdomain - required subdomain to pass to integrationSalesforce
   * @returns IntegrationPayload
   */
  public integrationSalesforce(code: string, redirectUri: string, subdomain: string): LinearFetch<IntegrationPayload> {
    return new IntegrationSalesforceMutation(this._request).fetch(code, redirectUri, subdomain);
  }
  /**
   * Integrates the organization with Sentry.
   *
   * @param code - required code to pass to integrationSentryConnect
   * @param installationId - required installationId to pass to integrationSentryConnect
   * @param organizationSlug - required organizationSlug to pass to integrationSentryConnect
   * @returns IntegrationPayload
   */
  public integrationSentryConnect(
    code: string,
    installationId: string,
    organizationSlug: string
  ): LinearFetch<IntegrationPayload> {
    return new IntegrationSentryConnectMutation(this._request).fetch(code, installationId, organizationSlug);
  }
  /**
   * Integrates the organization with Slack.
   *
   * @param code - required code to pass to integrationSlack
   * @param redirectUri - required redirectUri to pass to integrationSlack
   * @param variables - variables without 'code', 'redirectUri' to pass into the IntegrationSlackMutation
   * @returns IntegrationPayload
   */
  public integrationSlack(
    code: string,
    redirectUri: string,
    variables?: Omit<L.IntegrationSlackMutationVariables, "code" | "redirectUri">
  ): LinearFetch<IntegrationPayload> {
    return new IntegrationSlackMutation(this._request).fetch(code, redirectUri, variables);
  }
  /**
   * Integrates the organization with the Slack Asks app.
   *
   * @param code - required code to pass to integrationSlackAsks
   * @param redirectUri - required redirectUri to pass to integrationSlackAsks
   * @returns IntegrationPayload
   */
  public integrationSlackAsks(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    return new IntegrationSlackAsksMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Slack integration for custom view notifications.
   *
   * @param code - required code to pass to integrationSlackCustomViewNotifications
   * @param customViewId - required customViewId to pass to integrationSlackCustomViewNotifications
   * @param redirectUri - required redirectUri to pass to integrationSlackCustomViewNotifications
   * @returns SlackChannelConnectPayload
   */
  public integrationSlackCustomViewNotifications(
    code: string,
    customViewId: string,
    redirectUri: string
  ): LinearFetch<SlackChannelConnectPayload> {
    return new IntegrationSlackCustomViewNotificationsMutation(this._request).fetch(code, customViewId, redirectUri);
  }
  /**
   * Integrates a Slack Asks channel with a Customer.
   *
   * @param code - required code to pass to integrationSlackCustomerChannelLink
   * @param customerId - required customerId to pass to integrationSlackCustomerChannelLink
   * @param redirectUri - required redirectUri to pass to integrationSlackCustomerChannelLink
   * @returns SuccessPayload
   */
  public integrationSlackCustomerChannelLink(
    code: string,
    customerId: string,
    redirectUri: string
  ): LinearFetch<SuccessPayload> {
    return new IntegrationSlackCustomerChannelLinkMutation(this._request).fetch(code, customerId, redirectUri);
  }
  /**
   * Imports custom emojis from your Slack workspace.
   *
   * @param code - required code to pass to integrationSlackImportEmojis
   * @param redirectUri - required redirectUri to pass to integrationSlackImportEmojis
   * @returns IntegrationPayload
   */
  public integrationSlackImportEmojis(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    return new IntegrationSlackImportEmojisMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Slack integration for organization level project update notifications.
   *
   * @param code - required code to pass to integrationSlackOrgProjectUpdatesPost
   * @param redirectUri - required redirectUri to pass to integrationSlackOrgProjectUpdatesPost
   * @returns SlackChannelConnectPayload
   */
  public integrationSlackOrgProjectUpdatesPost(
    code: string,
    redirectUri: string
  ): LinearFetch<SlackChannelConnectPayload> {
    return new IntegrationSlackOrgProjectUpdatesPostMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Integrates your personal notifications with Slack.
   *
   * @param code - required code to pass to integrationSlackPersonal
   * @param redirectUri - required redirectUri to pass to integrationSlackPersonal
   * @returns IntegrationPayload
   */
  public integrationSlackPersonal(code: string, redirectUri: string): LinearFetch<IntegrationPayload> {
    return new IntegrationSlackPersonalMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Slack integration for team notifications.
   *
   * @param code - required code to pass to integrationSlackPost
   * @param redirectUri - required redirectUri to pass to integrationSlackPost
   * @param teamId - required teamId to pass to integrationSlackPost
   * @param variables - variables without 'code', 'redirectUri', 'teamId' to pass into the IntegrationSlackPostMutation
   * @returns SlackChannelConnectPayload
   */
  public integrationSlackPost(
    code: string,
    redirectUri: string,
    teamId: string,
    variables?: Omit<L.IntegrationSlackPostMutationVariables, "code" | "redirectUri" | "teamId">
  ): LinearFetch<SlackChannelConnectPayload> {
    return new IntegrationSlackPostMutation(this._request).fetch(code, redirectUri, teamId, variables);
  }
  /**
   * Slack integration for project notifications.
   *
   * @param code - required code to pass to integrationSlackProjectPost
   * @param projectId - required projectId to pass to integrationSlackProjectPost
   * @param redirectUri - required redirectUri to pass to integrationSlackProjectPost
   * @param service - required service to pass to integrationSlackProjectPost
   * @returns SlackChannelConnectPayload
   */
  public integrationSlackProjectPost(
    code: string,
    projectId: string,
    redirectUri: string,
    service: string
  ): LinearFetch<SlackChannelConnectPayload> {
    return new IntegrationSlackProjectPostMutation(this._request).fetch(code, projectId, redirectUri, service);
  }
  /**
   * Creates a new integrationTemplate join.
   *
   * @param input - required input to pass to createIntegrationTemplate
   * @returns IntegrationTemplatePayload
   */
  public createIntegrationTemplate(input: L.IntegrationTemplateCreateInput): LinearFetch<IntegrationTemplatePayload> {
    return new CreateIntegrationTemplateMutation(this._request).fetch(input);
  }
  /**
   * Deletes a integrationTemplate.
   *
   * @param id - required id to pass to deleteIntegrationTemplate
   * @returns DeletePayload
   */
  public deleteIntegrationTemplate(id: string): LinearFetch<DeletePayload> {
    return new DeleteIntegrationTemplateMutation(this._request).fetch(id);
  }
  /**
   * Integrates the organization with Zendesk.
   *
   * @param code - required code to pass to integrationZendesk
   * @param redirectUri - required redirectUri to pass to integrationZendesk
   * @param scope - required scope to pass to integrationZendesk
   * @param subdomain - required subdomain to pass to integrationZendesk
   * @returns IntegrationPayload
   */
  public integrationZendesk(
    code: string,
    redirectUri: string,
    scope: string,
    subdomain: string
  ): LinearFetch<IntegrationPayload> {
    return new IntegrationZendeskMutation(this._request).fetch(code, redirectUri, scope, subdomain);
  }
  /**
   * Creates new settings for one or more integrations.
   *
   * @param input - required input to pass to createIntegrationsSettings
   * @returns IntegrationsSettingsPayload
   */
  public createIntegrationsSettings(
    input: L.IntegrationsSettingsCreateInput
  ): LinearFetch<IntegrationsSettingsPayload> {
    return new CreateIntegrationsSettingsMutation(this._request).fetch(input);
  }
  /**
   * Updates settings related to integrations for a project or a team.
   *
   * @param id - required id to pass to updateIntegrationsSettings
   * @param input - required input to pass to updateIntegrationsSettings
   * @returns IntegrationsSettingsPayload
   */
  public updateIntegrationsSettings(
    id: string,
    input: L.IntegrationsSettingsUpdateInput
  ): LinearFetch<IntegrationsSettingsPayload> {
    return new UpdateIntegrationsSettingsMutation(this._request).fetch(id, input);
  }
  /**
   * Adds a label to an issue.
   *
   * @param id - required id to pass to issueAddLabel
   * @param labelId - required labelId to pass to issueAddLabel
   * @returns IssuePayload
   */
  public issueAddLabel(id: string, labelId: string): LinearFetch<IssuePayload> {
    return new IssueAddLabelMutation(this._request).fetch(id, labelId);
  }
  /**
   * Archives an issue.
   *
   * @param id - required id to pass to archiveIssue
   * @param variables - variables without 'id' to pass into the ArchiveIssueMutation
   * @returns IssueArchivePayload
   */
  public archiveIssue(
    id: string,
    variables?: Omit<L.ArchiveIssueMutationVariables, "id">
  ): LinearFetch<IssueArchivePayload> {
    return new ArchiveIssueMutation(this._request).fetch(id, variables);
  }
  /**
   * Creates a list of issues in one transaction.
   *
   * @param input - required input to pass to createIssueBatch
   * @returns IssueBatchPayload
   */
  public createIssueBatch(input: L.IssueBatchCreateInput): LinearFetch<IssueBatchPayload> {
    return new CreateIssueBatchMutation(this._request).fetch(input);
  }
  /**
   * Updates multiple issues at once.
   *
   * @param ids - required ids to pass to updateIssueBatch
   * @param input - required input to pass to updateIssueBatch
   * @returns IssueBatchPayload
   */
  public updateIssueBatch(ids: L.Scalars["UUID"][], input: L.IssueUpdateInput): LinearFetch<IssueBatchPayload> {
    return new UpdateIssueBatchMutation(this._request).fetch(ids, input);
  }
  /**
   * Creates a new issue.
   *
   * @param input - required input to pass to createIssue
   * @returns IssuePayload
   */
  public createIssue(input: L.IssueCreateInput): LinearFetch<IssuePayload> {
    return new CreateIssueMutation(this._request).fetch(input);
  }
  /**
   * Deletes (trashes) an issue.
   *
   * @param id - required id to pass to deleteIssue
   * @param variables - variables without 'id' to pass into the DeleteIssueMutation
   * @returns IssueArchivePayload
   */
  public deleteIssue(
    id: string,
    variables?: Omit<L.DeleteIssueMutationVariables, "id">
  ): LinearFetch<IssueArchivePayload> {
    return new DeleteIssueMutation(this._request).fetch(id, variables);
  }
  /**
   * Kicks off an Asana import job.
   *
   * @param asanaTeamName - required asanaTeamName to pass to issueImportCreateAsana
   * @param asanaToken - required asanaToken to pass to issueImportCreateAsana
   * @param variables - variables without 'asanaTeamName', 'asanaToken' to pass into the IssueImportCreateAsanaMutation
   * @returns IssueImportPayload
   */
  public issueImportCreateAsana(
    asanaTeamName: string,
    asanaToken: string,
    variables?: Omit<L.IssueImportCreateAsanaMutationVariables, "asanaTeamName" | "asanaToken">
  ): LinearFetch<IssueImportPayload> {
    return new IssueImportCreateAsanaMutation(this._request).fetch(asanaTeamName, asanaToken, variables);
  }
  /**
   * Kicks off a Jira import job from a CSV.
   *
   * @param csvUrl - required csvUrl to pass to issueImportCreateCSVJira
   * @param variables - variables without 'csvUrl' to pass into the IssueImportCreateCsvJiraMutation
   * @returns IssueImportPayload
   */
  public issueImportCreateCSVJira(
    csvUrl: string,
    variables?: Omit<L.IssueImportCreateCsvJiraMutationVariables, "csvUrl">
  ): LinearFetch<IssueImportPayload> {
    return new IssueImportCreateCsvJiraMutation(this._request).fetch(csvUrl, variables);
  }
  /**
   * Kicks off a Shortcut (formerly Clubhouse) import job.
   *
   * @param clubhouseGroupName - required clubhouseGroupName to pass to issueImportCreateClubhouse
   * @param clubhouseToken - required clubhouseToken to pass to issueImportCreateClubhouse
   * @param variables - variables without 'clubhouseGroupName', 'clubhouseToken' to pass into the IssueImportCreateClubhouseMutation
   * @returns IssueImportPayload
   */
  public issueImportCreateClubhouse(
    clubhouseGroupName: string,
    clubhouseToken: string,
    variables?: Omit<L.IssueImportCreateClubhouseMutationVariables, "clubhouseGroupName" | "clubhouseToken">
  ): LinearFetch<IssueImportPayload> {
    return new IssueImportCreateClubhouseMutation(this._request).fetch(clubhouseGroupName, clubhouseToken, variables);
  }
  /**
   * Kicks off a GitHub import job.
   *
   * @param variables - variables to pass into the IssueImportCreateGithubMutation
   * @returns IssueImportPayload
   */
  public issueImportCreateGithub(
    variables?: L.IssueImportCreateGithubMutationVariables
  ): LinearFetch<IssueImportPayload> {
    return new IssueImportCreateGithubMutation(this._request).fetch(variables);
  }
  /**
   * Kicks off a Jira import job.
   *
   * @param jiraEmail - required jiraEmail to pass to issueImportCreateJira
   * @param jiraHostname - required jiraHostname to pass to issueImportCreateJira
   * @param jiraProject - required jiraProject to pass to issueImportCreateJira
   * @param jiraToken - required jiraToken to pass to issueImportCreateJira
   * @param variables - variables without 'jiraEmail', 'jiraHostname', 'jiraProject', 'jiraToken' to pass into the IssueImportCreateJiraMutation
   * @returns IssueImportPayload
   */
  public issueImportCreateJira(
    jiraEmail: string,
    jiraHostname: string,
    jiraProject: string,
    jiraToken: string,
    variables?: Omit<
      L.IssueImportCreateJiraMutationVariables,
      "jiraEmail" | "jiraHostname" | "jiraProject" | "jiraToken"
    >
  ): LinearFetch<IssueImportPayload> {
    return new IssueImportCreateJiraMutation(this._request).fetch(
      jiraEmail,
      jiraHostname,
      jiraProject,
      jiraToken,
      variables
    );
  }
  /**
   * Deletes an import job.
   *
   * @param issueImportId - required issueImportId to pass to deleteIssueImport
   * @returns IssueImportDeletePayload
   */
  public deleteIssueImport(issueImportId: string): LinearFetch<IssueImportDeletePayload> {
    return new DeleteIssueImportMutation(this._request).fetch(issueImportId);
  }
  /**
   * Kicks off import processing.
   *
   * @param issueImportId - required issueImportId to pass to issueImportProcess
   * @param mapping - required mapping to pass to issueImportProcess
   * @returns IssueImportPayload
   */
  public issueImportProcess(issueImportId: string, mapping: L.Scalars["JSONObject"]): LinearFetch<IssueImportPayload> {
    return new IssueImportProcessMutation(this._request).fetch(issueImportId, mapping);
  }
  /**
   * Updates the mapping for the issue import.
   *
   * @param id - required id to pass to updateIssueImport
   * @param input - required input to pass to updateIssueImport
   * @returns IssueImportPayload
   */
  public updateIssueImport(id: string, input: L.IssueImportUpdateInput): LinearFetch<IssueImportPayload> {
    return new UpdateIssueImportMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new label.
   *
   * @param input - required input to pass to createIssueLabel
   * @param variables - variables without 'input' to pass into the CreateIssueLabelMutation
   * @returns IssueLabelPayload
   */
  public createIssueLabel(
    input: L.IssueLabelCreateInput,
    variables?: Omit<L.CreateIssueLabelMutationVariables, "input">
  ): LinearFetch<IssueLabelPayload> {
    return new CreateIssueLabelMutation(this._request).fetch(input, variables);
  }
  /**
   * Deletes an issue label.
   *
   * @param id - required id to pass to deleteIssueLabel
   * @returns DeletePayload
   */
  public deleteIssueLabel(id: string): LinearFetch<DeletePayload> {
    return new DeleteIssueLabelMutation(this._request).fetch(id);
  }
  /**
   * Updates an label.
   *
   * @param id - required id to pass to updateIssueLabel
   * @param input - required input to pass to updateIssueLabel
   * @param variables - variables without 'id', 'input' to pass into the UpdateIssueLabelMutation
   * @returns IssueLabelPayload
   */
  public updateIssueLabel(
    id: string,
    input: L.IssueLabelUpdateInput,
    variables?: Omit<L.UpdateIssueLabelMutationVariables, "id" | "input">
  ): LinearFetch<IssueLabelPayload> {
    return new UpdateIssueLabelMutation(this._request).fetch(id, input, variables);
  }
  /**
   * Creates a new issue relation.
   *
   * @param input - required input to pass to createIssueRelation
   * @param variables - variables without 'input' to pass into the CreateIssueRelationMutation
   * @returns IssueRelationPayload
   */
  public createIssueRelation(
    input: L.IssueRelationCreateInput,
    variables?: Omit<L.CreateIssueRelationMutationVariables, "input">
  ): LinearFetch<IssueRelationPayload> {
    return new CreateIssueRelationMutation(this._request).fetch(input, variables);
  }
  /**
   * Deletes an issue relation.
   *
   * @param id - required id to pass to deleteIssueRelation
   * @returns DeletePayload
   */
  public deleteIssueRelation(id: string): LinearFetch<DeletePayload> {
    return new DeleteIssueRelationMutation(this._request).fetch(id);
  }
  /**
   * Updates an issue relation.
   *
   * @param id - required id to pass to updateIssueRelation
   * @param input - required input to pass to updateIssueRelation
   * @returns IssueRelationPayload
   */
  public updateIssueRelation(id: string, input: L.IssueRelationUpdateInput): LinearFetch<IssueRelationPayload> {
    return new UpdateIssueRelationMutation(this._request).fetch(id, input);
  }
  /**
   * Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is reached.
   *
   * @param id - required id to pass to issueReminder
   * @param reminderAt - required reminderAt to pass to issueReminder
   * @returns IssuePayload
   */
  public issueReminder(id: string, reminderAt: Date): LinearFetch<IssuePayload> {
    return new IssueReminderMutation(this._request).fetch(id, reminderAt);
  }
  /**
   * Removes a label from an issue.
   *
   * @param id - required id to pass to issueRemoveLabel
   * @param labelId - required labelId to pass to issueRemoveLabel
   * @returns IssuePayload
   */
  public issueRemoveLabel(id: string, labelId: string): LinearFetch<IssuePayload> {
    return new IssueRemoveLabelMutation(this._request).fetch(id, labelId);
  }
  /**
   * Subscribes a user to an issue.
   *
   * @param id - required id to pass to issueSubscribe
   * @param variables - variables without 'id' to pass into the IssueSubscribeMutation
   * @returns IssuePayload
   */
  public issueSubscribe(
    id: string,
    variables?: Omit<L.IssueSubscribeMutationVariables, "id">
  ): LinearFetch<IssuePayload> {
    return new IssueSubscribeMutation(this._request).fetch(id, variables);
  }
  /**
   * Unarchives an issue.
   *
   * @param id - required id to pass to unarchiveIssue
   * @returns IssueArchivePayload
   */
  public unarchiveIssue(id: string): LinearFetch<IssueArchivePayload> {
    return new UnarchiveIssueMutation(this._request).fetch(id);
  }
  /**
   * Unsubscribes a user from an issue.
   *
   * @param id - required id to pass to issueUnsubscribe
   * @param variables - variables without 'id' to pass into the IssueUnsubscribeMutation
   * @returns IssuePayload
   */
  public issueUnsubscribe(
    id: string,
    variables?: Omit<L.IssueUnsubscribeMutationVariables, "id">
  ): LinearFetch<IssuePayload> {
    return new IssueUnsubscribeMutation(this._request).fetch(id, variables);
  }
  /**
   * Updates an issue.
   *
   * @param id - required id to pass to updateIssue
   * @param input - required input to pass to updateIssue
   * @returns IssuePayload
   */
  public updateIssue(id: string, input: L.IssueUpdateInput): LinearFetch<IssuePayload> {
    return new UpdateIssueMutation(this._request).fetch(id, input);
  }
  /**
   * Join an organization from onboarding.
   *
   * @param input - required input to pass to joinOrganizationFromOnboarding
   * @returns CreateOrJoinOrganizationResponse
   */
  public joinOrganizationFromOnboarding(input: L.JoinOrganizationInput): LinearFetch<CreateOrJoinOrganizationResponse> {
    return new JoinOrganizationFromOnboardingMutation(this._request).fetch(input);
  }
  /**
   * Leave an organization.
   *
   * @param organizationId - required organizationId to pass to leaveOrganization
   * @returns CreateOrJoinOrganizationResponse
   */
  public leaveOrganization(organizationId: string): LinearFetch<CreateOrJoinOrganizationResponse> {
    return new LeaveOrganizationMutation(this._request).fetch(organizationId);
  }
  /**
   * Logout the client.
   *
   * @param variables - variables to pass into the LogoutMutation
   * @returns LogoutResponse
   */
  public logout(variables?: L.LogoutMutationVariables): LinearFetch<LogoutResponse> {
    return new LogoutMutation(this._request).fetch(variables);
  }
  /**
   * Logout all of user's sessions including the active one.
   *
   * @param variables - variables to pass into the LogoutAllSessionsMutation
   * @returns LogoutResponse
   */
  public logoutAllSessions(variables?: L.LogoutAllSessionsMutationVariables): LinearFetch<LogoutResponse> {
    return new LogoutAllSessionsMutation(this._request).fetch(variables);
  }
  /**
   * Logout all of user's sessions excluding the current one.
   *
   * @param variables - variables to pass into the LogoutOtherSessionsMutation
   * @returns LogoutResponse
   */
  public logoutOtherSessions(variables?: L.LogoutOtherSessionsMutationVariables): LinearFetch<LogoutResponse> {
    return new LogoutOtherSessionsMutation(this._request).fetch(variables);
  }
  /**
   * Logout an individual session with its ID.
   *
   * @param sessionId - required sessionId to pass to logoutSession
   * @returns LogoutResponse
   */
  public logoutSession(sessionId: string): LinearFetch<LogoutResponse> {
    return new LogoutSessionMutation(this._request).fetch(sessionId);
  }
  /**
   * Archives a notification.
   *
   * @param id - required id to pass to archiveNotification
   * @returns NotificationArchivePayload
   */
  public archiveNotification(id: string): LinearFetch<NotificationArchivePayload> {
    return new ArchiveNotificationMutation(this._request).fetch(id);
  }
  /**
   * Archives a notification and all related notifications.
   *
   * @param input - required input to pass to notificationArchiveAll
   * @returns NotificationBatchActionPayload
   */
  public notificationArchiveAll(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload> {
    return new NotificationArchiveAllMutation(this._request).fetch(input);
  }
  /**
   * Subscribes to or unsubscribes from a notification category for a given notification channel for the user
   *
   * @param category - required category to pass to updateNotificationCategoryChannelSubscription
   * @param channel - required channel to pass to updateNotificationCategoryChannelSubscription
   * @param subscribe - required subscribe to pass to updateNotificationCategoryChannelSubscription
   * @returns UserSettingsPayload
   */
  public updateNotificationCategoryChannelSubscription(
    category: L.NotificationCategory,
    channel: L.NotificationChannel,
    subscribe: boolean
  ): LinearFetch<UserSettingsPayload> {
    return new UpdateNotificationCategoryChannelSubscriptionMutation(this._request).fetch(category, channel, subscribe);
  }
  /**
   * Marks notification and all related notifications as read.
   *
   * @param input - required input to pass to notificationMarkReadAll
   * @param readAt - required readAt to pass to notificationMarkReadAll
   * @returns NotificationBatchActionPayload
   */
  public notificationMarkReadAll(
    input: L.NotificationEntityInput,
    readAt: Date
  ): LinearFetch<NotificationBatchActionPayload> {
    return new NotificationMarkReadAllMutation(this._request).fetch(input, readAt);
  }
  /**
   * Marks notification and all related notifications as unread.
   *
   * @param input - required input to pass to notificationMarkUnreadAll
   * @returns NotificationBatchActionPayload
   */
  public notificationMarkUnreadAll(input: L.NotificationEntityInput): LinearFetch<NotificationBatchActionPayload> {
    return new NotificationMarkUnreadAllMutation(this._request).fetch(input);
  }
  /**
   * Snoozes a notification and all related notifications.
   *
   * @param input - required input to pass to notificationSnoozeAll
   * @param snoozedUntilAt - required snoozedUntilAt to pass to notificationSnoozeAll
   * @returns NotificationBatchActionPayload
   */
  public notificationSnoozeAll(
    input: L.NotificationEntityInput,
    snoozedUntilAt: Date
  ): LinearFetch<NotificationBatchActionPayload> {
    return new NotificationSnoozeAllMutation(this._request).fetch(input, snoozedUntilAt);
  }
  /**
   * Creates a new notification subscription for a cycle, custom view, label, project or team.
   *
   * @param input - required input to pass to createNotificationSubscription
   * @returns NotificationSubscriptionPayload
   */
  public createNotificationSubscription(
    input: L.NotificationSubscriptionCreateInput
  ): LinearFetch<NotificationSubscriptionPayload> {
    return new CreateNotificationSubscriptionMutation(this._request).fetch(input);
  }
  /**
   * Deletes a notification subscription reference.
   *
   * @param id - required id to pass to deleteNotificationSubscription
   * @returns DeletePayload
   */
  public deleteNotificationSubscription(id: string): LinearFetch<DeletePayload> {
    return new DeleteNotificationSubscriptionMutation(this._request).fetch(id);
  }
  /**
   * Updates a notification subscription.
   *
   * @param id - required id to pass to updateNotificationSubscription
   * @param input - required input to pass to updateNotificationSubscription
   * @returns NotificationSubscriptionPayload
   */
  public updateNotificationSubscription(
    id: string,
    input: L.NotificationSubscriptionUpdateInput
  ): LinearFetch<NotificationSubscriptionPayload> {
    return new UpdateNotificationSubscriptionMutation(this._request).fetch(id, input);
  }
  /**
   * Unarchives a notification.
   *
   * @param id - required id to pass to unarchiveNotification
   * @returns NotificationArchivePayload
   */
  public unarchiveNotification(id: string): LinearFetch<NotificationArchivePayload> {
    return new UnarchiveNotificationMutation(this._request).fetch(id);
  }
  /**
   * Unsnoozes a notification and all related notifications.
   *
   * @param input - required input to pass to notificationUnsnoozeAll
   * @param unsnoozedAt - required unsnoozedAt to pass to notificationUnsnoozeAll
   * @returns NotificationBatchActionPayload
   */
  public notificationUnsnoozeAll(
    input: L.NotificationEntityInput,
    unsnoozedAt: Date
  ): LinearFetch<NotificationBatchActionPayload> {
    return new NotificationUnsnoozeAllMutation(this._request).fetch(input, unsnoozedAt);
  }
  /**
   * Updates a notification.
   *
   * @param id - required id to pass to updateNotification
   * @param input - required input to pass to updateNotification
   * @returns NotificationPayload
   */
  public updateNotification(id: string, input: L.NotificationUpdateInput): LinearFetch<NotificationPayload> {
    return new UpdateNotificationMutation(this._request).fetch(id, input);
  }
  /**
   * Cancels the deletion of an organization. Administrator privileges required.
   *
   * @returns OrganizationCancelDeletePayload
   */
  public get deleteOrganizationCancel(): LinearFetch<OrganizationCancelDeletePayload> {
    return new DeleteOrganizationCancelMutation(this._request).fetch();
  }
  /**
   * Delete's an organization. Administrator privileges required.
   *
   * @param input - required input to pass to deleteOrganization
   * @returns OrganizationDeletePayload
   */
  public deleteOrganization(input: L.DeleteOrganizationInput): LinearFetch<OrganizationDeletePayload> {
    return new DeleteOrganizationMutation(this._request).fetch(input);
  }
  /**
   * Get an organization's delete confirmation token. Administrator privileges required.
   *
   * @returns OrganizationDeletePayload
   */
  public get organizationDeleteChallenge(): LinearFetch<OrganizationDeletePayload> {
    return new OrganizationDeleteChallengeMutation(this._request).fetch();
  }
  /**
   * Deletes a domain.
   *
   * @param id - required id to pass to deleteOrganizationDomain
   * @returns DeletePayload
   */
  public deleteOrganizationDomain(id: string): LinearFetch<DeletePayload> {
    return new DeleteOrganizationDomainMutation(this._request).fetch(id);
  }
  /**
   * Creates a new organization invite.
   *
   * @param input - required input to pass to createOrganizationInvite
   * @returns OrganizationInvitePayload
   */
  public createOrganizationInvite(input: L.OrganizationInviteCreateInput): LinearFetch<OrganizationInvitePayload> {
    return new CreateOrganizationInviteMutation(this._request).fetch(input);
  }
  /**
   * Deletes an organization invite.
   *
   * @param id - required id to pass to deleteOrganizationInvite
   * @returns DeletePayload
   */
  public deleteOrganizationInvite(id: string): LinearFetch<DeletePayload> {
    return new DeleteOrganizationInviteMutation(this._request).fetch(id);
  }
  /**
   * Updates an organization invite.
   *
   * @param id - required id to pass to updateOrganizationInvite
   * @param input - required input to pass to updateOrganizationInvite
   * @returns OrganizationInvitePayload
   */
  public updateOrganizationInvite(
    id: string,
    input: L.OrganizationInviteUpdateInput
  ): LinearFetch<OrganizationInvitePayload> {
    return new UpdateOrganizationInviteMutation(this._request).fetch(id, input);
  }
  /**
   * [DEPRECATED] Starts a trial for the organization. Administrator privileges required.
   *
   * @returns OrganizationStartTrialPayload
   */
  public get organizationStartTrial(): LinearFetch<OrganizationStartTrialPayload> {
    return new OrganizationStartTrialMutation(this._request).fetch();
  }
  /**
   * Starts a trial for the organization on the specified plan type. Administrator privileges required.
   *
   * @param input - required input to pass to organizationStartTrialForPlan
   * @returns OrganizationStartTrialPayload
   */
  public organizationStartTrialForPlan(
    input: L.OrganizationStartTrialInput
  ): LinearFetch<OrganizationStartTrialPayload> {
    return new OrganizationStartTrialForPlanMutation(this._request).fetch(input);
  }
  /**
   * Updates the user's organization.
   *
   * @param input - required input to pass to updateOrganization
   * @returns OrganizationPayload
   */
  public updateOrganization(input: L.OrganizationUpdateInput): LinearFetch<OrganizationPayload> {
    return new UpdateOrganizationMutation(this._request).fetch(input);
  }
  /**
   * Adds a label to a project.
   *
   * @param id - required id to pass to projectAddLabel
   * @param labelId - required labelId to pass to projectAddLabel
   * @returns ProjectPayload
   */
  public projectAddLabel(id: string, labelId: string): LinearFetch<ProjectPayload> {
    return new ProjectAddLabelMutation(this._request).fetch(id, labelId);
  }
  /**
   * Archives a project.
   *
   * @param id - required id to pass to archiveProject
   * @param variables - variables without 'id' to pass into the ArchiveProjectMutation
   * @returns ProjectArchivePayload
   */
  public archiveProject(
    id: string,
    variables?: Omit<L.ArchiveProjectMutationVariables, "id">
  ): LinearFetch<ProjectArchivePayload> {
    return new ArchiveProjectMutation(this._request).fetch(id, variables);
  }
  /**
   * Creates a new project.
   *
   * @param input - required input to pass to createProject
   * @param variables - variables without 'input' to pass into the CreateProjectMutation
   * @returns ProjectPayload
   */
  public createProject(
    input: L.ProjectCreateInput,
    variables?: Omit<L.CreateProjectMutationVariables, "input">
  ): LinearFetch<ProjectPayload> {
    return new CreateProjectMutation(this._request).fetch(input, variables);
  }
  /**
   * Deletes (trashes) a project.
   *
   * @param id - required id to pass to deleteProject
   * @returns ProjectArchivePayload
   */
  public deleteProject(id: string): LinearFetch<ProjectArchivePayload> {
    return new DeleteProjectMutation(this._request).fetch(id);
  }
  /**
   * Creates a new project label.
   *
   * @param input - required input to pass to createProjectLabel
   * @returns ProjectLabelPayload
   */
  public createProjectLabel(input: L.ProjectLabelCreateInput): LinearFetch<ProjectLabelPayload> {
    return new CreateProjectLabelMutation(this._request).fetch(input);
  }
  /**
   * Deletes a project label.
   *
   * @param id - required id to pass to deleteProjectLabel
   * @returns DeletePayload
   */
  public deleteProjectLabel(id: string): LinearFetch<DeletePayload> {
    return new DeleteProjectLabelMutation(this._request).fetch(id);
  }
  /**
   * Updates a project label.
   *
   * @param id - required id to pass to updateProjectLabel
   * @param input - required input to pass to updateProjectLabel
   * @returns ProjectLabelPayload
   */
  public updateProjectLabel(id: string, input: L.ProjectLabelUpdateInput): LinearFetch<ProjectLabelPayload> {
    return new UpdateProjectLabelMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new project milestone.
   *
   * @param input - required input to pass to createProjectMilestone
   * @returns ProjectMilestonePayload
   */
  public createProjectMilestone(input: L.ProjectMilestoneCreateInput): LinearFetch<ProjectMilestonePayload> {
    return new CreateProjectMilestoneMutation(this._request).fetch(input);
  }
  /**
   * Deletes a project milestone.
   *
   * @param id - required id to pass to deleteProjectMilestone
   * @returns DeletePayload
   */
  public deleteProjectMilestone(id: string): LinearFetch<DeletePayload> {
    return new DeleteProjectMilestoneMutation(this._request).fetch(id);
  }
  /**
   * Updates a project milestone.
   *
   * @param id - required id to pass to updateProjectMilestone
   * @param input - required input to pass to updateProjectMilestone
   * @returns ProjectMilestonePayload
   */
  public updateProjectMilestone(
    id: string,
    input: L.ProjectMilestoneUpdateInput
  ): LinearFetch<ProjectMilestonePayload> {
    return new UpdateProjectMilestoneMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new project relation.
   *
   * @param input - required input to pass to createProjectRelation
   * @returns ProjectRelationPayload
   */
  public createProjectRelation(input: L.ProjectRelationCreateInput): LinearFetch<ProjectRelationPayload> {
    return new CreateProjectRelationMutation(this._request).fetch(input);
  }
  /**
   * Deletes a project relation.
   *
   * @param id - required id to pass to deleteProjectRelation
   * @returns DeletePayload
   */
  public deleteProjectRelation(id: string): LinearFetch<DeletePayload> {
    return new DeleteProjectRelationMutation(this._request).fetch(id);
  }
  /**
   * Updates a project relation.
   *
   * @param id - required id to pass to updateProjectRelation
   * @param input - required input to pass to updateProjectRelation
   * @returns ProjectRelationPayload
   */
  public updateProjectRelation(id: string, input: L.ProjectRelationUpdateInput): LinearFetch<ProjectRelationPayload> {
    return new UpdateProjectRelationMutation(this._request).fetch(id, input);
  }
  /**
   * Removes a label from a project.
   *
   * @param id - required id to pass to projectRemoveLabel
   * @param labelId - required labelId to pass to projectRemoveLabel
   * @returns ProjectPayload
   */
  public projectRemoveLabel(id: string, labelId: string): LinearFetch<ProjectPayload> {
    return new ProjectRemoveLabelMutation(this._request).fetch(id, labelId);
  }
  /**
   * Archives a project status.
   *
   * @param id - required id to pass to archiveProjectStatus
   * @returns ProjectStatusArchivePayload
   */
  public archiveProjectStatus(id: string): LinearFetch<ProjectStatusArchivePayload> {
    return new ArchiveProjectStatusMutation(this._request).fetch(id);
  }
  /**
   * Creates a new project status.
   *
   * @param input - required input to pass to createProjectStatus
   * @returns ProjectStatusPayload
   */
  public createProjectStatus(input: L.ProjectStatusCreateInput): LinearFetch<ProjectStatusPayload> {
    return new CreateProjectStatusMutation(this._request).fetch(input);
  }
  /**
   * Unarchives a project status.
   *
   * @param id - required id to pass to unarchiveProjectStatus
   * @returns ProjectStatusArchivePayload
   */
  public unarchiveProjectStatus(id: string): LinearFetch<ProjectStatusArchivePayload> {
    return new UnarchiveProjectStatusMutation(this._request).fetch(id);
  }
  /**
   * Updates a project status.
   *
   * @param id - required id to pass to updateProjectStatus
   * @param input - required input to pass to updateProjectStatus
   * @returns ProjectStatusPayload
   */
  public updateProjectStatus(id: string, input: L.ProjectStatusUpdateInput): LinearFetch<ProjectStatusPayload> {
    return new UpdateProjectStatusMutation(this._request).fetch(id, input);
  }
  /**
   * Unarchives a project.
   *
   * @param id - required id to pass to unarchiveProject
   * @returns ProjectArchivePayload
   */
  public unarchiveProject(id: string): LinearFetch<ProjectArchivePayload> {
    return new UnarchiveProjectMutation(this._request).fetch(id);
  }
  /**
   * Updates a project.
   *
   * @param id - required id to pass to updateProject
   * @param input - required input to pass to updateProject
   * @returns ProjectPayload
   */
  public updateProject(id: string, input: L.ProjectUpdateInput): LinearFetch<ProjectPayload> {
    return new UpdateProjectMutation(this._request).fetch(id, input);
  }
  /**
   * Archives a project update.
   *
   * @param id - required id to pass to archiveProjectUpdate
   * @returns ProjectUpdateArchivePayload
   */
  public archiveProjectUpdate(id: string): LinearFetch<ProjectUpdateArchivePayload> {
    return new ArchiveProjectUpdateMutation(this._request).fetch(id);
  }
  /**
   * Creates a new project update.
   *
   * @param input - required input to pass to createProjectUpdate
   * @returns ProjectUpdatePayload
   */
  public createProjectUpdate(input: L.ProjectUpdateCreateInput): LinearFetch<ProjectUpdatePayload> {
    return new CreateProjectUpdateMutation(this._request).fetch(input);
  }
  /**
   * Deletes a project update.
   *
   * @param id - required id to pass to deleteProjectUpdate
   * @returns DeletePayload
   */
  public deleteProjectUpdate(id: string): LinearFetch<DeletePayload> {
    return new DeleteProjectUpdateMutation(this._request).fetch(id);
  }
  /**
   * Unarchives a project update.
   *
   * @param id - required id to pass to unarchiveProjectUpdate
   * @returns ProjectUpdateArchivePayload
   */
  public unarchiveProjectUpdate(id: string): LinearFetch<ProjectUpdateArchivePayload> {
    return new UnarchiveProjectUpdateMutation(this._request).fetch(id);
  }
  /**
   * Updates a project update.
   *
   * @param id - required id to pass to updateProjectUpdate
   * @param input - required input to pass to updateProjectUpdate
   * @returns ProjectUpdatePayload
   */
  public updateProjectUpdate(id: string, input: L.ProjectUpdateUpdateInput): LinearFetch<ProjectUpdatePayload> {
    return new UpdateProjectUpdateMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a push subscription.
   *
   * @param input - required input to pass to createPushSubscription
   * @returns PushSubscriptionPayload
   */
  public createPushSubscription(input: L.PushSubscriptionCreateInput): LinearFetch<PushSubscriptionPayload> {
    return new CreatePushSubscriptionMutation(this._request).fetch(input);
  }
  /**
   * Deletes a push subscription.
   *
   * @param id - required id to pass to deletePushSubscription
   * @returns PushSubscriptionPayload
   */
  public deletePushSubscription(id: string): LinearFetch<PushSubscriptionPayload> {
    return new DeletePushSubscriptionMutation(this._request).fetch(id);
  }
  /**
   * Creates a new reaction.
   *
   * @param input - required input to pass to createReaction
   * @returns ReactionPayload
   */
  public createReaction(input: L.ReactionCreateInput): LinearFetch<ReactionPayload> {
    return new CreateReactionMutation(this._request).fetch(input);
  }
  /**
   * Deletes a reaction.
   *
   * @param id - required id to pass to deleteReaction
   * @returns DeletePayload
   */
  public deleteReaction(id: string): LinearFetch<DeletePayload> {
    return new DeleteReactionMutation(this._request).fetch(id);
  }
  /**
   * Manually update Google Sheets data.
   *
   * @param id - required id to pass to refreshGoogleSheetsData
   * @param variables - variables without 'id' to pass into the RefreshGoogleSheetsDataMutation
   * @returns IntegrationPayload
   */
  public refreshGoogleSheetsData(
    id: string,
    variables?: Omit<L.RefreshGoogleSheetsDataMutationVariables, "id">
  ): LinearFetch<IntegrationPayload> {
    return new RefreshGoogleSheetsDataMutation(this._request).fetch(id, variables);
  }
  /**
   * Re-send an organization invite.
   *
   * @param id - required id to pass to resendOrganizationInvite
   * @returns DeletePayload
   */
  public resendOrganizationInvite(id: string): LinearFetch<DeletePayload> {
    return new ResendOrganizationInviteMutation(this._request).fetch(id);
  }
  /**
   * Re-send an organization invite tied to an email address.
   *
   * @param email - required email to pass to resendOrganizationInviteByEmail
   * @returns DeletePayload
   */
  public resendOrganizationInviteByEmail(email: string): LinearFetch<DeletePayload> {
    return new ResendOrganizationInviteByEmailMutation(this._request).fetch(email);
  }
  /**
   * Archives a roadmap.
   *
   * @param id - required id to pass to archiveRoadmap
   * @returns RoadmapArchivePayload
   */
  public archiveRoadmap(id: string): LinearFetch<RoadmapArchivePayload> {
    return new ArchiveRoadmapMutation(this._request).fetch(id);
  }
  /**
   * Creates a new roadmap.
   *
   * @param input - required input to pass to createRoadmap
   * @returns RoadmapPayload
   */
  public createRoadmap(input: L.RoadmapCreateInput): LinearFetch<RoadmapPayload> {
    return new CreateRoadmapMutation(this._request).fetch(input);
  }
  /**
   * Deletes a roadmap.
   *
   * @param id - required id to pass to deleteRoadmap
   * @returns DeletePayload
   */
  public deleteRoadmap(id: string): LinearFetch<DeletePayload> {
    return new DeleteRoadmapMutation(this._request).fetch(id);
  }
  /**
   * Creates a new roadmapToProject join.
   *
   * @param input - required input to pass to createRoadmapToProject
   * @returns RoadmapToProjectPayload
   */
  public createRoadmapToProject(input: L.RoadmapToProjectCreateInput): LinearFetch<RoadmapToProjectPayload> {
    return new CreateRoadmapToProjectMutation(this._request).fetch(input);
  }
  /**
   * Deletes a roadmapToProject.
   *
   * @param id - required id to pass to deleteRoadmapToProject
   * @returns DeletePayload
   */
  public deleteRoadmapToProject(id: string): LinearFetch<DeletePayload> {
    return new DeleteRoadmapToProjectMutation(this._request).fetch(id);
  }
  /**
   * Updates a roadmapToProject.
   *
   * @param id - required id to pass to updateRoadmapToProject
   * @param input - required input to pass to updateRoadmapToProject
   * @returns RoadmapToProjectPayload
   */
  public updateRoadmapToProject(
    id: string,
    input: L.RoadmapToProjectUpdateInput
  ): LinearFetch<RoadmapToProjectPayload> {
    return new UpdateRoadmapToProjectMutation(this._request).fetch(id, input);
  }
  /**
   * Unarchives a roadmap.
   *
   * @param id - required id to pass to unarchiveRoadmap
   * @returns RoadmapArchivePayload
   */
  public unarchiveRoadmap(id: string): LinearFetch<RoadmapArchivePayload> {
    return new UnarchiveRoadmapMutation(this._request).fetch(id);
  }
  /**
   * Updates a roadmap.
   *
   * @param id - required id to pass to updateRoadmap
   * @param input - required input to pass to updateRoadmap
   * @returns RoadmapPayload
   */
  public updateRoadmap(id: string, input: L.RoadmapUpdateInput): LinearFetch<RoadmapPayload> {
    return new UpdateRoadmapMutation(this._request).fetch(id, input);
  }
  /**
   * Authenticates a user account via email and authentication token for SAML.
   *
   * @param input - required input to pass to samlTokenUserAccountAuth
   * @returns AuthResolverResponse
   */
  public samlTokenUserAccountAuth(input: L.TokenUserAccountAuthInput): LinearFetch<AuthResolverResponse> {
    return new SamlTokenUserAccountAuthMutation(this._request).fetch(input);
  }
  /**
   * Creates a new team. The user who creates the team will automatically be added as a member to the newly created team.
   *
   * @param input - required input to pass to createTeam
   * @param variables - variables without 'input' to pass into the CreateTeamMutation
   * @returns TeamPayload
   */
  public createTeam(
    input: L.TeamCreateInput,
    variables?: Omit<L.CreateTeamMutationVariables, "input">
  ): LinearFetch<TeamPayload> {
    return new CreateTeamMutation(this._request).fetch(input, variables);
  }
  /**
   * Deletes team's cycles data
   *
   * @param id - required id to pass to deleteTeamCycles
   * @returns TeamPayload
   */
  public deleteTeamCycles(id: string): LinearFetch<TeamPayload> {
    return new DeleteTeamCyclesMutation(this._request).fetch(id);
  }
  /**
   * Deletes a team.
   *
   * @param id - required id to pass to deleteTeam
   * @returns DeletePayload
   */
  public deleteTeam(id: string): LinearFetch<DeletePayload> {
    return new DeleteTeamMutation(this._request).fetch(id);
  }
  /**
   * Deletes a previously used team key.
   *
   * @param id - required id to pass to deleteTeamKey
   * @returns DeletePayload
   */
  public deleteTeamKey(id: string): LinearFetch<DeletePayload> {
    return new DeleteTeamKeyMutation(this._request).fetch(id);
  }
  /**
   * Creates a new team membership.
   *
   * @param input - required input to pass to createTeamMembership
   * @returns TeamMembershipPayload
   */
  public createTeamMembership(input: L.TeamMembershipCreateInput): LinearFetch<TeamMembershipPayload> {
    return new CreateTeamMembershipMutation(this._request).fetch(input);
  }
  /**
   * Deletes a team membership.
   *
   * @param id - required id to pass to deleteTeamMembership
   * @param variables - variables without 'id' to pass into the DeleteTeamMembershipMutation
   * @returns DeletePayload
   */
  public deleteTeamMembership(
    id: string,
    variables?: Omit<L.DeleteTeamMembershipMutationVariables, "id">
  ): LinearFetch<DeletePayload> {
    return new DeleteTeamMembershipMutation(this._request).fetch(id, variables);
  }
  /**
   * Updates a team membership.
   *
   * @param id - required id to pass to updateTeamMembership
   * @param input - required input to pass to updateTeamMembership
   * @returns TeamMembershipPayload
   */
  public updateTeamMembership(id: string, input: L.TeamMembershipUpdateInput): LinearFetch<TeamMembershipPayload> {
    return new UpdateTeamMembershipMutation(this._request).fetch(id, input);
  }
  /**
   * Unarchives a team and cancels deletion.
   *
   * @param id - required id to pass to unarchiveTeam
   * @returns TeamArchivePayload
   */
  public unarchiveTeam(id: string): LinearFetch<TeamArchivePayload> {
    return new UnarchiveTeamMutation(this._request).fetch(id);
  }
  /**
   * Updates a team.
   *
   * @param id - required id to pass to updateTeam
   * @param input - required input to pass to updateTeam
   * @param variables - variables without 'id', 'input' to pass into the UpdateTeamMutation
   * @returns TeamPayload
   */
  public updateTeam(
    id: string,
    input: L.TeamUpdateInput,
    variables?: Omit<L.UpdateTeamMutationVariables, "id" | "input">
  ): LinearFetch<TeamPayload> {
    return new UpdateTeamMutation(this._request).fetch(id, input, variables);
  }
  /**
   * Creates a new template.
   *
   * @param input - required input to pass to createTemplate
   * @returns TemplatePayload
   */
  public createTemplate(input: L.TemplateCreateInput): LinearFetch<TemplatePayload> {
    return new CreateTemplateMutation(this._request).fetch(input);
  }
  /**
   * Deletes a template.
   *
   * @param id - required id to pass to deleteTemplate
   * @returns DeletePayload
   */
  public deleteTemplate(id: string): LinearFetch<DeletePayload> {
    return new DeleteTemplateMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing template.
   *
   * @param id - required id to pass to updateTemplate
   * @param input - required input to pass to updateTemplate
   * @returns TemplatePayload
   */
  public updateTemplate(id: string, input: L.TemplateUpdateInput): LinearFetch<TemplatePayload> {
    return new UpdateTemplateMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new time schedule.
   *
   * @param input - required input to pass to createTimeSchedule
   * @returns TimeSchedulePayload
   */
  public createTimeSchedule(input: L.TimeScheduleCreateInput): LinearFetch<TimeSchedulePayload> {
    return new CreateTimeScheduleMutation(this._request).fetch(input);
  }
  /**
   * Deletes a time schedule.
   *
   * @param id - required id to pass to deleteTimeSchedule
   * @returns DeletePayload
   */
  public deleteTimeSchedule(id: string): LinearFetch<DeletePayload> {
    return new DeleteTimeScheduleMutation(this._request).fetch(id);
  }
  /**
   * Refresh the integration schedule information.
   *
   * @param id - required id to pass to timeScheduleRefreshIntegrationSchedule
   * @returns TimeSchedulePayload
   */
  public timeScheduleRefreshIntegrationSchedule(id: string): LinearFetch<TimeSchedulePayload> {
    return new TimeScheduleRefreshIntegrationScheduleMutation(this._request).fetch(id);
  }
  /**
   * Updates a time schedule.
   *
   * @param id - required id to pass to updateTimeSchedule
   * @param input - required input to pass to updateTimeSchedule
   * @returns TimeSchedulePayload
   */
  public updateTimeSchedule(id: string, input: L.TimeScheduleUpdateInput): LinearFetch<TimeSchedulePayload> {
    return new UpdateTimeScheduleMutation(this._request).fetch(id, input);
  }
  /**
   * Upsert an external time schedule.
   *
   * @param externalId - required externalId to pass to timeScheduleUpsertExternal
   * @param input - required input to pass to timeScheduleUpsertExternal
   * @returns TimeSchedulePayload
   */
  public timeScheduleUpsertExternal(
    externalId: string,
    input: L.TimeScheduleUpdateInput
  ): LinearFetch<TimeSchedulePayload> {
    return new TimeScheduleUpsertExternalMutation(this._request).fetch(externalId, input);
  }
  /**
   * Creates a new triage responsibility.
   *
   * @param input - required input to pass to createTriageResponsibility
   * @returns TriageResponsibilityPayload
   */
  public createTriageResponsibility(
    input: L.TriageResponsibilityCreateInput
  ): LinearFetch<TriageResponsibilityPayload> {
    return new CreateTriageResponsibilityMutation(this._request).fetch(input);
  }
  /**
   * Deletes a triage responsibility.
   *
   * @param id - required id to pass to deleteTriageResponsibility
   * @returns DeletePayload
   */
  public deleteTriageResponsibility(id: string): LinearFetch<DeletePayload> {
    return new DeleteTriageResponsibilityMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing triage responsibility.
   *
   * @param id - required id to pass to updateTriageResponsibility
   * @param input - required input to pass to updateTriageResponsibility
   * @returns TriageResponsibilityPayload
   */
  public updateTriageResponsibility(
    id: string,
    input: L.TriageResponsibilityUpdateInput
  ): LinearFetch<TriageResponsibilityPayload> {
    return new UpdateTriageResponsibilityMutation(this._request).fetch(id, input);
  }
  /**
   * Makes user a regular user. Can only be called by an admin.
   *
   * @param id - required id to pass to userDemoteAdmin
   * @returns UserAdminPayload
   */
  public userDemoteAdmin(id: string): LinearFetch<UserAdminPayload> {
    return new UserDemoteAdminMutation(this._request).fetch(id);
  }
  /**
   * Makes user a guest. Can only be called by an admin.
   *
   * @param id - required id to pass to userDemoteMember
   * @returns UserAdminPayload
   */
  public userDemoteMember(id: string): LinearFetch<UserAdminPayload> {
    return new UserDemoteMemberMutation(this._request).fetch(id);
  }
  /**
   * Connects the Discord user to this Linear account via OAuth2.
   *
   * @param code - required code to pass to userDiscordConnect
   * @param redirectUri - required redirectUri to pass to userDiscordConnect
   * @returns UserPayload
   */
  public userDiscordConnect(code: string, redirectUri: string): LinearFetch<UserPayload> {
    return new UserDiscordConnectMutation(this._request).fetch(code, redirectUri);
  }
  /**
   * Disconnects the external user from this Linear account.
   *
   * @param service - required service to pass to userExternalUserDisconnect
   * @returns UserPayload
   */
  public userExternalUserDisconnect(service: string): LinearFetch<UserPayload> {
    return new UserExternalUserDisconnectMutation(this._request).fetch(service);
  }
  /**
   * Updates a user's settings flag.
   *
   * @param flag - required flag to pass to updateUserFlag
   * @param operation - required operation to pass to updateUserFlag
   * @returns UserSettingsFlagPayload
   */
  public updateUserFlag(
    flag: L.UserFlagType,
    operation: L.UserFlagUpdateOperation
  ): LinearFetch<UserSettingsFlagPayload> {
    return new UpdateUserFlagMutation(this._request).fetch(flag, operation);
  }
  /**
   * Makes user an admin. Can only be called by an admin.
   *
   * @param id - required id to pass to userPromoteAdmin
   * @returns UserAdminPayload
   */
  public userPromoteAdmin(id: string): LinearFetch<UserAdminPayload> {
    return new UserPromoteAdminMutation(this._request).fetch(id);
  }
  /**
   * Makes user a regular user. Can only be called by an admin.
   *
   * @param id - required id to pass to userPromoteMember
   * @returns UserAdminPayload
   */
  public userPromoteMember(id: string): LinearFetch<UserAdminPayload> {
    return new UserPromoteMemberMutation(this._request).fetch(id);
  }
  /**
   * Resets user's setting flags.
   *
   * @param variables - variables to pass into the UserSettingsFlagsResetMutation
   * @returns UserSettingsFlagsResetPayload
   */
  public userSettingsFlagsReset(
    variables?: L.UserSettingsFlagsResetMutationVariables
  ): LinearFetch<UserSettingsFlagsResetPayload> {
    return new UserSettingsFlagsResetMutation(this._request).fetch(variables);
  }
  /**
   * Updates the user's settings.
   *
   * @param id - required id to pass to updateUserSettings
   * @param input - required input to pass to updateUserSettings
   * @returns UserSettingsPayload
   */
  public updateUserSettings(id: string, input: L.UserSettingsUpdateInput): LinearFetch<UserSettingsPayload> {
    return new UpdateUserSettingsMutation(this._request).fetch(id, input);
  }
  /**
   * Suspends a user. Can only be called by an admin.
   *
   * @param id - required id to pass to suspendUser
   * @returns UserAdminPayload
   */
  public suspendUser(id: string): LinearFetch<UserAdminPayload> {
    return new SuspendUserMutation(this._request).fetch(id);
  }
  /**
   * Un-suspends a user. Can only be called by an admin.
   *
   * @param id - required id to pass to unsuspendUser
   * @returns UserAdminPayload
   */
  public unsuspendUser(id: string): LinearFetch<UserAdminPayload> {
    return new UnsuspendUserMutation(this._request).fetch(id);
  }
  /**
   * Updates a user. Only available to organization admins and the user themselves.
   *
   * @param id - required id to pass to updateUser
   * @param input - required input to pass to updateUser
   * @returns UserPayload
   */
  public updateUser(id: string, input: L.UserUpdateInput): LinearFetch<UserPayload> {
    return new UpdateUserMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new ViewPreferences object.
   *
   * @param input - required input to pass to createViewPreferences
   * @returns ViewPreferencesPayload
   */
  public createViewPreferences(input: L.ViewPreferencesCreateInput): LinearFetch<ViewPreferencesPayload> {
    return new CreateViewPreferencesMutation(this._request).fetch(input);
  }
  /**
   * Deletes a ViewPreferences.
   *
   * @param id - required id to pass to deleteViewPreferences
   * @returns DeletePayload
   */
  public deleteViewPreferences(id: string): LinearFetch<DeletePayload> {
    return new DeleteViewPreferencesMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing ViewPreferences object.
   *
   * @param id - required id to pass to updateViewPreferences
   * @param input - required input to pass to updateViewPreferences
   * @returns ViewPreferencesPayload
   */
  public updateViewPreferences(id: string, input: L.ViewPreferencesUpdateInput): LinearFetch<ViewPreferencesPayload> {
    return new UpdateViewPreferencesMutation(this._request).fetch(id, input);
  }
  /**
   * Creates a new webhook.
   *
   * @param input - required input to pass to createWebhook
   * @returns WebhookPayload
   */
  public createWebhook(input: L.WebhookCreateInput): LinearFetch<WebhookPayload> {
    return new CreateWebhookMutation(this._request).fetch(input);
  }
  /**
   * Deletes a Webhook.
   *
   * @param id - required id to pass to deleteWebhook
   * @returns DeletePayload
   */
  public deleteWebhook(id: string): LinearFetch<DeletePayload> {
    return new DeleteWebhookMutation(this._request).fetch(id);
  }
  /**
   * Updates an existing Webhook.
   *
   * @param id - required id to pass to updateWebhook
   * @param input - required input to pass to updateWebhook
   * @returns WebhookPayload
   */
  public updateWebhook(id: string, input: L.WebhookUpdateInput): LinearFetch<WebhookPayload> {
    return new UpdateWebhookMutation(this._request).fetch(id, input);
  }
  /**
   * Archives a state. Only states with issues that have all been archived can be archived.
   *
   * @param id - required id to pass to archiveWorkflowState
   * @returns WorkflowStateArchivePayload
   */
  public archiveWorkflowState(id: string): LinearFetch<WorkflowStateArchivePayload> {
    return new ArchiveWorkflowStateMutation(this._request).fetch(id);
  }
  /**
   * Creates a new state, adding it to the workflow of a team.
   *
   * @param input - required input to pass to createWorkflowState
   * @returns WorkflowStatePayload
   */
  public createWorkflowState(input: L.WorkflowStateCreateInput): LinearFetch<WorkflowStatePayload> {
    return new CreateWorkflowStateMutation(this._request).fetch(input);
  }
  /**
   * Updates a state.
   *
   * @param id - required id to pass to updateWorkflowState
   * @param input - required input to pass to updateWorkflowState
   * @returns WorkflowStatePayload
   */
  public updateWorkflowState(id: string, input: L.WorkflowStateUpdateInput): LinearFetch<WorkflowStatePayload> {
    return new UpdateWorkflowStateMutation(this._request).fetch(id, input);
  }
}
