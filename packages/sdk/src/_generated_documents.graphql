# A basic entity.
fragment Entity on Entity {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A comment associated with an issue.
fragment Comment on Comment {
  __typename
  # Comment's URL.
  url
  # Emoji reaction summary, grouped by emoji type
  reactionData
  # The comment content as a Prosemirror document.
  bodyData
  # The comment content in markdown format.
  body
  # The issue that the comment is associated with.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The parent comment under which the current comment is nested.
  parent {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time user edited the comment.
  editedAt
  # The unique identifier of the entity.
  id
  # The user who wrote the comment.
  user {
    id
  }
}

# A custom emoji.
fragment Emoji on Emoji {
  __typename
  # The emoji image URL.
  url
  # The emoji's name.
  name
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The source of the emoji.
  source
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the emoji.
  creator {
    id
  }
}

# A custom view that has been saved by a user.
fragment CustomView on CustomView {
  __typename
  # The color of the icon of the custom view.
  color
  # The description of the custom view.
  description
  # The filter applied to issues in the custom view.
  filterData
  # The filters applied to issues in the custom view.
  filters
  # The icon of the custom view.
  icon
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the custom view.
  name
  # The team associated with the custom view.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the custom view.
  creator {
    id
  }
  # Whether the custom view is shared with everyone in the organization.
  shared
}

# A document for a project.
fragment Document on Document {
  __typename
  # The color of the icon.
  color
  # The document content as JSON.
  contentData
  # The document content in markdown format.
  content
  # The document title.
  title
  # The document's unique URL slug.
  slugId
  # The icon of the document.
  icon
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the document is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the document.
  creator {
    id
  }
  # The user who last updated the document.
  updatedBy {
    id
  }
}

# A milestone for a project.
fragment ProjectMilestone on ProjectMilestone {
  __typename
  # The description of the project milestone.
  description
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the project milestone.
  name
  # The planned completion date of the milestone.
  targetDate
  # The project of the milestone.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A notification sent to a user.
fragment Notification on Notification {
  __typename
  # Notification type
  type
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification. If empty it's Linear itself.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }

  ... on IssueNotification {
    ...IssueNotification
  }

  ... on OauthClientApprovalNotification {
    ...OauthClientApprovalNotification
  }

  ... on ProjectNotification {
    ...ProjectNotification
  }
}

# A personal note for a user
fragment PersonalNote on PersonalNote {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The note content as JSON.
  contentData
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that owns the note.
  user {
    id
  }
}

# A project notification subscription.
fragment ProjectNotificationSubscription on ProjectNotificationSubscription {
  __typename
  # Subscribed team.
  team {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project subscribed to.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the subscription.
  type
  # The unique identifier of the entity.
  id
  # The user associated with notification subscriptions.
  user {
    id
  }
}

# A project related notification
fragment ProjectNotification on ProjectNotification {
  __typename
  # Notification type
  type
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project related to the notification.
  project {
    id
  }
  # The project update related to the notification.
  projectUpdate {
    id
  }
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification. If empty it's Linear itself.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# A project.
fragment Project on Project {
  __typename
  # Project URL.
  url
  # Settings for all integrations associated with that project.
  integrationsSettings {
    id
  }
  # The estimated completion date of the project.
  targetDate
  # The icon of the project.
  icon
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The number of completed estimation points after each week.
  completedScopeHistory
  # The number of completed issues in the project after each week.
  completedIssueCountHistory
  # The number of in progress estimation points after each week.
  inProgressScopeHistory
  # The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  progress
  # The overall scope (total estimate points) of the project.
  scope
  # The project lead.
  lead {
    id
  }
  # The project was created based on this issue.
  convertedFromIssue {
    id
  }
  # The project's color.
  color
  # The project's description.
  description
  # The project's name.
  name
  # The project's unique URL slug.
  slugId
  # The sort order for the project within the organizion.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the project was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the project was moved into canceled state.
  canceledAt
  # The time at which the project was moved into completed state.
  completedAt
  # The time at which the project was moved into started state.
  startedAt
  # The time until which project update reminders are paused.
  projectUpdateRemindersPausedUntilAt
  # The total number of estimation points after each week.
  scopeHistory
  # The total number of issues in the project after each week.
  issueCountHistory
  # The type of the state.
  state
  # The unique identifier of the entity.
  id
  # The user who created the project.
  creator {
    id
  }
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
}

# A reaction associated with a comment or a project update.
fragment Reaction on Reaction {
  __typename
  # Name of the reaction's emoji.
  emoji
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who reacted.
  user {
    id
  }
}

# A record of changes to an issue.
fragment IssueHistory on IssueHistory {
  __typename
  # Changed issue relationships.
  relationChanges {
    ...IssueRelationHistoryPayload
  }
  # ID's of labels that were added.
  addedLabelIds
  # ID's of labels that were removed.
  removedLabelIds
  # The id of linked attachment.
  attachmentId
  # The id of new cycle of the issue.
  toCycleId
  # The id of new parent of the issue.
  toParentId
  # The id of new project created from the issue.
  toConvertedProjectId
  # The id of new project of the issue.
  toProjectId
  # The id of new workflow state of the issue.
  toStateId
  # The id of previous cycle of the issue.
  fromCycleId
  # The id of previous parent of the issue.
  fromParentId
  # The id of previous project of the issue.
  fromProjectId
  # The id of previous workflow state of the issue.
  fromStateId
  # The id of team from which the issue was moved from.
  fromTeamId
  # The id of team to which the issue was moved to.
  toTeamId
  # The id of user from whom the issue was re-assigned from.
  fromAssigneeId
  # The id of user to whom the issue was assigned to.
  toAssigneeId
  # The id of user who made these changes. If null, possibly means that the change made by an integration.
  actorId
  # The import record.
  issueImport {
    ...IssueImport
  }
  # The issue that was changed.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The linked attachment.
  attachment {
    id
  }
  # The new cycle of the issue.
  toCycle {
    id
  }
  # The new parent of the issue.
  toParent {
    id
  }
  # The new project created from the issue.
  toConvertedProject {
    id
  }
  # The new project of the issue.
  toProject {
    id
  }
  # The new workflow state of the issue.
  toState {
    id
  }
  # The previous cycle of the issue.
  fromCycle {
    id
  }
  # The previous parent of the issue.
  fromParent {
    id
  }
  # The previous project of the issue.
  fromProject {
    id
  }
  # The previous workflow state of the issue.
  fromState {
    id
  }
  # The team from which the issue was moved from.
  fromTeam {
    id
  }
  # The team to which the issue was moved to.
  toTeam {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user from whom the issue was re-assigned from.
  fromAssignee {
    id
  }
  # The user to whom the issue was assigned to.
  toAssignee {
    id
  }
  # The user who made these changes. If null, possibly means that the change made by an integration.
  actor {
    id
  }
  # What the due date was changed from
  fromDueDate
  # What the due date was changed to
  toDueDate
  # What the estimate was changed from.
  fromEstimate
  # What the estimate was changed to.
  toEstimate
  # What the priority was changed from.
  fromPriority
  # What the priority was changed to.
  toPriority
  # What the title was changed from.
  fromTitle
  # What the title was changed to.
  toTitle
  # Whether the issue was archived or un-archived.
  archived
  # Whether the issue was auto-archived.
  autoArchived
  # Whether the issue was auto-closed.
  autoClosed
  # Whether the issue was trashed or un-trashed.
  trashed
  # Whether the issue's description was updated.
  updatedDescription
}

# A relation between two issues.
fragment IssueRelation on IssueRelation {
  __typename
  # The issue whose relationship is being described.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The related issue.
  relatedIssue {
    id
  }
  # The relationship of the issue with the related issue.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A roadmap for projects.
fragment Roadmap on Roadmap {
  __typename
  # The description of the roadmap.
  description
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the roadmap.
  name
  # The roadmap's unique URL slug.
  slugId
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the roadmap.
  creator {
    id
  }
  # The user who owns the roadmap.
  owner {
    id
  }
}

# A set of issues to be resolved in a specified amount of time.
fragment Cycle on Cycle {
  __typename
  # The completion time of the cycle. If null, the cycle hasn't been completed.
  completedAt
  # The custom name of the cycle.
  name
  # The cycle's description.
  description
  # The end time of the cycle.
  endsAt
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The number of completed estimation points after each day.
  completedScopeHistory
  # The number of completed issues in the cycle after each day.
  completedIssueCountHistory
  # The number of in progress estimation points after each day.
  inProgressScopeHistory
  # The number of the cycle.
  number
  # The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  progress
  # The start time of the cycle.
  startsAt
  # The team that the cycle is associated with.
  team {
    id
  }
  # The time at which the cycle was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The total number of estimation points after each day.
  scopeHistory
  # The total number of issues in the cycle after each day.
  issueCountHistory
  # The unique identifier of the entity.
  id
}

# A state in a team workflow.
fragment WorkflowState on WorkflowState {
  __typename
  # Description of the state.
  description
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The position of the state in the team flow.
  position
  # The state's UI color as a HEX string.
  color
  # The state's name.
  name
  # The team to which this state belongs to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the state.
  type
  # The unique identifier of the entity.
  id
}

# A team notification subscription.
fragment TeamNotificationSubscription on TeamNotificationSubscription {
  __typename
  # Subscribed project.
  project {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team subscribed to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the subscription.
  type
  # The unique identifier of the entity.
  id
  # The user associated with notification subscriptions.
  user {
    id
  }
}

# A template object used for creating entities faster.
fragment Template on Template {
  __typename
  # Template data.
  templateData
  # Template description.
  description
  # The entity type this template is for.
  type
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the template.
  name
  # The team that the template is associated with. If null, the template is global to the workspace.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the template.
  creator {
    id
  }
  # The user who last updated the template.
  lastUpdatedBy {
    id
  }
}

# A update associated with an project.
fragment ProjectUpdate on ProjectUpdate {
  __typename
  # The URL to the project update.
  url
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the update is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time the project update was edited.
  editedAt
  # The unique identifier of the entity.
  id
  # The update content in markdown format.
  body
  # The user who wrote the update.
  user {
    id
  }
}

# A user account.
fragment UserAccount on UserAccount {
  __typename
  # The authentication service used to create the account.
  service
  # The models identifier.
  id
  # The time at which the model was archived.
  archivedAt
  # The time at which the model was created.
  createdAt
  # The time at which the model was updated.
  updatedAt
  # The user's email address.
  email
  # The user's name.
  name
  # Users belonging to the account.
  users {
    ...User
  }
}

# A user that has access to the the resources of an organization.
fragment User on User {
  __typename
  # A date at which the user current status should be cleared.
  statusUntilAt
  # A short description of the user, either its title or bio.
  description
  # An URL to the user's avatar image.
  avatarUrl
  # Hash for the user to be used in calendar URLs.
  calendarHash
  # Number of issues created.
  createdIssueCount
  # Reason why is the account disabled.
  disableReason
  # The emoji to represent the user current status.
  statusEmoji
  # The label of the user current status.
  statusLabel
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The last time the user was seen online. If null, the user is currently online.
  lastSeen
  # The local timezone of the user.
  timezone
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user's display (nick) name. Unique within each organization.
  displayName
  # The user's email address.
  email
  # The user's full name.
  name
  # Unique hash for the user to be used in invite URLs.
  inviteHash
  # User's profile URL.
  url
  # Whether the user account is active or disabled (suspended).
  active
  # Whether the user is a guest in the workspace and limited to accessing a subset of teams.
  guest
  # Whether the user is an organization administrator.
  admin
  # Whether the user is the currently authenticated user.
  isMe
}

# A user's web browser push notification subscription.
fragment PushSubscription on PushSubscription {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A webhook used to send HTTP notifications over data updates
fragment Webhook on Webhook {
  __typename
  # Secret token for verifying the origin on the recipient side.
  secret
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The resource types this webhook is subscribed to.
  resourceTypes
  # The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the webhook.
  creator {
    id
  }
  # Webhook URL
  url
  # Webhook label
  label
  # Whether the Webhook is enabled for all public teams, including teams created after the webhook was created.
  allPublicTeams
  # Whether the Webhook is enabled.
  enabled
}

# An API key. Grants access to the user's resources.
fragment ApiKey on ApiKey {
  __typename
  # The label of the API key.
  label
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# An external link for a project.
fragment ProjectLink on ProjectLink {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The link's URL.
  url
  # The link's label.
  label
  # The project that the link is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the link.
  creator {
    id
  }
}

# An import job for data from an external service
fragment IssueImport on IssueImport {
  __typename
  # Current step progress in % (0-100).
  progress
  # New team's name in cases when teamId not set
  teamName
  # The data mapping configuration for the import job.
  mapping
  # The id for the user that started the job.
  creatorId
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The service from which data will be imported.
  service
  # The status for the import job.
  status
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # User readable error message, if one has occurred during the import.
  error
}

# An integration with an external service.
fragment Integration on Integration {
  __typename
  # The integration's type.
  service
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team that the integration is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that added the integration.
  creator {
    id
  }
}

# An invitation to the organization that has been sent via email.
fragment OrganizationInvite on OrganizationInvite {
  __typename
  # The invite was sent to external address.
  external
  # The invitees email address.
  email
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the invite was accepted. Null, if the invite hasn't been accepted
  acceptedAt
  # The time at which the invite will be expiring. Null, if the invite shouldn't expire
  expiresAt
  # The unique identifier of the entity.
  id
  # The user who created the invitation.
  inviter {
    id
  }
  # The user who has accepted the invite. Null, if the invite hasn't been accepted.
  invitee {
    id
  }
}

# An issue related notification
fragment IssueNotification on IssueNotification {
  __typename
  # Name of the reaction emoji related to the notification.
  reactionEmoji
  # Notification type
  type
  # The comment related to the notification.
  comment {
    id
  }
  # The issue related to the notification.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team related to the notification.
  team {
    id
  }
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification. If empty it's Linear itself.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# An issue.
fragment Issue on Issue {
  __typename
  # A flag that indicates whether the issue is in the trash bin.
  trashed
  # Issue URL.
  url
  # Issue's human readable identifier (e.g. ENG-123).
  identifier
  # Label for the priority.
  priorityLabel
  # Previous identifiers of the issue if it has been moved between teams.
  previousIdentifiers
  # Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
  customerTicketCount
  # Suggested branch name for the issue.
  branchName
  # The cycle that the issue is associated with.
  cycle {
    id
  }
  # The date at which the issue is due.
  dueDate
  # The estimate of the complexity of the issue..
  estimate
  # The issue's description in markdown format.
  description
  # The issue's title.
  title
  # The issue's unique number.
  number
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in its column on the board.
  boardOrder
  # The order of the item in relation to other items in the organization.
  sortOrder
  # The order of the item in the sub-issue list. Only set if the issue has a parent.
  subIssueSortOrder
  # The parent of the issue.
  parent {
    id
  }
  # The priority of the issue.
  priority
  # The project that the issue is associated with.
  project {
    id
  }
  # The team that the issue is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the issue entered triage.
  startedTriageAt
  # The time at which the issue left triage.
  triagedAt
  # The time at which the issue was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the issue was automatically closed by the auto pruning process.
  autoClosedAt
  # The time at which the issue was moved into canceled state.
  canceledAt
  # The time at which the issue was moved into completed state.
  completedAt
  # The time at which the issue was moved into started state.
  startedAt
  # The time until an issue will be snoozed in Triage view.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user to whom the issue is assigned to.
  assignee {
    id
  }
  # The user who created the issue.
  creator {
    id
  }
  # The user who snoozed the issue.
  snoozedBy {
    id
  }
  # The workflow state that the issue is associated with.
  state {
    id
  }
}

# An oauth client approval related notification
fragment OauthClientApprovalNotification on OauthClientApprovalNotification {
  __typename
  # Notification type
  type
  # The OAuth client approval request related to the notification.
  oauthClientApproval {
    ...OauthClientApproval
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification. If empty it's Linear itself.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# An organization. Organizations are root-level objects that contain user accounts and teams.
fragment Organization on Organization {
  __typename
  # Allowed authentication providers, empty array means all are allowed
  allowedAuthServices
  # How git branches are formatted. If null, default formatting will be used.
  gitBranchFormat
  # Number of active users in the organization.
  userCount
  # Number of issues in the organization.
  createdIssueCount
  # Previously used URL keys for the organization (last 3 are kept and redirected).
  previousUrlKeys
  # Rolling 30-day total upload volume for the organization, in megabytes.
  periodUploadVolume
  # The hour at which to prompt for project updates.
  projectUpdateRemindersHour
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The organization's logo URL.
  logoUrl
  # The organization's name.
  name
  # The organization's subscription to a paid plan.
  subscription {
    ...PaidSubscription
  }
  # The organization's unique URL key.
  urlKey
  # The time at which deletion of the organization was requested.
  deletionRequestedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # Whether SAML authentication is enabled for organization.
  samlEnabled
  # Whether SCIM provisioning is enabled for organization.
  scimEnabled
  # Whether the Git integration linkback messages should be sent to private repositories.
  gitLinkbackMessagesEnabled
  # Whether the Git integration linkback messages should be sent to public repositories.
  gitPublicLinkbackMessagesEnabled
  # Whether the organization is using a roadmap.
  roadmapEnabled
}

# An organizational unit that contains issues.
fragment Team on Team {
  __typename
  # Auto assign completed issues to current cycle.
  cycleIssueAutoAssignCompleted
  # Auto assign started issues to current cycle.
  cycleIssueAutoAssignStarted
  # Calendar feed URL (iCal) for cycles.
  cycleCalenderUrl
  # How many upcoming cycles to create.
  upcomingCycleCount
  # Only allow issues issues with cycles in Active Issues.
  cycleLockToActive
  # Period after which automatically closed and completed issues are automatically archived in months.
  autoArchivePeriod
  # Period after which issues are automatically closed in months. Null/undefined means disabled.
  autoClosePeriod
  # Settings for all integrations associated with that team.
  integrationsSettings {
    id
  }
  # Team's currently active cycle.
  activeCycle {
    id
  }
  # The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
  autoCloseStateId
  # The cooldown time after each cycle in weeks.
  cycleCooldownTime
  # The day of the week that a new cycle starts.
  cycleStartDay
  # The default template to use for new issues created by members of the team.
  defaultTemplateForMembers {
    id
  }
  # The default template to use for new issues created by non-members of the team.
  defaultTemplateForNonMembers {
    id
  }
  # The default workflow state into which issues are set when they are opened by team members.
  defaultIssueState {
    id
  }
  # The duration of a cycle in weeks.
  cycleDuration
  # The icon of the team.
  icon
  # The id of the default template to use for new issues created by members of the team.
  defaultTemplateForMembersId
  # The id of the default template to use for new issues created by non-members of the team.
  defaultTemplateForNonMembersId
  # The issue estimation type to use.
  issueEstimationType
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team's color.
  color
  # The team's description.
  description
  # The team's name.
  name
  # The team's unique key. The key is used in URLs.
  key
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The timezone of the team. Defaults to "America/Los_Angeles"
  timezone
  # The unique identifier of the entity.
  id
  # The workflow state into which issues are moved when a PR has been merged.
  mergeWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR has been opened as draft.
  draftWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR has been opened.
  startWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a review has been requested for the PR.
  reviewWorkflowState {
    id
  }
  # The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
  markedAsDuplicateWorkflowState {
    id
  }
  # The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
  triageIssueState {
    id
  }
  # Unique hash for the team to be used in invite URLs.
  inviteHash
  # What to use as an default estimate for unestimated issues.
  defaultIssueEstimate
  # Whether an issue needs to have a priority set before leaving triage
  requirePriorityToLeaveTriage
  # Whether issues without priority should be sorted first.
  issueOrderingNoPriorityFirst
  # Whether the team is private or not.
  private
  # Whether the team uses cycles.
  cyclesEnabled
  # Whether to add additional points to the estimate scale.
  issueEstimationExtended
  # Whether to allow zeros in issues estimates.
  issueEstimationAllowZero
  # Whether to group recent issue history entries.
  groupIssueHistory
  # Whether to move issues to bottom of the column when changing state.
  issueSortOrderDefaultToBottom
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
  # Whether triage mode is enabled for the team or not.
  triageEnabled
}

# Contains either the full serialized state of the application or delta packets that the requester can
# apply to the local data set in order to be up-to-date.
fragment SyncResponse on SyncResponse {
  __typename
  # JSON serialized delta changes that the client can apply to its local state
  #     in order to catch up with the state of the world.
  delta
  # The full state of the organization as a serialized JSON object.
  #     Mutually exclusive with the delta property
  state
  # The last sync id covered by the response.
  lastSyncId
  # The sync groups that the user is subscribed to.
  subscribedSyncGroups
  # The version of the remote database. Incremented by 1 for each migration run on the database.
  databaseVersion
}

# Defines the membership of a user to a team.
fragment TeamMembership on TeamMembership {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in the users team list.
  sortOrder
  # The team that the membership is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that the membership is associated with.
  user {
    id
  }
  # Whether the user is the owner of the team
  owner
}

# Defines the use of a domain by an organization.
fragment OrganizationDomain on OrganizationDomain {
  __typename
  # Domain name
  name
  # E-mail used to verify this domain
  verificationEmail
  # Is this domain verified
  verified
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who added the domain.
  creator {
    id
  }
  # Whether the domains was claimed by the organization through DNS verification.
  claimed
}

# Front specific settings.
fragment FrontSettings on FrontSettings {
  __typename
  # Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  automateTicketReopeningOnComment
  # Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  automateTicketReopeningOnCancellation
  # Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  automateTicketReopeningOnCompletion
  # Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  sendNoteOnStatusChange
  # Whether an internal message should be added when someone comments on an issue.
  sendNoteOnComment
}

# GitHub OAuth token, plus information about the organizations the user is a member of.
fragment GithubOAuthTokenPayload on GithubOAuthTokenPayload {
  __typename
  # A list of the GitHub organizations the user is a member of with attached repositories.
  organizations {
    ...GithubOrg
  }
  # The OAuth token if the operation to fetch it was successful.
  token
}

# Google Sheets specific settings.
fragment GoogleSheetsSettings on GoogleSheetsSettings {
  __typename
  sheetId
  spreadsheetId
  spreadsheetUrl
  updatedIssuesAt
}

# Holds information about when a user has interacted with a project update.
fragment ProjectUpdateInteraction on ProjectUpdateInteraction {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project update that has been interacted with.
  projectUpdate {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the user read the project update.
  readAt
  # The unique identifier of the entity.
  id
  # The user that has interacted with the project update.
  user {
    id
  }
}

# Intercom specific settings.
fragment IntercomSettings on IntercomSettings {
  __typename
  # Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  automateTicketReopeningOnComment
  # Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  automateTicketReopeningOnCancellation
  # Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  automateTicketReopeningOnCompletion
  # Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  sendNoteOnStatusChange
  # Whether an internal message should be added when someone comments on an issue.
  sendNoteOnComment
}

# Issue attachment (e.g. support ticket, pull request).
fragment Attachment on Attachment {
  __typename
  # An accessor helper to source.type, defines the source type of the attachment.
  sourceType
  # Content for the subtitle line in the Linear attachment widget.
  subtitle
  # Content for the title line in the Linear attachment widget.
  title
  # Custom metadata related to the attachment.
  metadata
  # Indicates if attachments for the same source application should be grouped in the Linear UI.
  groupBySource
  # Information about the source which created the attachment.
  source
  # Location of the attachment which is also used as an identifier.
  url
  # The creator of the attachment.
  creator {
    id
  }
  # The issue this attachment belongs to.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Issue relation history's payload
fragment IssueRelationHistoryPayload on IssueRelationHistoryPayload {
  __typename
  # The identifier of the related issue.
  identifier
  # The type of the change.
  type
}

# Jira specific settings.
fragment JiraSettings on JiraSettings {
  __typename
  # The Jira projects for the organization.
  projects {
    ...JiraProjectData
  }
  # The mapping of Jira project id => Linear team id.
  projectMapping {
    ...JiraLinearMapping
  }
}

# Join table between projects and roadmaps
fragment RoadmapToProject on RoadmapToProject {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the roadmap is associated with.
  project {
    id
  }
  # The roadmap that the project is associated with.
  roadmap {
    id
  }
  # The sort order of the project within the roadmap.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Join table between templates and integrations
fragment IntegrationTemplate on IntegrationTemplate {
  __typename
  # The integration that the template is associated with.
  integration {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The template that the integration is associated with.
  template {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Labels that can be associated with issues.
fragment IssueLabel on IssueLabel {
  __typename
  # The label's color as a HEX string.
  color
  # The label's description.
  description
  # The label's name.
  name
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The parent label.
  parent {
    id
  }
  # The team that the label is associated with. If null, the label is associated with the global workspace.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the label.
  creator {
    id
  }
}

# Metadata about a Jira project.
fragment JiraProjectData on JiraProjectData {
  __typename
  # The Jira id for this project.
  id
  # The Jira key for this project, such as ENG.
  key
  # The Jira name for this project, such as Engineering.
  name
}

# Metadata and settings for a GitHub integration.
fragment GitHubSettings on GitHubSettings {
  __typename
  # The GitHub organization's name
  orgLogin
  # The avatar URL for the GitHub organization
  orgAvatarUrl
}

# Notification subscriptions for models.
fragment NotificationSubscription on NotificationSubscription {
  __typename
  # Subscribed project.
  project {
    id
  }
  # Subscribed team.
  team {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the subscription.
  type
  # The unique identifier of the entity.
  id
  # The user associated with notification subscriptions.
  user {
    id
  }
}

# Notion specific settings.
fragment NotionSettings on NotionSettings {
  __typename
  # The ID of the Notion workspace being connected.
  workspaceId
  # The name of the Notion workspace being connected.
  workspaceName
}

# OAuth2 client application
fragment OauthClient on OauthClient {
  __typename
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # List of allowed redirect URIs for the application.
  redirectUris
  # Name of the developer.
  developer
  # OAuth application's client ID.
  clientId
  # OAuth application's client name.
  name
  # OAuth application's client secret.
  clientSecret
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The resource types to request when creating new webhooks.
  webhookResourceTypes
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the OAuthClient.
  creator {
    id
  }
  # Url of the developer.
  developerUrl
  # Webhook URL
  webhookUrl
  # Whether the OAuth application is publicly visible, or only visible to the creating workspace.
  publicEnabled
}

# Object representing Figma preview information.
fragment FigmaEmbed on FigmaEmbed {
  __typename
  # Date when the file was updated at the time of embedding.
  lastModified
  # Figma file name.
  name
  # Figma screenshot URL.
  url
  # Node name.
  nodeName
}

# Object representing Google Cloud upload policy, plus additional data.
fragment UploadFile on UploadFile {
  __typename
  # The asset URL for the uploaded file. (assigned automatically)
  assetUrl
  # The content type.
  contentType
  # The filename.
  filename
  # The signed URL the for the uploaded file. (assigned automatically)
  uploadUrl
  # The size of the uploaded file.
  size
  headers {
    ...UploadFileHeader
  }
  metaData
}

# Public information of the OAuth application, plus whether the application has been authorized for
# the given scopes.
fragment UserAuthorizedApplication on UserAuthorizedApplication {
  __typename
  # Application name.
  name
  # Error associated with the application needing to be requested for approval in the workspace
  approvalErrorCode
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's ID.
  id
  # OAuth application's client ID.
  clientId
  # Url of the developer (homepage or docs).
  developerUrl
  # Whether or not webhooks are enabled for the application.
  webhooksEnabled
  # Whether the application was created by Linear.
  createdByLinear
  # Whether the user has authorized the application for the given scopes.
  isAuthorized
}

# Public information of the OAuth application.
fragment Application on Application {
  __typename
  # Application name.
  name
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's ID.
  id
  # OAuth application's client ID.
  clientId
  # Url of the developer (homepage or docs).
  developerUrl
}

# Relevant information for the GitHub organization.
fragment GithubOrg on GithubOrg {
  __typename
  # GitHub organization id.
  id
  # Repositories that the organization owns.
  repositories {
    ...GithubRepo
  }
  # The login for the GitHub organization.
  login
  # The name of the GitHub organization.
  name
  # Whether or not this org is the user's personal repositories.
  isPersonal
}

# Relevant information for the GitHub repository.
fragment GithubRepo on GithubRepo {
  __typename
  # The id of the GitHub repository.
  id
  # The name of the GitHub repository.
  name
}

# Request to install OAuth clients on organizations and the response to the request.
fragment OauthClientApproval on OauthClientApproval {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The person who requested installing the OAuth client.
  requesterId
  # The person who responded to the request to install the OAuth client.
  responderId
  # The reason the person wants to install this OAuth client.
  requestReason
  # The reason the request for the OAuth client approval was denied.
  denyReason
  # The scopes the app has requested.
  scopes
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The uuid of the OAuth client being requested for installation.
  oauthClientId
}

# Sentry specific settings.
fragment SentrySettings on SentrySettings {
  __typename
  # The slug of the Sentry organization being connected.
  organizationSlug
}

# Slack notification specific settings.
fragment SlackPostSettings on SlackPostSettings {
  __typename
  channel
  channelId
  configurationUrl
}

# The configuration of all integrations for a project or a team.
fragment IntegrationsSettings on IntegrationsSettings {
  __typename
  # Project which those settings apply to.
  project {
    id
  }
  # Team which those settings apply to.
  team {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # Whether to send a Slack message when a comment is created on any of the project or team's issues.
  slackIssueNewComment
  # Whether to send a Slack message when a new issue is added to triage.
  slackIssueAddedToTriage
  # Whether to send a Slack message when a new issue is created for the project or the team.
  slackIssueCreated
  # Whether to send a Slack message when a project update is created.
  slackProjectUpdateCreated
  # Whether to send a Slack message when an SLA is at high risk
  slackIssueSlaHighRisk
  # Whether to send a Slack message when an SLA is breached
  slackIssueSlaBreached
  # Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
  slackIssueStatusChangedDone
  # Whether to send a Slack message when any of the project or team's issues has a change in status.
  slackIssueStatusChangedAll
  # Whether to send a new project update to team Slack channels.
  slackProjectUpdateCreatedToTeam
  # Whether to send a new project update to workspace Slack channel.
  slackProjectUpdateCreatedToWorkspace
}

# The integration resource's settings
fragment IntegrationSettings on IntegrationSettings {
  __typename
  front {
    ...FrontSettings
  }
  gitHub {
    ...GitHubSettings
  }
  googleSheets {
    ...GoogleSheetsSettings
  }
  intercom {
    ...IntercomSettings
  }
  jira {
    ...JiraSettings
  }
  notion {
    ...NotionSettings
  }
  sentry {
    ...SentrySettings
  }
  slackOrgProjectUpdatesPost {
    ...SlackPostSettings
  }
  slackPost {
    ...SlackPostSettings
  }
  slackProjectPost {
    ...SlackPostSettings
  }
  zendesk {
    ...ZendeskSettings
  }
}

# The organization's SAML configuration
fragment SamlConfigurationPayload on SamlConfigurationPayload {
  __typename
  # Binding method for authentication call. Can be either `post` (default) or `redirect`.
  ssoBinding
  # Sign in endpoint URL for the identity provider.
  ssoEndpoint
  # The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  ssoSignAlgo
  # The issuer's custom entity ID.
  issuerEntityId
}

# The paid subscription of an organization.
fragment PaidSubscription on PaidSubscription {
  __typename
  # The creator of the subscription.
  creator {
    id
  }
  # The date the subscription was canceled, if any.
  canceledAt
  # The date the subscription will be billed next.
  nextBillingAt
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The maximum number of seats that will be billed in the subscription.
  seatsMaximum
  # The minimum number of seats that will be billed in the subscription.
  seatsMinimum
  # The number of seats in the subscription.
  seats
  # The subscription type of a pending change. Null if no change pending.
  pendingChangeType
  # The subscription type.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# The settings of a user as a JSON object.
fragment UserSettings on UserSettings {
  __typename
  # The email types the user has unsubscribed from.
  unsubscribedFrom
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The notification channel settings the user has selected.
  notificationPreferences
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user associated with these settings.
  user {
    id
  }
}

# Tuple for mapping Jira projects to Linear teams.
fragment JiraLinearMapping on JiraLinearMapping {
  __typename
  # The Jira id for this project.
  jiraProjectId
  # The Linear team id to map to the given project.
  linearTeamId
}

# User favorites presented in the sidebar.
fragment Favorite on Favorite {
  __typename
  # The favorited custom view.
  customView {
    id
  }
  # The favorited cycle.
  cycle {
    id
  }
  # The favorited document.
  document {
    id
  }
  # The favorited issue.
  issue {
    id
  }
  # The favorited label.
  label {
    id
  }
  # The favorited project.
  project {
    id
  }
  # The favorited roadmap.
  roadmap {
    id
  }
  # The favorited team of the project.
  projectTeam {
    id
  }
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the folder. Only applies to favorites of type folder.
  folderName
  # The order of the item in the favorites list.
  sortOrder
  # The owner of the favorite.
  user {
    id
  }
  # The parent folder of the favorite.
  parent {
    id
  }
  # The team of the favorited predefiend view.
  predefinedViewTeam {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of favorited predefiend view.
  predefinedViewType
  # The type of the favorite.
  type
  # The unique identifier of the entity.
  id
}

# View preferences.
fragment ViewPreferences on ViewPreferences {
  __typename
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The view preference type.
  type
  # The view type.
  viewType
}

# Workspace audit log entry object.
fragment AuditEntry on AuditEntry {
  __typename
  # Additional information related to the request which performed the action.
  requestInformation
  # Additional metadata related to the audit entry.
  metadata
  # Country code of request resulting to audit entry.
  countryCode
  # IP from actor when entry was recorded.
  ip
  # The ID of the user that caused the audit entry to be created.
  actorId
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that caused the audit entry to be created.
  actor {
    id
  }
  type
}

# Zendesk specific settings.
fragment ZendeskSettings on ZendeskSettings {
  __typename
  # The ID of the Linear bot user.
  botUserId
  # The URL of the connected Zendesk organization.
  url
  # The subdomain of the Zendesk organization being connected.
  subdomain
  # Whether a ticket should be automatically reopened when a comment is posted on its linked Linear issue
  automateTicketReopeningOnComment
  # Whether a ticket should be automatically reopened when its linked Linear issue is cancelled.
  automateTicketReopeningOnCancellation
  # Whether a ticket should be automatically reopened when its linked Linear issue is completed.
  automateTicketReopeningOnCompletion
  # Whether an internal message should be added when a Linear issue changes status (for status types except completed or canceled).
  sendNoteOnStatusChange
  # Whether an internal message should be added when someone comments on an issue.
  sendNoteOnComment
}

fragment AdminJobConfigurationPayload on AdminJobConfigurationPayload {
  __typename
  currentJob
  delay
  enabled
  param
}

fragment AdminJobStatusPayload on AdminJobStatusPayload {
  __typename
  availableJobs
  configuration {
    ...AdminJobConfigurationPayload
  }
  cursor
  startedAt
}

fragment ApiKeyConnection on ApiKeyConnection {
  __typename
  nodes {
    ...ApiKey
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ApiKeyPayload on ApiKeyPayload {
  __typename
  # The API key that was created.
  apiKey {
    ...ApiKey
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ArchivePayload on ArchivePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment AttachmentConnection on AttachmentConnection {
  __typename
  nodes {
    ...Attachment
  }
  pageInfo {
    ...PageInfo
  }
}

fragment AttachmentPayload on AttachmentPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue attachment that was created.
  attachment {
    id
  }
  # Whether the operation was successful.
  success
}

fragment AuditEntryConnection on AuditEntryConnection {
  __typename
  nodes {
    ...AuditEntry
  }
  pageInfo {
    ...PageInfo
  }
}

fragment AuditEntryType on AuditEntryType {
  __typename
  # Description of the audit entry type.
  description
  # The audit entry type.
  type
}

fragment AuthResolverResponse on AuthResolverResponse {
  __typename
  # Email for the authenticated account.
  email
  # ID of the organization last accessed by the user.
  lastUsedOrganizationId
  # JWT token for authentication of the account.
  token
  # Organizations this account has access to, but is not yet a member.
  availableOrganizations {
    ...Organization
  }
  # Should the signup flow allow access for the domain.
  allowDomainAccess
  # User account ID.
  id
  # Users belonging to this account.
  users {
    ...User
  }
}

fragment CommentConnection on CommentConnection {
  __typename
  nodes {
    ...Comment
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CommentPayload on CommentPayload {
  __typename
  # The comment that was created or updated.
  comment {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ContactPayload on ContactPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment CreateCsvExportReportPayload on CreateCsvExportReportPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment CreateOrJoinOrganizationResponse on CreateOrJoinOrganizationResponse {
  __typename
  user {
    id
  }
}

fragment CustomViewConnection on CustomViewConnection {
  __typename
  nodes {
    ...CustomView
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomViewPayload on CustomViewPayload {
  __typename
  # The custom view that was created or updated.
  customView {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment CycleConnection on CycleConnection {
  __typename
  nodes {
    ...Cycle
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CyclePayload on CyclePayload {
  __typename
  # The Cycle that was created or updated.
  cycle {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment DocumentConnection on DocumentConnection {
  __typename
  nodes {
    ...Document
  }
  pageInfo {
    ...PageInfo
  }
}

fragment DocumentPayload on DocumentPayload {
  __typename
  # The document that was created or updated.
  document {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment EmailUnsubscribePayload on EmailUnsubscribePayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment EmailUserAccountAuthChallengeResponse on EmailUserAccountAuthChallengeResponse {
  __typename
  # Supported challenge for this user account. Can be either verificationCode or password.
  authType
  # Whether the operation was successful.
  success
}

fragment EmojiConnection on EmojiConnection {
  __typename
  nodes {
    ...Emoji
  }
  pageInfo {
    ...PageInfo
  }
}

fragment EmojiPayload on EmojiPayload {
  __typename
  # The emoji that was created.
  emoji {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment EventPayload on EventPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment FavoriteConnection on FavoriteConnection {
  __typename
  nodes {
    ...Favorite
  }
  pageInfo {
    ...PageInfo
  }
}

fragment FavoritePayload on FavoritePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The object that was added as a favorite.
  favorite {
    id
  }
  # Whether the operation was successful.
  success
}

fragment FigmaEmbedPayload on FigmaEmbedPayload {
  __typename
  # Figma embed information.
  figmaEmbed {
    ...FigmaEmbed
  }
  # Whether the operation was successful.
  success
}

fragment FrontAttachmentPayload on FrontAttachmentPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment GitHubCommitIntegrationPayload on GitHubCommitIntegrationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # The webhook secret to provide to GitHub.
  webhookSecret
  # Whether the operation was successful.
  success
}

fragment ImageUploadFromUrlPayload on ImageUploadFromUrlPayload {
  __typename
  # The URL containing the image.
  url
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment IntegrationConnection on IntegrationConnection {
  __typename
  nodes {
    ...Integration
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IntegrationPayload on IntegrationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IntegrationRequestPayload on IntegrationRequestPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment IntegrationTemplateConnection on IntegrationTemplateConnection {
  __typename
  nodes {
    ...IntegrationTemplate
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IntegrationTemplatePayload on IntegrationTemplatePayload {
  __typename
  # The IntegrationTemplate that was created or updated.
  integrationTemplate {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment IntegrationsSettingsConnection on IntegrationsSettingsConnection {
  __typename
  nodes {
    ...IntegrationsSettings
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IntegrationsSettingsPayload on IntegrationsSettingsPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The settings that were created or updated.
  integrationsSettings {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssueBatchPayload on IssueBatchPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issues that were updated.
  issues {
    ...Issue
  }
  # Whether the operation was successful.
  success
}

fragment IssueConnection on IssueConnection {
  __typename
  nodes {
    ...Issue
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueHistoryConnection on IssueHistoryConnection {
  __typename
  nodes {
    ...IssueHistory
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueImportDeletePayload on IssueImportDeletePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The import job that was deleted.
  issueImport {
    ...IssueImport
  }
  # Whether the operation was successful.
  success
}

fragment IssueImportPayload on IssueImportPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The import job that was created or updated.
  issueImport {
    ...IssueImport
  }
  # Whether the operation was successful.
  success
}

fragment IssueLabelConnection on IssueLabelConnection {
  __typename
  nodes {
    ...IssueLabel
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueLabelPayload on IssueLabelPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The label that was created or updated.
  issueLabel {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssuePayload on IssuePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue that was created or updated.
  issue {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssuePriorityValue on IssuePriorityValue {
  __typename
  # Priority's label.
  label
  # Priority's number value.
  priority
}

fragment IssueRelationConnection on IssueRelationConnection {
  __typename
  nodes {
    ...IssueRelation
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueRelationPayload on IssueRelationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue relation that was created or updated.
  issueRelation {
    id
  }
  # Whether the operation was successful.
  success
}

fragment LogoutResponse on LogoutResponse {
  __typename
  # Whether the operation was successful.
  success
}

fragment Node on Node {
  __typename
  # The unique identifier of the entity.
  id
}

fragment NotificationConnection on NotificationConnection {
  __typename
  nodes {
    ...Notification
  }
  pageInfo {
    ...PageInfo
  }
}

fragment NotificationPayload on NotificationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The notification that was created or updated.
  notification {
    ...Notification
  }
  # Whether the operation was successful.
  success
}

fragment NotificationSubscriptionConnection on NotificationSubscriptionConnection {
  __typename
  nodes {
    ...NotificationSubscription
  }
  pageInfo {
    ...PageInfo
  }
}

fragment NotificationSubscriptionPayload on NotificationSubscriptionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The notification subscription that was created or updated.
  notificationSubscription {
    ...NotificationSubscription
  }
  # Whether the operation was successful.
  success
}

fragment OrganizationCancelDeletePayload on OrganizationCancelDeletePayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment OrganizationDeletePayload on OrganizationDeletePayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment OrganizationExistsPayload on OrganizationExistsPayload {
  __typename
  # Whether the operation was successful.
  success
  # Whether the organization exists.
  exists
}

fragment OrganizationInviteConnection on OrganizationInviteConnection {
  __typename
  nodes {
    ...OrganizationInvite
  }
  pageInfo {
    ...PageInfo
  }
}

fragment OrganizationInviteDetailsPayload on OrganizationInviteDetailsPayload {
  __typename
  # ID of the workspace the invite is for.
  organizationId
  # Name of the workspace the invite is for.
  organizationName
  # The email of the invitee
  email
  # The name of the inviter
  inviter
  # URL of the workspace logo the invite is for.
  organizationLogoUrl
  # When the invite was created.
  createdAt
  # Whether the invite has already been accepted.
  accepted
  # Whether the invite has expired.
  expired
}

fragment OrganizationInvitePayload on OrganizationInvitePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The organization invite that was created or updated.
  organizationInvite {
    id
  }
  # Whether the operation was successful.
  success
}

fragment OrganizationPayload on OrganizationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment PageInfo on PageInfo {
  __typename
  # Cursor representing the first result in the paginated results.
  startCursor
  # Cursor representing the last result in the paginated results.
  endCursor
  # Indicates if there are more results when paginating backward.
  hasPreviousPage
  # Indicates if there are more results when paginating forward.
  hasNextPage
}

fragment ProjectConnection on ProjectConnection {
  __typename
  nodes {
    ...Project
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectLinkConnection on ProjectLinkConnection {
  __typename
  nodes {
    ...ProjectLink
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectLinkPayload on ProjectLinkPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project that was created or updated.
  projectLink {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectMilestoneConnection on ProjectMilestoneConnection {
  __typename
  nodes {
    ...ProjectMilestone
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectMilestonePayload on ProjectMilestonePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project milestone that was created or updated.
  projectMilestone {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectPayload on ProjectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project that was created or updated.
  project {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectUpdateConnection on ProjectUpdateConnection {
  __typename
  nodes {
    ...ProjectUpdate
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectUpdateInteractionConnection on ProjectUpdateInteractionConnection {
  __typename
  nodes {
    ...ProjectUpdateInteraction
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectUpdateInteractionPayload on ProjectUpdateInteractionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project update interaction that was created or updated.
  projectUpdateInteraction {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectUpdatePayload on ProjectUpdatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project update that was created or updated.
  projectUpdate {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectUpdateWithInteractionPayload on ProjectUpdateWithInteractionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project update that was created or updated.
  interaction {
    id
  }
  # The project update that was created or updated.
  projectUpdate {
    id
  }
  # Whether the operation was successful.
  success
}

fragment PushSubscriptionConnection on PushSubscriptionConnection {
  __typename
  nodes {
    ...PushSubscription
  }
  pageInfo {
    ...PageInfo
  }
}

fragment PushSubscriptionPayload on PushSubscriptionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment PushSubscriptionTestPayload on PushSubscriptionTestPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment RateLimitPayload on RateLimitPayload {
  __typename
  # The identifier we rate limit on.
  identifier
  # The kind of rate limit selected for this request.
  kind
  # The state of the rate limit.
  limits {
    ...RateLimitResultPayload
  }
}

fragment RateLimitResultPayload on RateLimitResultPayload {
  __typename
  # The period in which the rate limit is fully replenished in ms.
  period
  # The remaining quantity for this type of limit after this request.
  remainingAmount
  # The requested quantity for this type of limit.
  requestedAmount
  # The timestamp after the rate limit is fully replenished as a UNIX timestamp.
  reset
  # The total allowed quantity for this type of limit.
  allowedAmount
  # What is being rate limited.
  type
}

fragment ReactionConnection on ReactionConnection {
  __typename
  nodes {
    ...Reaction
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ReactionPayload on ReactionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  reaction {
    ...Reaction
  }
  success
}

fragment RoadmapConnection on RoadmapConnection {
  __typename
  nodes {
    ...Roadmap
  }
  pageInfo {
    ...PageInfo
  }
}

fragment RoadmapPayload on RoadmapPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The roadmap that was created or updated.
  roadmap {
    id
  }
  # Whether the operation was successful.
  success
}

fragment RoadmapToProjectConnection on RoadmapToProjectConnection {
  __typename
  nodes {
    ...RoadmapToProject
  }
  pageInfo {
    ...PageInfo
  }
}

fragment RoadmapToProjectPayload on RoadmapToProjectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The roadmapToProject that was created or updated.
  roadmapToProject {
    id
  }
  # Whether the operation was successful.
  success
}

fragment SamlConfiguration on SamlConfiguration {
  __typename
  # Binding method for authentication call. Can be either `post` (default) or `redirect`.
  ssoBinding
  # Sign in endpoint URL for the identity provider.
  ssoEndpoint
  # The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  ssoSignAlgo
  # The issuer's custom entity ID.
  issuerEntityId
  # X.509 Signing Certificate in string form.
  ssoSigningCert
}

fragment SsoUrlFromEmailResponse on SsoUrlFromEmailResponse {
  __typename
  # SAML SSO sign-in URL.
  samlSsoUrl
  # Whether the operation was successful.
  success
}

fragment SynchronizedPayload on SynchronizedPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
}

fragment TeamConnection on TeamConnection {
  __typename
  nodes {
    ...Team
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TeamMembershipConnection on TeamMembershipConnection {
  __typename
  nodes {
    ...TeamMembership
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TeamMembershipPayload on TeamMembershipPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The team membership that was created or updated.
  teamMembership {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TeamPayload on TeamPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The team that was created or updated.
  team {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TemplateConnection on TemplateConnection {
  __typename
  pageInfo {
    ...PageInfo
  }
}

fragment TemplatePayload on TemplatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The template that was created or updated.
  template {
    id
  }
  # Whether the operation was successful.
  success
}

fragment UploadFileHeader on UploadFileHeader {
  __typename
  # Upload file header key.
  key
  # Upload file header value.
  value
}

fragment UploadPayload on UploadPayload {
  __typename
  # Object describing the file to be uploaded.
  uploadFile {
    ...UploadFile
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserAdminPayload on UserAdminPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment UserConnection on UserConnection {
  __typename
  nodes {
    ...User
  }
  pageInfo {
    ...PageInfo
  }
}

fragment UserPayload on UserPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The user that was created or updated.
  user {
    id
  }
  # Whether the operation was successful.
  success
}

fragment UserSettingsFlagPayload on UserSettingsFlagPayload {
  __typename
  # The flag key which was updated.
  flag
  # The flag value after update.
  value
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSettingsFlagsResetPayload on UserSettingsFlagsResetPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSettingsPayload on UserSettingsPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ViewPreferencesPayload on ViewPreferencesPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The view preferences entity being mutated.
  viewPreferences {
    ...ViewPreferences
  }
  # Whether the operation was successful.
  success
}

fragment WebhookConnection on WebhookConnection {
  __typename
  nodes {
    ...Webhook
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WebhookPayload on WebhookPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The webhook entity being mutated.
  webhook {
    id
  }
  # Whether the operation was successful.
  success
}

fragment WorkflowDefinition on WorkflowDefinition {
  __typename
  # An array of activities that will be executed as part of the workflow.
  activities
  # Cron schedule which is used to execute the workflow. Only applicable for cron based workflows.
  schedule
  # The conditions that need to be match for the workflow to be triggered.
  conditions
  # The description of the workflow.
  description
  # The last time at which the entity was meaningfully updated, i.e. for all changes of syncable properties except those
  #     for which updates should not produce an update to updatedAt (see skipUpdatedAtKeys). This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the group that the workflow belongs to.
  groupName
  # The name of the workflow.
  name
  # The sort order of the workflow definition within its siblings.
  sortOrder
  # The team associated with the workflow. If not set, the workflow is associated with the entire organization.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the workflow.
  creator {
    id
  }
  enabled
}

fragment WorkflowDefinitionConnection on WorkflowDefinitionConnection {
  __typename
  nodes {
    ...WorkflowDefinition
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WorkflowStateConnection on WorkflowStateConnection {
  __typename
  nodes {
    ...WorkflowState
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WorkflowStatePayload on WorkflowStatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The state that was created or updated.
  workflowState {
    id
  }
  # Whether the operation was successful.
  success
}

# Creates an integration api key for Airbyte to connect with Linear
mutation airbyteIntegrationConnect(
  # Airbyte integration settings.
  $input: AirbyteConfigurationInput!
) {
  airbyteIntegrationConnect(input: $input) {
    ...IntegrationPayload
  }
}
# Creates a new API key.
mutation createApiKey(
  # The api key object to create.
  $input: ApiKeyCreateInput!
) {
  apiKeyCreate(input: $input) {
    ...ApiKeyPayload
  }
}
# Deletes an API key.
mutation deleteApiKey(
  # The identifier of the API key to delete.
  $id: String!
) {
  apiKeyDelete(id: $id) {
    ...ArchivePayload
  }
}
# [DEPRECATED] Archives an issue attachment.
mutation archiveAttachment(
  # The identifier of the attachment to archive.
  $id: String!
) {
  attachmentArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
mutation createAttachment(
  # The attachment object to create.
  $input: AttachmentCreateInput!
) {
  attachmentCreate(input: $input) {
    ...AttachmentPayload
  }
}
# Deletes an issue attachment.
mutation deleteAttachment(
  # The identifier of the attachment to delete.
  $id: String!
) {
  attachmentDelete(id: $id) {
    ...ArchivePayload
  }
}
# Link an existing Discord message to an issue.
mutation attachmentLinkDiscord(
  # The Discord channel ID for the message to link.
  $channelId: String!
  # The issue for which to link the Discord message.
  $issueId: String!
  # The Discord message ID for the message to link.
  $messageId: String!
  # The Discord message URL for the message to link.
  $url: String!
) {
  attachmentLinkDiscord(channelId: $channelId, issueId: $issueId, messageId: $messageId, url: $url) {
    ...AttachmentPayload
  }
}
# Link an existing Front conversation to an issue.
mutation attachmentLinkFront(
  # The Front conversation ID to link.
  $conversationId: String!
  # The issue for which to link the Front conversation.
  $issueId: String!
) {
  attachmentLinkFront(conversationId: $conversationId, issueId: $issueId) {
    ...FrontAttachmentPayload
  }
}
# Link an existing Intercom conversation to an issue.
mutation attachmentLinkIntercom(
  # The Intercom conversation ID to link.
  $conversationId: String!
  # The issue for which to link the Intercom conversation.
  $issueId: String!
) {
  attachmentLinkIntercom(conversationId: $conversationId, issueId: $issueId) {
    ...AttachmentPayload
  }
}
# Link an existing Jira issue to an issue.
mutation attachmentLinkJiraIssue(
  # The issue for which to link the Jira issue.
  $issueId: String!
  # The Jira issue key or ID to link.
  $jiraIssueId: String!
) {
  attachmentLinkJiraIssue(issueId: $issueId, jiraIssueId: $jiraIssueId) {
    ...AttachmentPayload
  }
}
# Link any url to an issue.
mutation attachmentLinkURL(
  # The id for the attachment.
  $id: String
  # The issue for which to link the url.
  $issueId: String!
  # The title to use for the attachment.
  $title: String
  # The url to link.
  $url: String!
) {
  attachmentLinkURL(id: $id, issueId: $issueId, title: $title, url: $url) {
    ...AttachmentPayload
  }
}
# Link an existing Zendesk ticket to an issue.
mutation attachmentLinkZendesk(
  # The issue for which to link the Zendesk ticket.
  $issueId: String!
  # The Zendesk ticket ID to link.
  $ticketId: String!
) {
  attachmentLinkZendesk(issueId: $issueId, ticketId: $ticketId) {
    ...AttachmentPayload
  }
}
# Updates an existing issue attachment.
mutation updateAttachment(
  # The identifier of the attachment to update.
  $id: String!
  # A partial attachment object to update the attachment with.
  $input: AttachmentUpdateInput!
) {
  attachmentUpdate(id: $id, input: $input) {
    ...AttachmentPayload
  }
}
# Creates a new comment.
mutation createComment(
  # The comment object to create.
  $input: CommentCreateInput!
) {
  commentCreate(input: $input) {
    ...CommentPayload
  }
}
# Deletes a comment.
mutation deleteComment(
  # The identifier of the comment to delete.
  $id: String!
) {
  commentDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a comment.
mutation updateComment(
  # The identifier of the comment to update.
  $id: String!
  # A partial comment object to update the comment with.
  $input: CommentUpdateInput!
) {
  commentUpdate(id: $id, input: $input) {
    ...CommentPayload
  }
}
# Saves user message.
mutation createContact(
  # The contact entry to create.
  $input: ContactCreateInput!
) {
  contactCreate(input: $input) {
    ...ContactPayload
  }
}
# Create CSV export report for the organization.
mutation createCsvExportReport($includePrivateTeamIds: [String!]) {
  createCsvExportReport(includePrivateTeamIds: $includePrivateTeamIds) {
    ...CreateCsvExportReportPayload
  }
}
# Creates an organization from onboarding.
mutation createOrganizationFromOnboarding(
  # Organization details for the new organization.
  $input: CreateOrganizationInput!
  # Onboarding survey.
  $survey: OnboardingCustomerSurvey
) {
  createOrganizationFromOnboarding(input: $input, survey: $survey) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Creates a new custom view.
mutation createCustomView(
  # The properties of the custom view to create.
  $input: CustomViewCreateInput!
) {
  customViewCreate(input: $input) {
    ...CustomViewPayload
  }
}
# Deletes a custom view.
mutation deleteCustomView(
  # The identifier of the custom view to delete.
  $id: String!
) {
  customViewDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a custom view.
mutation updateCustomView(
  # The identifier of the custom view to update.
  $id: String!
  # The properties of the custom view to update.
  $input: CustomViewUpdateInput!
) {
  customViewUpdate(id: $id, input: $input) {
    ...CustomViewPayload
  }
}
# Archives a cycle.
mutation archiveCycle(
  # The identifier of the cycle to archive.
  $id: String!
) {
  cycleArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new cycle.
mutation createCycle(
  # The cycle object to create.
  $input: CycleCreateInput!
) {
  cycleCreate(input: $input) {
    ...CyclePayload
  }
}
# Updates a cycle.
mutation updateCycle(
  # The identifier of the cycle to update.
  $id: String!
  # A partial cycle object to update the cycle with.
  $input: CycleUpdateInput!
) {
  cycleUpdate(id: $id, input: $input) {
    ...CyclePayload
  }
}
# Creates a new document.
mutation createDocument(
  # The document to create.
  $input: DocumentCreateInput!
) {
  documentCreate(input: $input) {
    ...DocumentPayload
  }
}
# Deletes a document.
mutation deleteDocument(
  # The identifier of the document to delete.
  $id: String!
) {
  documentDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a document.
mutation updateDocument(
  # The identifier of the document to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial document object to update the document with.
  $input: DocumentUpdateInput!
) {
  documentUpdate(id: $id, input: $input) {
    ...DocumentPayload
  }
}
# Authenticates a user account via email and authentication token.
mutation emailTokenUserAccountAuth(
  # The data used for token authentication.
  $input: TokenUserAccountAuthInput!
) {
  emailTokenUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Unsubscribes the user from one type of emails.
mutation emailUnsubscribe(
  # Unsubscription details.
  $input: EmailUnsubscribeInput!
) {
  emailUnsubscribe(input: $input) {
    ...EmailUnsubscribePayload
  }
}
# Finds or creates a new user account by email and sends an email with token.
mutation emailUserAccountAuthChallenge(
  # The data used for email authentication.
  $input: EmailUserAccountAuthChallengeInput!
) {
  emailUserAccountAuthChallenge(input: $input) {
    ...EmailUserAccountAuthChallengeResponse
  }
}
# Creates a custom emoji.
mutation createEmoji(
  # The emoji object to create.
  $input: EmojiCreateInput!
) {
  emojiCreate(input: $input) {
    ...EmojiPayload
  }
}
# Deletes an emoji.
mutation deleteEmoji(
  # The identifier of the emoji to delete.
  $id: String!
) {
  emojiDelete(id: $id) {
    ...ArchivePayload
  }
}
# [Deprecated] Creates a new event.
mutation createEvent(
  # The event to create.
  $input: EventCreateInput!
) {
  eventCreate(input: $input) {
    ...EventPayload
  }
}
# Creates a new favorite (project, cycle etc).
mutation createFavorite(
  # The favorite object to create.
  $input: FavoriteCreateInput!
) {
  favoriteCreate(input: $input) {
    ...FavoritePayload
  }
}
# Deletes a favorite reference.
mutation deleteFavorite(
  # The identifier of the favorite reference to delete.
  $id: String!
) {
  favoriteDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a favorite.
mutation updateFavorite(
  # The identifier of the favorite to update.
  $id: String!
  # A partial favorite object to update the favorite with.
  $input: FavoriteUpdateInput!
) {
  favoriteUpdate(id: $id, input: $input) {
    ...FavoritePayload
  }
}
# XHR request payload to upload an images, video and other attachments directly to Linear's cloud
# storage.
mutation fileUpload(
  # MIME type of the uploaded file.
  $contentType: String!
  # Filename of the uploaded file.
  $filename: String!
  # Should the file be made publicly accessible (default: false).
  $makePublic: Boolean
  # Optional metadata.
  $metaData: JSON
  # File size of the uploaded file.
  $size: Int!
) {
  fileUpload(
    contentType: $contentType
    filename: $filename
    makePublic: $makePublic
    metaData: $metaData
    size: $size
  ) {
    ...UploadPayload
  }
}
# Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
mutation googleUserAccountAuth(
  # The data used for Google authentication.
  $input: GoogleUserAccountAuthInput!
) {
  googleUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Upload an image from an URL to Linear.
mutation imageUploadFromUrl(
  # URL of the file to be uploaded to Linear.
  $url: String!
) {
  imageUploadFromUrl(url: $url) {
    ...ImageUploadFromUrlPayload
  }
}
# Deletes an integration.
mutation deleteIntegration(
  # The identifier of the integration to delete.
  $id: String!
) {
  integrationDelete(id: $id) {
    ...ArchivePayload
  }
}
# Integrates the organization with Discord.
mutation integrationDiscord(
  # The Discord OAuth code.
  $code: String!
  # The Discord OAuth redirect URI.
  $redirectUri: String!
) {
  integrationDiscord(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Figma.
mutation integrationFigma(
  # The Figma OAuth code.
  $code: String!
  # The Figma OAuth redirect URI.
  $redirectUri: String!
) {
  integrationFigma(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Front.
mutation integrationFront(
  # The Front OAuth code.
  $code: String!
  # The Front OAuth redirect URI.
  $redirectUri: String!
) {
  integrationFront(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Generates a webhook for the GitHub commit integration.
mutation createIntegrationGithubCommit {
  integrationGithubCommitCreate {
    ...GitHubCommitIntegrationPayload
  }
}
# Connects the organization with the GitHub App.
mutation integrationGithubConnect(
  # The GitHub data to connect with.
  $installationId: String!
) {
  integrationGithubConnect(installationId: $installationId) {
    ...IntegrationPayload
  }
}
# Connects the organization with a GitLab Access Token.
mutation integrationGitlabConnect(
  # The GitLab Access Token to connect with.
  $accessToken: String!
  # The URL of the GitLab installation
  $gitlabUrl: String!
) {
  integrationGitlabConnect(accessToken: $accessToken, gitlabUrl: $gitlabUrl) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Google Sheets.
mutation integrationGoogleSheets(
  # The Google OAuth code.
  $code: String!
) {
  integrationGoogleSheets(code: $code) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Intercom.
mutation integrationIntercom(
  # The Intercom OAuth code.
  $code: String!
  # The Intercom domain URL to use for the integration. Defaults to app.intercom.com if not provided.
  $domainUrl: String
  # The Intercom OAuth redirect URI.
  $redirectUri: String!
) {
  integrationIntercom(code: $code, domainUrl: $domainUrl, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Disconnects the organization from Intercom.
mutation deleteIntegrationIntercom {
  integrationIntercomDelete {
    ...IntegrationPayload
  }
}
# [DEPRECATED] Updates settings on the Intercom integration.
mutation updateIntegrationIntercomSettings(
  # A partial Intercom integration settings object to update the integration settings with.
  $input: IntercomSettingsInput!
) {
  integrationIntercomSettingsUpdate(input: $input) {
    ...IntegrationPayload
  }
}
# Enables Loom integration for the organization.
mutation integrationLoom {
  integrationLoom {
    ...IntegrationPayload
  }
}
# Requests a currently unavailable integration.
mutation integrationRequest(
  # Integration request details.
  $input: IntegrationRequestInput!
) {
  integrationRequest(input: $input) {
    ...IntegrationRequestPayload
  }
}
# Integrates the organization with Sentry.
mutation integrationSentryConnect(
  # The Sentry grant code that's exchanged for OAuth tokens.
  $code: String!
  # The Sentry installationId to connect with.
  $installationId: String!
  # The slug of the Sentry organization being connected.
  $organizationSlug: String!
) {
  integrationSentryConnect(code: $code, installationId: $installationId, organizationSlug: $organizationSlug) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Slack.
mutation integrationSlack(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
  $shouldUseV2Auth: Boolean
) {
  integrationSlack(code: $code, redirectUri: $redirectUri, shouldUseV2Auth: $shouldUseV2Auth) {
    ...IntegrationPayload
  }
}
# Imports custom emojis from your Slack workspace.
mutation integrationSlackImportEmojis(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackImportEmojis(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Slack integration for organization level project update notifications.
mutation integrationSlackOrgProjectUpdatesPost(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackOrgProjectUpdatesPost(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates your personal notifications with Slack.
mutation integrationSlackPersonal(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackPersonal(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Slack webhook integration.
mutation integrationSlackPost(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
  $shouldUseV2Auth: Boolean
  # Integration's associated team.
  $teamId: String!
) {
  integrationSlackPost(code: $code, redirectUri: $redirectUri, shouldUseV2Auth: $shouldUseV2Auth, teamId: $teamId) {
    ...IntegrationPayload
  }
}
# Slack integration for project notifications.
mutation integrationSlackProjectPost(
  # The Slack OAuth code.
  $code: String!
  # Integration's associated project.
  $projectId: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # The service to enable once connected, either 'notifications' or 'updates'.
  $service: String!
) {
  integrationSlackProjectPost(code: $code, projectId: $projectId, redirectUri: $redirectUri, service: $service) {
    ...IntegrationPayload
  }
}
# Creates a new integrationTemplate join.
mutation createIntegrationTemplate(
  # The properties of the integrationTemplate to create.
  $input: IntegrationTemplateCreateInput!
) {
  integrationTemplateCreate(input: $input) {
    ...IntegrationTemplatePayload
  }
}
# Deletes a integrationTemplate.
mutation deleteIntegrationTemplate(
  # The identifier of the integrationTemplate to delete.
  $id: String!
) {
  integrationTemplateDelete(id: $id) {
    ...ArchivePayload
  }
}
# Integrates the organization with Zendesk.
mutation integrationZendesk(
  # The Zendesk OAuth code.
  $code: String!
  # The Zendesk OAuth redirect URI.
  $redirectUri: String!
  # The Zendesk OAuth scopes.
  $scope: String!
  # The Zendesk installation subdomain.
  $subdomain: String!
) {
  integrationZendesk(code: $code, redirectUri: $redirectUri, scope: $scope, subdomain: $subdomain) {
    ...IntegrationPayload
  }
}
# Creates new settings for one or more integrations.
mutation createIntegrationsSettings(
  # The settings to create.
  $input: IntegrationsSettingsCreateInput!
) {
  integrationsSettingsCreate(input: $input) {
    ...IntegrationsSettingsPayload
  }
}
# Updates settings related to integrations for a project or a team.
mutation updateIntegrationsSettings(
  # The identifier of the settings to update.
  $id: String!
  # A settings object to update the settings with.
  $input: IntegrationsSettingsUpdateInput!
) {
  integrationsSettingsUpdate(id: $id, input: $input) {
    ...IntegrationsSettingsPayload
  }
}
# Archives an issue.
mutation archiveIssue(
  # The identifier of the issue to archive.
  $id: String!
  # Whether to trash the issue
  $trash: Boolean
) {
  issueArchive(id: $id, trash: $trash) {
    ...ArchivePayload
  }
}
# Updates multiple issues at once.
mutation updateIssueBatch(
  # The id's of the issues to update. Can't be more than 50 at a time.
  $ids: [UUID!]!
  # A partial issue object to update the issues with.
  $input: IssueUpdateInput!
) {
  issueBatchUpdate(ids: $ids, input: $input) {
    ...IssueBatchPayload
  }
}
# Creates a new issue.
mutation createIssue(
  # The issue object to create.
  $input: IssueCreateInput!
) {
  issueCreate(input: $input) {
    ...IssuePayload
  }
}
# Deletes (trashes) an issue.
mutation deleteIssue(
  # The identifier of the issue to delete.
  $id: String!
) {
  issueDelete(id: $id) {
    ...ArchivePayload
  }
}
# Kicks off an Asana import job.
mutation issueImportCreateAsana(
  # Asana team name to choose which issues we should import.
  $asanaTeamName: String!
  # Asana token to fetch information from the Asana API.
  $asanaToken: String!
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the organization into which to import data.
  $organizationId: String
  # ID of the team into which to import data.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateAsana(
    asanaTeamName: $asanaTeamName
    asanaToken: $asanaToken
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    organizationId: $organizationId
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Shortcut (formerly Clubhouse) import job.
mutation issueImportCreateClubhouse(
  # Shortcut (formerly Clubhouse) team name to choose which issues we should import.
  $clubhouseTeamName: String!
  # Shortcut (formerly Clubhouse) token to fetch information from the Clubhouse API.
  $clubhouseToken: String!
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the organization into which to import data.
  $organizationId: String
  # ID of the team into which to import data.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateClubhouse(
    clubhouseTeamName: $clubhouseTeamName
    clubhouseToken: $clubhouseToken
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    organizationId: $organizationId
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a GitHub import job.
mutation issueImportCreateGithub(
  # GitHub repository name from which we will import data.
  $githubRepoName: String!
  # GitHub owner (user or org) for the repository from which we will import data.
  $githubRepoOwner: String!
  # Whether or not we should import GitHub organization level projects.
  $githubShouldImportOrgProjects: Boolean
  # GitHub token to fetch information from the GitHub API.
  $githubToken: String!
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the organization into which to import data.
  $organizationId: String
  # ID of the team into which to import data.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateGithub(
    githubRepoName: $githubRepoName
    githubRepoOwner: $githubRepoOwner
    githubShouldImportOrgProjects: $githubShouldImportOrgProjects
    githubToken: $githubToken
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    organizationId: $organizationId
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Jira import job.
mutation issueImportCreateJira(
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # Jira user account email.
  $jiraEmail: String!
  # Jira installation or cloud hostname.
  $jiraHostname: String!
  # Jira project key from which we will import data.
  $jiraProject: String!
  # Jira personal access token to access Jira REST API.
  $jiraToken: String!
  # ID of the organization into which to import data.
  $organizationId: String
  # ID of the team into which to import data. Empty to create new team.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateJira(
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    jiraEmail: $jiraEmail
    jiraHostname: $jiraHostname
    jiraProject: $jiraProject
    jiraToken: $jiraToken
    organizationId: $organizationId
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Deletes an import job.
mutation deleteIssueImport(
  # ID of the issue import to delete.
  $issueImportId: String!
) {
  issueImportDelete(issueImportId: $issueImportId) {
    ...IssueImportDeletePayload
  }
}
# Kicks off import processing.
mutation issueImportProcess(
  # ID of the issue import which we're going to process.
  $issueImportId: String!
  # The mapping configuration to use for processing the import.
  $mapping: JSONObject!
) {
  issueImportProcess(issueImportId: $issueImportId, mapping: $mapping) {
    ...IssueImportPayload
  }
}
# Updates the mapping for the issue import.
mutation updateIssueImport(
  # The identifier of the issue import.
  $id: String!
  # The properties of the issue import to update.
  $input: IssueImportUpdateInput!
) {
  issueImportUpdate(id: $id, input: $input) {
    ...IssueImportPayload
  }
}
# Deletes an issue label.
mutation archiveIssueLabel(
  # The identifier of the label to archive.
  $id: String!
) {
  issueLabelArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new label.
mutation createIssueLabel(
  # The issue label to create.
  $input: IssueLabelCreateInput!
  # Whether to replace all team-specific labels with the same name with this newly created workspace label.
  $replaceTeamLabels: Boolean
) {
  issueLabelCreate(input: $input, replaceTeamLabels: $replaceTeamLabels) {
    ...IssueLabelPayload
  }
}
# Deletes an issue label.
mutation deleteIssueLabel(
  # The identifier of the label to delete.
  $id: String!
) {
  issueLabelDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an label.
mutation updateIssueLabel(
  # The identifier of the label to update.
  $id: String!
  # A partial label object to update.
  $input: IssueLabelUpdateInput!
) {
  issueLabelUpdate(id: $id, input: $input) {
    ...IssueLabelPayload
  }
}
# Creates a new issue relation.
mutation createIssueRelation(
  # The issue relation to create.
  $input: IssueRelationCreateInput!
) {
  issueRelationCreate(input: $input) {
    ...IssueRelationPayload
  }
}
# Deletes an issue relation.
mutation deleteIssueRelation(
  # The identifier of the issue relation to delete.
  $id: String!
) {
  issueRelationDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an issue relation.
mutation updateIssueRelation(
  # The identifier of the issue relation to update.
  $id: String!
  # The properties of the issue relation to update.
  $input: IssueRelationUpdateInput!
) {
  issueRelationUpdate(id: $id, input: $input) {
    ...IssueRelationPayload
  }
}
# Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is
# reached.
mutation issueReminder(
  # The identifier of the issue to add a reminder for.
  $id: String!
  # The time when a reminder notification will be sent.
  $reminderAt: DateTime!
) {
  issueReminder(id: $id, reminderAt: $reminderAt) {
    ...IssuePayload
  }
}
# Unarchives an issue.
mutation unarchiveIssue(
  # The identifier of the issue to archive.
  $id: String!
) {
  issueUnarchive(id: $id) {
    ...ArchivePayload
  }
}
# Updates an issue.
mutation updateIssue(
  # The identifier of the issue to update.
  $id: String!
  # A partial issue object to update the issue with.
  $input: IssueUpdateInput!
) {
  issueUpdate(id: $id, input: $input) {
    ...IssuePayload
  }
}
# Join an organization from onboarding.
mutation joinOrganizationFromOnboarding(
  # Organization details for the organization to join.
  $input: JoinOrganizationInput!
) {
  joinOrganizationFromOnboarding(input: $input) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Leave an organization.
mutation leaveOrganization(
  # ID of the organization to leave.
  $organizationId: String!
) {
  leaveOrganization(organizationId: $organizationId) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Logout of all clients.
mutation logout {
  logout {
    ...LogoutResponse
  }
}
# Archives a notification.
mutation archiveNotification(
  # The id of the notification to archive.
  $id: String!
) {
  notificationArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new notification subscription for a team or a project.
mutation createNotificationSubscription(
  # The subscription object to create.
  $input: NotificationSubscriptionCreateInput!
) {
  notificationSubscriptionCreate(input: $input) {
    ...NotificationSubscriptionPayload
  }
}
# Deletes a notification subscription reference.
mutation deleteNotificationSubscription(
  # The identifier of the notification subscription reference to delete.
  $id: String!
) {
  notificationSubscriptionDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a notification subscription.
mutation updateNotificationSubscription(
  # The identifier of the notification subscription to update.
  $id: String!
  # A partial notification subscription object to update the notification subscription with.
  $input: NotificationSubscriptionUpdateInput!
) {
  notificationSubscriptionUpdate(id: $id, input: $input) {
    ...NotificationSubscriptionPayload
  }
}
# Unarchives a notification.
mutation unarchiveNotification(
  # The id of the notification to archive.
  $id: String!
) {
  notificationUnarchive(id: $id) {
    ...ArchivePayload
  }
}
# Updates a notification.
mutation updateNotification(
  # The identifier of the notification to update.
  $id: String!
  # A partial notification object to update the notification with.
  $input: NotificationUpdateInput!
) {
  notificationUpdate(id: $id, input: $input) {
    ...NotificationPayload
  }
}
# Cancels the deletion of an organization. Administrator privileges required.
mutation deleteOrganizationCancel {
  organizationCancelDelete {
    ...OrganizationCancelDeletePayload
  }
}
# Delete's an organization. Administrator privileges required.
mutation deleteOrganization(
  # Information required to delete an organization.
  $input: DeleteOrganizationInput!
) {
  organizationDelete(input: $input) {
    ...OrganizationDeletePayload
  }
}
# Get an organization's delete confirmation token. Administrator privileges required.
mutation organizationDeleteChallenge {
  organizationDeleteChallenge {
    ...OrganizationDeletePayload
  }
}
# Deletes a domain.
mutation deleteOrganizationDomain(
  # The identifier of the domain to delete.
  $id: String!
) {
  organizationDomainDelete(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new organization invite.
mutation createOrganizationInvite(
  # The organization invite object to create.
  $input: OrganizationInviteCreateInput!
) {
  organizationInviteCreate(input: $input) {
    ...OrganizationInvitePayload
  }
}
# Deletes an organization invite.
mutation deleteOrganizationInvite(
  # The identifier of the organization invite to delete.
  $id: String!
) {
  organizationInviteDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an organization invite.
mutation updateOrganizationInvite(
  # The identifier of the organization invite to update.
  $id: String!
  # The updates to make to the organization invite object.
  $input: OrganizationInviteUpdateInput!
) {
  organizationInviteUpdate(id: $id, input: $input) {
    ...OrganizationInvitePayload
  }
}
# Updates the user's organization.
mutation updateOrganization(
  # A partial organization object to update the organization with.
  $input: UpdateOrganizationInput!
) {
  organizationUpdate(input: $input) {
    ...OrganizationPayload
  }
}
# Archives a project.
mutation archiveProject(
  # The identifier of the project to archive. Also the identifier from the URL is accepted.
  $id: String!
) {
  projectArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new project.
mutation createProject(
  # The issue object to create.
  $input: ProjectCreateInput!
) {
  projectCreate(input: $input) {
    ...ProjectPayload
  }
}
# Deletes a project. All issues will be disassociated from the deleted project.
mutation deleteProject(
  # The identifier of the project to delete. Also the identifier from the URL is accepted.
  $id: String!
) {
  projectDelete(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new project link.
mutation createProjectLink(
  # The project link object to create.
  $input: ProjectLinkCreateInput!
) {
  projectLinkCreate(input: $input) {
    ...ProjectLinkPayload
  }
}
# Deletes a project link.
mutation deleteProjectLink(
  # The identifier of the project link to delete.
  $id: String!
) {
  projectLinkDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a project link.
mutation updateProjectLink(
  # The identifier of the project link to update.
  $id: String!
  # The project link object to update.
  $input: ProjectLinkUpdateInput!
) {
  projectLinkUpdate(id: $id, input: $input) {
    ...ProjectLinkPayload
  }
}
# Creates a new project milestone.
mutation createProjectMilestone(
  # The project milestone to create.
  $input: ProjectMilestoneCreateInput!
) {
  projectMilestoneCreate(input: $input) {
    ...ProjectMilestonePayload
  }
}
# Deletes a project milestone.
mutation deleteProjectMilestone(
  # The identifier of the project milestone to delete.
  $id: String!
) {
  projectMilestoneDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a project milestone.
mutation updateProjectMilestone(
  # The identifier of the project milestone to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial object to update the project milestone with.
  $input: ProjectMilestoneUpdateInput!
) {
  projectMilestoneUpdate(id: $id, input: $input) {
    ...ProjectMilestonePayload
  }
}
# Unarchives a project.
mutation unarchiveProject(
  # The identifier of the project to restore. Also the identifier from the URL is accepted.
  $id: String!
) {
  projectUnarchive(id: $id) {
    ...ArchivePayload
  }
}
# Updates a project.
mutation updateProject(
  # The identifier of the project to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial project object to update the project with.
  $input: ProjectUpdateInput!
) {
  projectUpdate(id: $id, input: $input) {
    ...ProjectPayload
  }
}
# Creates a new project update.
mutation createProjectUpdate(
  # Data for the project update to create.
  $input: ProjectUpdateCreateInput!
) {
  projectUpdateCreate(input: $input) {
    ...ProjectUpdatePayload
  }
}
# Deletes a project update.
mutation deleteProjectUpdate(
  # The identifier of the project update to delete.
  $id: String!
) {
  projectUpdateDelete(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new interaction on a project update.
mutation createProjectUpdateInteraction(
  # Data for the project update interaction to create.
  $input: ProjectUpdateInteractionCreateInput!
) {
  projectUpdateInteractionCreate(input: $input) {
    ...ProjectUpdateInteractionPayload
  }
}
# Mark a project update as read.
mutation projectUpdateMarkAsRead(
  # The identifier of the project update.
  $id: String!
) {
  projectUpdateMarkAsRead(id: $id) {
    ...ProjectUpdateWithInteractionPayload
  }
}
# Updates a project update.
mutation updateProjectUpdate(
  # The identifier of the project update to update.
  $id: String!
  # A data to update the project update with.
  $input: ProjectUpdateUpdateInput!
) {
  projectUpdateUpdate(id: $id, input: $input) {
    ...ProjectUpdatePayload
  }
}
# Creates a push subscription.
mutation createPushSubscription(
  # The push subscription to create.
  $input: PushSubscriptionCreateInput!
) {
  pushSubscriptionCreate(input: $input) {
    ...PushSubscriptionPayload
  }
}
# Deletes a push subscription.
mutation deletePushSubscription(
  # The identifier of the push subscription to delete.
  $id: String!
) {
  pushSubscriptionDelete(id: $id) {
    ...PushSubscriptionPayload
  }
}
# Creates a new reaction.
mutation createReaction(
  # The reaction object to create.
  $input: ReactionCreateInput!
) {
  reactionCreate(input: $input) {
    ...ReactionPayload
  }
}
# Deletes a reaction.
mutation deleteReaction(
  # The identifier of the reaction to delete.
  $id: String!
) {
  reactionDelete(id: $id) {
    ...ArchivePayload
  }
}
# Manually update Google Sheets data.
mutation refreshGoogleSheetsData(
  # The identifier of the Google Sheets integration to update.
  $id: String!
) {
  refreshGoogleSheetsData(id: $id) {
    ...IntegrationPayload
  }
}
# Re-send an organization invite.
mutation resendOrganizationInvite(
  # The identifier of the organization invite to be re-send.
  $id: String!
) {
  resendOrganizationInvite(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new roadmap.
mutation createRoadmap(
  # The properties of the roadmap to create.
  $input: RoadmapCreateInput!
) {
  roadmapCreate(input: $input) {
    ...RoadmapPayload
  }
}
# Deletes a roadmap.
mutation deleteRoadmap(
  # The identifier of the roadmap to delete.
  $id: String!
) {
  roadmapDelete(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new roadmapToProject join.
mutation createRoadmapToProject(
  # The properties of the roadmapToProject to create.
  $input: RoadmapToProjectCreateInput!
) {
  roadmapToProjectCreate(input: $input) {
    ...RoadmapToProjectPayload
  }
}
# Deletes a roadmapToProject.
mutation deleteRoadmapToProject(
  # The identifier of the roadmapToProject to delete.
  $id: String!
) {
  roadmapToProjectDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a roadmapToProject.
mutation updateRoadmapToProject(
  # The identifier of the roadmapToProject to update.
  $id: String!
  # The properties of the roadmapToProject to update.
  $input: RoadmapToProjectUpdateInput!
) {
  roadmapToProjectUpdate(id: $id, input: $input) {
    ...RoadmapToProjectPayload
  }
}
# Updates a roadmap.
mutation updateRoadmap(
  # The identifier of the roadmap to update.
  $id: String!
  # The properties of the roadmap to update.
  $input: RoadmapUpdateInput!
) {
  roadmapUpdate(id: $id, input: $input) {
    ...RoadmapPayload
  }
}
# Authenticates a user account via email and authentication token for SAML.
mutation samlTokenUserAccountAuth(
  # The data used for token authentication.
  $input: TokenUserAccountAuthInput!
) {
  samlTokenUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Creates a new team. The user who creates the team will automatically be added as a member to the
# newly created team.
mutation createTeam(
  # The team id to copy settings from.
  $copySettingsFromTeamId: String
  # The team object to create.
  $input: TeamCreateInput!
) {
  teamCreate(copySettingsFromTeamId: $copySettingsFromTeamId, input: $input) {
    ...TeamPayload
  }
}
# Deletes team's cycles data
mutation deleteTeamCycles(
  # The identifier of the team, which cycles will be deleted.
  $id: String!
) {
  teamCyclesDelete(id: $id) {
    ...TeamPayload
  }
}
# Deletes a team.
mutation deleteTeam(
  # The identifier of the team to delete.
  $id: String!
) {
  teamDelete(id: $id) {
    ...ArchivePayload
  }
}
# Deletes a previously used team key.
mutation deleteTeamKey(
  # The identifier of the team key to delete.
  $id: String!
) {
  teamKeyDelete(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new team membership.
mutation createTeamMembership(
  # The team membership object to create.
  $input: TeamMembershipCreateInput!
) {
  teamMembershipCreate(input: $input) {
    ...TeamMembershipPayload
  }
}
# Deletes a team membership.
mutation deleteTeamMembership(
  # The identifier of the team membership to delete.
  $id: String!
) {
  teamMembershipDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a team membership.
mutation updateTeamMembership(
  # The identifier of the team membership to update.
  $id: String!
  # A partial team membership object to update the team membership with.
  $input: TeamMembershipUpdateInput!
) {
  teamMembershipUpdate(id: $id, input: $input) {
    ...TeamMembershipPayload
  }
}
# Updates a team.
mutation updateTeam(
  # The identifier of the team to update.
  $id: String!
  # A partial team object to update the team with.
  $input: TeamUpdateInput!
) {
  teamUpdate(id: $id, input: $input) {
    ...TeamPayload
  }
}
# Creates a new template.
mutation createTemplate(
  # The template object to create.
  $input: TemplateCreateInput!
) {
  templateCreate(input: $input) {
    ...TemplatePayload
  }
}
# Deletes a template.
mutation deleteTemplate(
  # The identifier of the template to delete.
  $id: String!
) {
  templateDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an existing template.
mutation updateTemplate(
  # The identifier of the template.
  $id: String!
  # The properties of the template to update.
  $input: TemplateUpdateInput!
) {
  templateUpdate(id: $id, input: $input) {
    ...TemplatePayload
  }
}
# Makes user a regular user. Can only be called by an admin.
mutation userDemoteAdmin(
  # The identifier of the user to make a regular user.
  $id: String!
) {
  userDemoteAdmin(id: $id) {
    ...UserAdminPayload
  }
}
# Makes user a guest. Can only be called by an admin.
mutation userDemoteMember(
  # The identifier of the user to make a guest.
  $id: String!
) {
  userDemoteMember(id: $id) {
    ...UserAdminPayload
  }
}
# Connects the Discord user to this Linear account via OAuth2.
mutation userDiscordConnect(
  # The Discord OAuth code.
  $code: String!
  # The Discord OAuth redirect URI.
  $redirectUri: String!
) {
  userDiscordConnect(code: $code, redirectUri: $redirectUri) {
    ...UserPayload
  }
}
# Disconnects the external user from this Linear account.
mutation userExternalUserDisconnect(
  # The external service to disconnect
  $service: String!
) {
  userExternalUserDisconnect(service: $service) {
    ...UserPayload
  }
}
# Updates a user's settings flag.
mutation updateUserFlag(
  # Settings flag to increment.
  $flag: UserFlagType!
  # Flag operation to perform
  $operation: UserFlagUpdateOperation!
) {
  userFlagUpdate(flag: $flag, operation: $operation) {
    ...UserSettingsFlagPayload
  }
}
# Connects the GitHub user to this Linear account via OAuth2.
mutation userGitHubConnect(
  # The GitHub OAuth code.
  $code: String!
) {
  userGitHubConnect(code: $code) {
    ...UserPayload
  }
}
# Connects the Google Calendar to the user to this Linear account via OAuth2.
mutation userGoogleCalendarConnect(
  # [Internal] The Google OAuth code.
  $code: String!
) {
  userGoogleCalendarConnect(code: $code) {
    ...UserPayload
  }
}
# Makes user an admin. Can only be called by an admin.
mutation userPromoteAdmin(
  # The identifier of the user to make an admin.
  $id: String!
) {
  userPromoteAdmin(id: $id) {
    ...UserAdminPayload
  }
}
# Makes user a regular user. Can only be called by an admin.
mutation userPromoteMember(
  # The identifier of the user to make a regular user.
  $id: String!
) {
  userPromoteMember(id: $id) {
    ...UserAdminPayload
  }
}
# [Deprecated] Updates a user's settings flag.
mutation userSettingsFlagIncrement(
  # Flag to increment.
  $flag: String!
) {
  userSettingsFlagIncrement(flag: $flag) {
    ...UserSettingsFlagPayload
  }
}
# Resets user's setting flags.
mutation userSettingsFlagsReset(
  # The flags to reset. If not provided all flags will be reset.
  $flags: [UserFlagType!]
) {
  userSettingsFlagsReset(flags: $flags) {
    ...UserSettingsFlagsResetPayload
  }
}
# Updates the user's settings.
mutation updateUserSettings(
  # The identifier of the userSettings to update.
  $id: String!
  # A partial notification object to update the settings with.
  $input: UserSettingsUpdateInput!
) {
  userSettingsUpdate(id: $id, input: $input) {
    ...UserSettingsPayload
  }
}
# Suspends a user. Can only be called by an admin.
mutation suspendUser(
  # The identifier of the user to suspend.
  $id: String!
) {
  userSuspend(id: $id) {
    ...UserAdminPayload
  }
}
# Un-suspends a user. Can only be called by an admin.
mutation unsuspendUser(
  # The identifier of the user to unsuspend.
  $id: String!
) {
  userUnsuspend(id: $id) {
    ...UserAdminPayload
  }
}
# Updates a user. Only available to organization admins and the user themselves.
mutation updateUser(
  # The identifier of the user to update. Use `me` to reference currently authenticated user.
  $id: String!
  # A partial user object to update the user with.
  $input: UpdateUserInput!
) {
  userUpdate(id: $id, input: $input) {
    ...UserPayload
  }
}
# Creates a new ViewPreferences object.
mutation createViewPreferences(
  # The ViewPreferences object to create.
  $input: ViewPreferencesCreateInput!
) {
  viewPreferencesCreate(input: $input) {
    ...ViewPreferencesPayload
  }
}
# Deletes a ViewPreferences.
mutation deleteViewPreferences(
  # The identifier of the ViewPreferences to delete.
  $id: String!
) {
  viewPreferencesDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an existing ViewPreferences object.
mutation updateViewPreferences(
  # The identifier of the ViewPreferences object.
  $id: String!
  # The properties of the view preferences.
  $input: ViewPreferencesUpdateInput!
) {
  viewPreferencesUpdate(id: $id, input: $input) {
    ...ViewPreferencesPayload
  }
}
# Creates a new webhook.
mutation createWebhook(
  # The webhook object to create.
  $input: WebhookCreateInput!
) {
  webhookCreate(input: $input) {
    ...WebhookPayload
  }
}
# Deletes a Webhook.
mutation deleteWebhook(
  # The identifier of the Webhook to delete.
  $id: String!
) {
  webhookDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an existing Webhook.
mutation updateWebhook(
  # The identifier of the Webhook.
  $id: String!
  # The properties of the Webhook.
  $input: WebhookUpdateInput!
) {
  webhookUpdate(id: $id, input: $input) {
    ...WebhookPayload
  }
}
# Archives a state. Only states with issues that have all been archived can be archived.
mutation archiveWorkflowState(
  # The identifier of the state to archive.
  $id: String!
) {
  workflowStateArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new state, adding it to the workflow of a team.
mutation createWorkflowState(
  # The state to create.
  $input: WorkflowStateCreateInput!
) {
  workflowStateCreate(input: $input) {
    ...WorkflowStatePayload
  }
}
# Updates a state.
mutation updateWorkflowState(
  # The identifier of the state to update.
  $id: String!
  # A partial state object to update.
  $input: WorkflowStateUpdateInput!
) {
  workflowStateUpdate(id: $id, input: $input) {
    ...WorkflowStatePayload
  }
}
# One specific project milestone.
query ProjectMilestone($id: String!) {
  ProjectMilestone(id: $id) {
    ...ProjectMilestone
  }
}
# All milestones for the project.
query ProjectMilestones(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  ProjectMilestones(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectMilestoneConnection
  }
}
# All teams you the user can administrate. Administrable teams are teams whose settings the user can
# change, but to whose issues the user doesn't necessarily have access to.
query administrableTeams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  administrableTeams(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamConnection
  }
}
# All API keys for the user.
query apiKeys(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  apiKeys(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ApiKeyConnection
  }
}
# Get basic information for an application.
query applicationInfo(
  # The client ID of the application.
  $clientId: String!
) {
  applicationInfo(clientId: $clientId) {
    ...Application
  }
}
# Get information for an application and whether a user has approved it for the given scopes.
query applicationWithAuthorization(
  # Actor mode used for the authorization.
  $actor: String
  # The client ID of the application.
  $clientId: String!
  # Redirect URI for the application.
  $redirectUri: String
  # Scopes being requested by the application
  $scope: [String!]!
) {
  applicationWithAuthorization(actor: $actor, clientId: $clientId, redirectUri: $redirectUri, scope: $scope) {
    ...UserAuthorizedApplication
  }
}
# One specific issue attachment.
# [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
query attachment($id: String!) {
  attachment(id: $id) {
    ...Attachment
  }
}
# Query an issue by its associated attachment, and its id.
query attachmentIssue(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
) {
  attachmentIssue(id: $id) {
    ...Issue
  }
}
# Attachments associated with the issue.
query attachmentIssue_attachments(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    attachments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# Children of the issue.
query attachmentIssue_children(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query attachmentIssue_comments(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query attachmentIssue_history(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query attachmentIssue_inverseRelations(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query attachmentIssue_labels(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Relations associated with this issue.
query attachmentIssue_relations(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query attachmentIssue_subscribers(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned subscribers.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    subscribers(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# All issue attachments.
#
# To get attachments for a given URL, use `attachmentsForURL` query.
query attachments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachments(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...AttachmentConnection
  }
}
# Returns issue attachments for a given `url`.
query attachmentsForURL(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # The attachment URL.
  $url: String!
) {
  attachmentsForURL(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
    url: $url
  ) {
    ...AttachmentConnection
  }
}
# All audit log entries.
query auditEntries(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned audit entries.
  $filter: AuditEntryFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  auditEntries(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...AuditEntryConnection
  }
}
# List of audit entry types.
query auditEntryTypes {
  auditEntryTypes {
    ...AuditEntryType
  }
}
# Fetch users belonging to this user account.
query availableUsers {
  availableUsers {
    ...AuthResolverResponse
  }
}
# A specific comment.
query comment(
  # The identifier of the comment to retrieve.
  $id: String!
) {
  comment(id: $id) {
    ...Comment
  }
}
# The children of the comment.
query comment_children(
  # The identifier of the comment to retrieve.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  comment(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# All comments.
query comments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  comments(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CommentConnection
  }
}
# One specific custom view.
query customView($id: String!) {
  customView(id: $id) {
    ...CustomView
  }
}
# Custom views for the user.
query customViews(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customViews(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CustomViewConnection
  }
}
# One specific cycle.
query cycle($id: String!) {
  cycle(id: $id) {
    ...Cycle
  }
}
# Issues associated with the cycle.
query cycle_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycle(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues that weren't completed when the cycle was closed.
query cycle_uncompletedIssuesUponClose(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycle(id: $id) {
    uncompletedIssuesUponClose(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All cycles.
query cycles(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: CycleFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycles(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CycleConnection
  }
}
# One specific document.
query document($id: String!) {
  document(id: $id) {
    ...Document
  }
}
# All documents for the project.
query documents(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  documents(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...DocumentConnection
  }
}
# A specific emoji.
query emoji(
  # The identifier of the emoji to retrieve.
  $id: String!
) {
  emoji(id: $id) {
    ...Emoji
  }
}
# All custom emojis.
query emojis(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  emojis(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...EmojiConnection
  }
}
# One specific favorite.
query favorite($id: String!) {
  favorite(id: $id) {
    ...Favorite
  }
}
# Children of the favorite. Only applies to favorites of type folder.
query favorite_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  favorite(id: $id) {
    children(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...FavoriteConnection
    }
  }
}
# The user's favorites.
query favorites(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  favorites(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...FavoriteConnection
  }
}
# Fetch Figma screenshot and other information with file and node identifiers.
query figmaEmbedInfo(
  # Figma file identifier.
  $fileId: String!
  # Figma node identifier.
  $nodeId: String
) {
  figmaEmbedInfo(fileId: $fileId, nodeId: $nodeId) {
    ...FigmaEmbedPayload
  }
}
# Figma embed information.
query figmaEmbedInfo_figmaEmbed(
  # Figma file identifier.
  $fileId: String!
  # Figma node identifier.
  $nodeId: String
) {
  figmaEmbedInfo(fileId: $fileId, nodeId: $nodeId) {
    figmaEmbed {
      ...FigmaEmbed
    }
  }
}
# One specific integration.
query integration($id: String!) {
  integration(id: $id) {
    ...Integration
  }
}
# One specific integrationTemplate.
query integrationTemplate($id: String!) {
  integrationTemplate(id: $id) {
    ...IntegrationTemplate
  }
}
# Template and integration connections.
query integrationTemplates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  integrationTemplates(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IntegrationTemplateConnection
  }
}
# All integrations.
query integrations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  integrations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IntegrationConnection
  }
}
# One specific set of settings.
query integrationsSettings($id: String!) {
  integrationsSettings(id: $id) {
    ...IntegrationsSettings
  }
}
# One specific issue.
query issue($id: String!) {
  issue(id: $id) {
    ...Issue
  }
}
# Attachments associated with the issue.
query issue_attachments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    attachments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# Children of the issue.
query issue_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query issue_comments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query issue_history(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query issue_inverseRelations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query issue_labels(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Relations associated with this issue.
query issue_relations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query issue_subscribers(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned subscribers.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    subscribers(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Fetches the GitHub token, completing the OAuth flow.
query issueImportFinishGithubOAuth(
  # OAuth code.
  $code: String!
) {
  issueImportFinishGithubOAuth(code: $code) {
    ...GithubOAuthTokenPayload
  }
}
# One specific label.
query issueLabel($id: String!) {
  issueLabel(id: $id) {
    ...IssueLabel
  }
}
# Children of the label.
query issueLabel_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabel(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Issues associated with the label.
query issueLabel_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabel(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All issue labels.
query issueLabels(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabels(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueLabelConnection
  }
}
# Issue priority values and corresponding labels.
query issuePriorityValues {
  issuePriorityValues {
    ...IssuePriorityValue
  }
}
# One specific issue relation.
query issueRelation($id: String!) {
  issueRelation(id: $id) {
    ...IssueRelation
  }
}
# All issue relationships.
query issueRelations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueRelations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueRelationConnection
  }
}
# Find issue based on the VCS branch name.
query issueVcsBranchSearch(
  # The VCS branch name to search for.
  $branchName: String!
) {
  issueVcsBranchSearch(branchName: $branchName) {
    ...Issue
  }
}
# Attachments associated with the issue.
query issueVcsBranchSearch_attachments(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    attachments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# Children of the issue.
query issueVcsBranchSearch_children(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query issueVcsBranchSearch_comments(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query issueVcsBranchSearch_history(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query issueVcsBranchSearch_inverseRelations(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query issueVcsBranchSearch_labels(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Relations associated with this issue.
query issueVcsBranchSearch_relations(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query issueVcsBranchSearch_subscribers(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned subscribers.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    subscribers(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# All issues.
query issues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issues(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueConnection
  }
}
# One specific notification.
query notification($id: String!) {
  notification(id: $id) {
    ...Notification
  }
}
# One specific notification subscription.
query notificationSubscription($id: String!) {
  notificationSubscription(id: $id) {
    ...NotificationSubscription
  }
}
# The user's notification subscriptions.
query notificationSubscriptions(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  notificationSubscriptions(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...NotificationSubscriptionConnection
  }
}
# All notifications.
query notifications(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  notifications(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...NotificationConnection
  }
}
# The user's organization.
query organization {
  organization {
    ...Organization
  }
}
# Integrations associated with the organization.
query organization_integrations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    integrations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IntegrationConnection
    }
  }
}
# Labels associated with the organization.
query organization_labels(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# The organization's subscription to a paid plan.
query organization_subscription {
  organization {
    subscription {
      ...PaidSubscription
    }
  }
}
# Teams associated with the organization.
query organization_teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# Templates associated with the organization.
query organization_templates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    templates(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TemplateConnection
    }
  }
}
# Users associated with the organization.
query organization_users(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    users(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Does the organization exist.
query organizationExists($urlKey: String!) {
  organizationExists(urlKey: $urlKey) {
    ...OrganizationExistsPayload
  }
}
# One specific organization invite.
query organizationInvite($id: String!) {
  organizationInvite(id: $id) {
    ...OrganizationInvite
  }
}
# One specific organization invite.
query organizationInviteDetails($id: String!) {
  organizationInviteDetails(id: $id) {
    ...OrganizationInviteDetailsPayload
  }
}
# All invites for the organization.
query organizationInvites(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organizationInvites(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...OrganizationInviteConnection
  }
}
# One specific project.
query project($id: String!) {
  project(id: $id) {
    ...Project
  }
}
# Documents associated with the project.
query project_documents(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    documents(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...DocumentConnection
    }
  }
}
# Issues associated with the project.
query project_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Links associated with the project.
query project_links(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    links(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectLinkConnection
    }
  }
}
# Users that are members of the project.
query project_members(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    members(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Project updates associated with the project.
query project_projectUpdates(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    projectUpdates(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectUpdateConnection
    }
  }
}
# Teams associated with this project.
query project_teams(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# One specific project link.
query projectLink($id: String!) {
  projectLink(id: $id) {
    ...ProjectLink
  }
}
# All links for the project.
query projectLinks(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectLinks(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectLinkConnection
  }
}
# A specific project update.
query projectUpdate(
  # The identifier of the project update to retrieve.
  $id: String!
) {
  projectUpdate(id: $id) {
    ...ProjectUpdate
  }
}
# A specific interaction on a project update.
query projectUpdateInteraction(
  # The identifier of the project update interaction to retrieve.
  $id: String!
) {
  projectUpdateInteraction(id: $id) {
    ...ProjectUpdateInteraction
  }
}
# All interactions on project updates.
query projectUpdateInteractions(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectUpdateInteractions(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectUpdateInteractionConnection
  }
}
# All project updates.
query projectUpdates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectUpdates(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectUpdateConnection
  }
}
# All projects.
query projects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projects(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectConnection
  }
}
# Sends a test push message.
query pushSubscriptionTest {
  pushSubscriptionTest {
    ...PushSubscriptionTestPayload
  }
}
# The status of the rate limiter.
query rateLimitStatus {
  rateLimitStatus {
    ...RateLimitPayload
  }
}
# One specific roadmap.
query roadmap($id: String!) {
  roadmap(id: $id) {
    ...Roadmap
  }
}
# Projects associated with the roadmap.
query roadmap_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  roadmap(id: $id) {
    projects(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# One specific roadmapToProject.
query roadmapToProject($id: String!) {
  roadmapToProject(id: $id) {
    ...RoadmapToProject
  }
}
# Custom views for the user.
query roadmapToProjects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  roadmapToProjects(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...RoadmapToProjectConnection
  }
}
# All roadmaps in the workspace.
query roadmaps(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  roadmaps(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...RoadmapConnection
  }
}
# Fetch SSO login URL for the email provided.
query ssoUrlFromEmail(
  # Email to query the SSO login URL by.
  $email: String!
  # Whether the client is the desktop app.
  $isDesktop: Boolean
) {
  ssoUrlFromEmail(email: $email, isDesktop: $isDesktop) {
    ...SsoUrlFromEmailResponse
  }
}
# One specific team.
query team($id: String!) {
  team(id: $id) {
    ...Team
  }
}
# Cycles associated with the team.
query team_cycles(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned cycles.
  $filter: CycleFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    cycles(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CycleConnection
    }
  }
}
# Issues associated with the team.
query team_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Labels associated with the team.
query team_labels(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Users who are members of this team.
query team_members(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    members(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Memberships associated with the team. For easier access of the same data, use `members` query.
query team_memberships(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    memberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Projects associated with the team.
query team_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    projects(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# The states that define the workflow associated with the team.
query team_states(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned workflow states.
  $filter: WorkflowStateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    states(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...WorkflowStateConnection
    }
  }
}
# Templates associated with the team.
query team_templates(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    templates(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TemplateConnection
    }
  }
}
# Webhooks associated with the team.
query team_webhooks(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    webhooks(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...WebhookConnection
    }
  }
}
# One specific team membership.
query teamMembership($id: String!) {
  teamMembership(id: $id) {
    ...TeamMembership
  }
}
# All team memberships.
query teamMemberships(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  teamMemberships(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamMembershipConnection
  }
}
# All teams whose issues can be accessed by the user. This might be different from
# `administrableTeams`, which also includes teams whose settings can be changed by the user.
query teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  teams(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamConnection
  }
}
# A specific template.
query template(
  # The identifier of the template to retrieve.
  $id: String!
) {
  template(id: $id) {
    ...Template
  }
}
# All templates from all users.
query templates {
  templates {
    ...Template
  }
}
# One specific user.
query user(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
) {
  user(id: $id) {
    ...User
  }
}
# Issues assigned to the user.
query user_assignedIssues(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    assignedIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues created by the user.
query user_createdIssues(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    createdIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Memberships associated with the user. For easier access of the same data, use `teams` query.
query user_teamMemberships(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    teamMemberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Teams the user is part of.
query user_teams(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# The user's settings.
query userSettings {
  userSettings {
    ...UserSettings
  }
}
# All users for the organization.
query users(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  users(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    includeDisabled: $includeDisabled
    last: $last
    orderBy: $orderBy
  ) {
    ...UserConnection
  }
}
# The currently authenticated user.
query viewer {
  viewer {
    ...User
  }
}
# Issues assigned to the user.
query viewer_assignedIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    assignedIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues created by the user.
query viewer_createdIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    createdIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Memberships associated with the user. For easier access of the same data, use `teams` query.
query viewer_teamMemberships(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    teamMemberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Teams the user is part of.
query viewer_teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# A specific webhook.
query webhook(
  # The identifier of the webhook to retrieve.
  $id: String!
) {
  webhook(id: $id) {
    ...Webhook
  }
}
# All webhooks.
query webhooks(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  webhooks(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...WebhookConnection
  }
}
# One specific state.
query workflowState($id: String!) {
  workflowState(id: $id) {
    ...WorkflowState
  }
}
# Issues belonging in this state.
query workflowState_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  workflowState(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All issue workflow states.
query workflowStates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned workflow states.
  $filter: WorkflowStateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  workflowStates(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...WorkflowStateConnection
  }
}
