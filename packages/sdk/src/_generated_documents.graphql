# A Git target branch for which there are automations (GitAutomationState).
fragment GitAutomationTargetBranch on GitAutomationTargetBranch {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The target branch pattern.
  branchPattern
  # The team to which this Git target branch automation belongs.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # Whether the branch pattern is a regular expression.
  isRegex
}

# A basic entity.
fragment Entity on Entity {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A bot actor is an actor that is not a user, but an application or integration.
fragment ActorBot on ActorBot {
  __typename
  # A url pointing to the avatar representing this bot.
  avatarUrl
  # The display name of the bot.
  name
  # The display name of the external user on behalf of which the bot acted.
  userDisplayName
  # The sub type of the bot.
  subType
  # The type of bot.
  type
  id
}

# A comment associated with an issue.
fragment Comment on Comment {
  __typename
  # Comment's URL.
  url
  # Emoji reaction summary, grouped by emoji type.
  reactionData
  # Reactions associated with the comment.
  reactions {
    ...Reaction
  }
  # The bot that created the comment.
  botActor {
    ...ActorBot
  }
  # The comment content in markdown format.
  body
  # The comment that resolved the thread.
  resolvingComment {
    id
  }
  # The document content that the comment is associated with.
  documentContent {
    ...DocumentContent
  }
  # The external thread that the comment is synced with.
  externalThread {
    ...SyncedExternalThread
  }
  # The external user who wrote the comment.
  externalUser {
    id
  }
  # The initiative update that the comment is associated with.
  initiativeUpdate {
    id
  }
  # The issue that the comment is associated with.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The parent comment under which the current comment is nested.
  parent {
    id
  }
  # The project update that the comment is associated with.
  projectUpdate {
    id
  }
  # The text that this comment references. Only defined for inline comments.
  quotedText
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time the resolvingUser resolved the thread.
  resolvedAt
  # The time user edited the comment.
  editedAt
  # The unique identifier of the entity.
  id
  # The user that resolved the thread.
  resolvingUser {
    id
  }
  # The user who wrote the comment.
  user {
    id
  }
}

# A comment thread that is synced with an external source.
fragment SyncedExternalThread on SyncedExternalThread {
  __typename
  # The display name of the source.
  name
  # The display name of the thread.
  displayName
  # The external url of the thread.
  url
  # The sub type of the external source.
  subType
  # The type of the external source.
  type
  # Whether a connected personal integration is required to comment in this thread.
  isPersonalIntegrationRequired
  # Whether the current user has the corresponding personal integration connected for the external service.
  isPersonalIntegrationConnected
  # Whether this thread is syncing with the external service.
  isConnected
  id
}

# A custom emoji.
fragment Emoji on Emoji {
  __typename
  # The emoji image URL.
  url
  # The emoji's name.
  name
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The source of the emoji.
  source
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the emoji.
  creator {
    id
  }
}

# A custom view notification subscription.
fragment CustomViewNotificationSubscription on CustomViewNotificationSubscription {
  __typename
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The custom view subscribed to.
  customView {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A custom view that has been saved by a user.
fragment CustomView on CustomView {
  __typename
  # The calculated view preferences values for this custom view.
  viewPreferencesValues {
    ...ViewPreferencesValues
  }
  # The color of the icon of the custom view.
  color
  # The current users view preferences for this custom view.
  userViewPreferences {
    ...ViewPreferences
  }
  # The custom view's unique URL slug.
  slugId
  # The description of the custom view.
  description
  # The filter applied to issues in the custom view.
  filterData
  # The filter applied to projects in the custom view.
  projectFilterData
  # The filters applied to issues in the custom view.
  filters
  # The icon of the custom view.
  icon
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The model name of the custom view.
  modelName
  # The name of the custom view.
  name
  # The organizations default view preferences for this custom view.
  organizationViewPreferences {
    ...ViewPreferences
  }
  # The team associated with the custom view.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the custom view.
  creator {
    id
  }
  # The user who last updated the custom view.
  updatedBy {
    id
  }
  # The user who owns the custom view.
  owner {
    id
  }
  # Whether the custom view is shared with everyone in the organization.
  shared
}

# A customer need, expressed through a reference to an issue, project, or comment.
fragment CustomerNeed on CustomerNeed {
  __typename
  # The URL of the underlying attachment, if any
  url
  # The attachment this need is referencing.
  attachment {
    id
  }
  # The comment this need is referencing.
  comment {
    id
  }
  # The creator of the customer need.
  creator {
    id
  }
  # The customer that this need is attached to.
  customer {
    id
  }
  # The issue this need is referencing.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The need content in markdown format.
  body
  # The project this need is referencing.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # Whether the customer need is important or not. 0 = Not important, 1 = Important.
  priority
}

# A customer notification subscription.
fragment CustomerNotificationSubscription on CustomerNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer subscribed to.
  customer {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A customer status.
fragment CustomerStatus on CustomerStatus {
  __typename
  # Description of the status.
  description
  # The UI color of the status as a HEX string.
  color
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the status.
  name
  # The position of the status in the workspace's customers flow.
  position
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the customer status.
  type
  # The unique identifier of the entity.
  id
}

# A customer tier.
fragment CustomerTier on CustomerTier {
  __typename
  # Description of the tier.
  description
  # The UI color of the tier as a HEX string.
  color
  # The display name of the tier.
  displayName
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the tier.
  name
  # The position of the tier in the workspace's customers flow.
  position
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A customer whose needs will be tied to issues or projects.
fragment Customer on Customer {
  __typename
  # The ID of the Slack channel used to interact with the customer.
  slackChannelId
  # The annual revenue generated by the customer.
  revenue
  # The approximate number of needs of the customer.
  approximateNeedCount
  # The current status of the customer.
  status {
    id
  }
  # The customer's logo URL.
  logoUrl
  # The customer's name.
  name
  # The customer's unique URL slug.
  slugId
  # The domains associated with this customer.
  domains
  # The ids of the customers in external systems.
  externalIds
  # The integration that manages the Customer.
  integration {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The size of the customer.
  size
  # The tier of the customer.
  tier {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who owns the customer.
  owner {
    id
  }
}

# A cycle notification subscription.
fragment CycleNotificationSubscription on CycleNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The cycle subscribed to.
  cycle {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A document content for a project.
fragment DocumentContent on DocumentContent {
  __typename
  # The document content in markdown format.
  content
  # The document content state as a base64 encoded string.
  contentState
  # The document that the content is associated with.
  document {
    id
  }
  # The initiative that the content is associated with.
  initiative {
    id
  }
  # The issue that the content is associated with.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project milestone that the content is associated with.
  projectMilestone {
    id
  }
  # The project that the content is associated with.
  project {
    id
  }
  # The time at which the document content was restored from a previous version.
  restoredAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A document related notification.
fragment DocumentNotification on DocumentNotification {
  __typename
  # Name of the reaction emoji related to the notification.
  reactionEmoji
  # Notification type.
  type
  # Related comment ID. Null if the notification is not related to a comment.
  commentId
  # Related document ID.
  documentId
  # Related parent comment ID. Null if the notification is not related to a comment.
  parentCommentId
  # The bot that caused the notification.
  botActor {
    ...ActorBot
  }
  # The external user that caused the notification.
  externalUserActor {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# A document that can be attached to different entities.
fragment Document on Document {
  __typename
  # A flag that indicates whether the document is in the trash bin.
  trashed
  # The ID of the document content associated with the document.
  documentContentId
  # The canonical url for the document.
  url
  # The color of the icon.
  color
  # The document title.
  title
  # The document's unique URL slug.
  slugId
  # The documents content in markdown format.
  content
  # The icon of the document.
  icon
  # The initiative that the document is associated with.
  initiative {
    id
  }
  # The last template that was applied to this document.
  lastAppliedTemplate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in the resources list.
  sortOrder
  # The project that the document is associated with.
  project {
    id
  }
  # The time at which the document was hidden. Null if the entity has not been hidden.
  hiddenAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the document.
  creator {
    id
  }
  # The user who last updated the document.
  updatedBy {
    id
  }
}

# A facet. Facets are joins between entities. A facet can tie a custom view to a project, or a a
# project to a roadmap for example.
fragment Facet on Facet {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The owning initiative.
  sourceInitiative {
    id
  }
  # The owning page.
  sourcePage
  # The owning project.
  sourceProject {
    id
  }
  # The owning team.
  sourceTeam {
    id
  }
  # The sort order of the facet.
  sortOrder
  # The targeted custom view.
  targetCustomView {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A general purpose draft. Used for comments, project updates, etc.
fragment Draft on Draft {
  __typename
  # Additional properties for the draft.
  data
  # The comment for which this is a draft comment reply.
  parentComment {
    id
  }
  # The customer need that this draft is referencing.
  customerNeed {
    id
  }
  # The initiative for which this is a draft initiative update.
  initiative {
    id
  }
  # The initiative update for which this is a draft comment.
  initiativeUpdate {
    id
  }
  # The issue for which this is a draft comment.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project for which this is a draft project update.
  project {
    id
  }
  # The project update for which this is a draft comment.
  projectUpdate {
    id
  }
  # The text content as a Prosemirror document.
  bodyData
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the draft.
  user {
    id
  }
  # Whether the draft was autogenerated for the user.
  isAutogenerated
}

# A generic payload return from entity archive mutations.
fragment CustomerNeedArchivePayload on CustomerNeedArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment CycleArchivePayload on CycleArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment DocumentArchivePayload on DocumentArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment InitiativeArchivePayload on InitiativeArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment InitiativeUpdateArchivePayload on InitiativeUpdateArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment IssueArchivePayload on IssueArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment NotificationArchivePayload on NotificationArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    ...Notification
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment ProjectArchivePayload on ProjectArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment ProjectStatusArchivePayload on ProjectStatusArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment ProjectUpdateArchivePayload on ProjectUpdateArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment RoadmapArchivePayload on RoadmapArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment TeamArchivePayload on TeamArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive mutations.
fragment WorkflowStateArchivePayload on WorkflowStateArchivePayload {
  __typename
  # The archived/unarchived entity. Null if entity was deleted.
  entity {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A generic payload return from entity archive or deletion mutations.
fragment ArchivePayload on ArchivePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success

  ... on CustomerNeedArchivePayload {
    ...CustomerNeedArchivePayload
  }

  ... on CycleArchivePayload {
    ...CycleArchivePayload
  }

  ... on DeletePayload {
    ...DeletePayload
  }

  ... on DocumentArchivePayload {
    ...DocumentArchivePayload
  }

  ... on InitiativeArchivePayload {
    ...InitiativeArchivePayload
  }

  ... on InitiativeUpdateArchivePayload {
    ...InitiativeUpdateArchivePayload
  }

  ... on IssueArchivePayload {
    ...IssueArchivePayload
  }

  ... on NotificationArchivePayload {
    ...NotificationArchivePayload
  }

  ... on ProjectArchivePayload {
    ...ProjectArchivePayload
  }

  ... on ProjectStatusArchivePayload {
    ...ProjectStatusArchivePayload
  }

  ... on ProjectUpdateArchivePayload {
    ...ProjectUpdateArchivePayload
  }

  ... on RoadmapArchivePayload {
    ...RoadmapArchivePayload
  }

  ... on TeamArchivePayload {
    ...TeamArchivePayload
  }

  ... on WorkflowStateArchivePayload {
    ...WorkflowStateArchivePayload
  }
}

# A generic payload return from entity deletion mutations.
fragment DeletePayload on DeletePayload {
  __typename
  # The identifier of the deleted entity.
  entityId
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

# A initiative history containing relevant change events.
fragment InitiativeHistory on InitiativeHistory {
  __typename
  # The events that happened while recording that history.
  entries
  # The initiative that the history is associated with.
  initiative {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A label notification subscription.
fragment LabelNotificationSubscription on LabelNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The label subscribed to.
  label {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A meeting that can be attached to different entities.
fragment Meeting on Meeting {
  __typename
  # A flag that indicates whether the meeting is in the trash bin.
  trashed
  # Link to a recording of the meeting.
  recordingLink
  # The color of the icon.
  color
  # The icon of the meeting.
  icon
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The location of the meeting.
  location
  # The meeting link of the meeting.
  meetingLink
  # The meeting title.
  title
  # The order of the item in the resources list.
  sortOrder
  # The project that the meeting is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the meeting is set to end.
  endsAt
  # The time at which the meeting is set to start.
  startsAt
  # The time at which the meeting was hidden. Null if the entity has not been hidden.
  hiddenAt
  # The unique identifier of the entity.
  id
  # The user who created the meeting.
  creator {
    id
  }
  # The user who last updated the meeting.
  updatedBy {
    id
  }
}

# A milestone for a project.
fragment ProjectMilestone on ProjectMilestone {
  __typename
  # The content of the project milestone description.
  documentContent {
    ...DocumentContent
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the project milestone.
  name
  # The order of the milestone in relation to other milestones within a project.
  sortOrder
  # The planned completion date of the milestone.
  targetDate
  # The progress % of the project milestone.
  progress
  # The project milestone's description in markdown format.
  description
  # The project of the milestone.
  project {
    id
  }
  # The status of the project milestone.
  status
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A notification sent to a user.
fragment Notification on Notification {
  __typename
  # Notification type.
  type
  # The bot that caused the notification.
  botActor {
    ...ActorBot
  }
  # The external user that caused the notification.
  externalUserActor {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }

  ... on DocumentNotification {
    ...DocumentNotification
  }

  ... on InitiativeNotification {
    ...InitiativeNotification
  }

  ... on IssueNotification {
    ...IssueNotification
  }

  ... on OauthClientApprovalNotification {
    ...OauthClientApprovalNotification
  }

  ... on ProjectNotification {
    ...ProjectNotification
  }
}

# A project notification subscription.
fragment ProjectNotificationSubscription on ProjectNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project subscribed to.
  project {
    id
  }
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A project related notification.
fragment ProjectNotification on ProjectNotification {
  __typename
  # Name of the reaction emoji related to the notification.
  reactionEmoji
  # Notification type.
  type
  # Related comment ID. Null if the notification is not related to a comment.
  commentId
  # Related parent comment ID. Null if the notification is not related to a comment.
  parentCommentId
  # Related project ID.
  projectId
  # Related project milestone ID.
  projectMilestoneId
  # Related project update ID.
  projectUpdateId
  # The bot that caused the notification.
  botActor {
    ...ActorBot
  }
  # The comment related to the notification.
  comment {
    id
  }
  # The document related to the notification.
  document {
    id
  }
  # The external user that caused the notification.
  externalUserActor {
    id
  }
  # The initiative related to the notification.
  initiative {
    id
  }
  # The initiative update related to the notification.
  initiativeUpdate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The parent comment related to the notification, if a notification is a reply comment notification.
  parentComment {
    id
  }
  # The project related to the notification.
  project {
    id
  }
  # The project update related to the notification.
  projectUpdate {
    id
  }
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# A project status.
fragment ProjectStatus on ProjectStatus {
  __typename
  # Description of the status.
  description
  # The UI color of the status as a HEX string.
  color
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the status.
  name
  # The position of the status in the workspace's project flow.
  position
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the project status.
  type
  # The unique identifier of the entity.
  id
  # Whether or not a project can be in this status indefinitely.
  indefinite
}

# A project.
fragment Project on Project {
  __typename
  # A flag that indicates whether the project is in the trash bin.
  trashed
  # Id of the labels associated with this project.
  labelIds
  # Project URL.
  url
  # Settings for all integrations associated with that project.
  integrationsSettings {
    id
  }
  # The content of the project description.
  documentContent {
    ...DocumentContent
  }
  # The day at which to prompt for updates.
  updateRemindersDay
  # The estimated completion date of the project.
  targetDate
  # The estimated start date of the project.
  startDate
  # The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  updateReminderFrequency
  # The health of the project.
  health
  # The hour at which to prompt for updates.
  updateRemindersHour
  # The icon of the project.
  icon
  # The last project update posted for this project.
  lastUpdate {
    id
  }
  # The last template that was applied to this project.
  lastAppliedTemplate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  updateReminderFrequencyInWeeks
  # The number of completed estimation points after each week.
  completedScopeHistory
  # The number of completed issues in the project after each week.
  completedIssueCountHistory
  # The number of in progress estimation points after each week.
  inProgressScopeHistory
  # The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  progress
  # The overall scope (total estimate points) of the project.
  scope
  # The priority of the project as a label.
  priorityLabel
  # The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  priority
  # The project lead.
  lead {
    id
  }
  # The project was created based on this issue.
  convertedFromIssue {
    id
  }
  # The project's color.
  color
  # The project's content in markdown format.
  content
  # The project's description.
  description
  # The project's name.
  name
  # The project's unique URL slug.
  slugId
  # The resolution of the project's estimated completion date.
  targetDateResolution
  # The resolution of the project's start date.
  startDateResolution
  # The resolution of the reminder frequency.
  frequencyResolution
  # The sort order for the project within the organization, when ordered by priority.
  prioritySortOrder
  # The sort order for the project within the organization.
  sortOrder
  # The status that the project is associated with.
  status {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the project health was updated.
  healthUpdatedAt
  # The time at which the project was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the project was moved into canceled state.
  canceledAt
  # The time at which the project was moved into completed state.
  completedAt
  # The time at which the project was moved into started state.
  startedAt
  # The time until which project update reminders are paused.
  projectUpdateRemindersPausedUntilAt
  # The total number of estimation points after each week.
  scopeHistory
  # The total number of issues in the project after each week.
  issueCountHistory
  # The unique identifier of the entity.
  id
  # The user who created the project.
  creator {
    id
  }
  # The user's favorite associated with this project.
  favorite {
    id
  }
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
  # [DEPRECATED] The type of the state.
  state
}

# A reaction associated with a comment or a project update.
fragment Reaction on Reaction {
  __typename
  # Name of the reaction's emoji.
  emoji
  # The comment that the reaction is associated with.
  comment {
    id
  }
  # The external user that created the reaction.
  externalUser {
    id
  }
  # The initiative update that the reaction is associated with.
  initiativeUpdate {
    id
  }
  # The issue that the reaction is associated with.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project update that the reaction is associated with.
  projectUpdate {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that created the reaction.
  user {
    id
  }
}

# A record of changes to an issue.
fragment IssueHistory on IssueHistory {
  __typename
  # Changed issue relationships.
  relationChanges {
    ...IssueRelationHistoryPayload
  }
  # ID's of labels that were added.
  addedLabelIds
  # ID's of labels that were removed.
  removedLabelIds
  # The actor that performed the actions. This field may be empty in the case of integrations or automations.
  actor {
    id
  }
  # The actors that edited the description of the issue, if any.
  descriptionUpdatedBy {
    ...User
  }
  # The actors that performed the actions. This field may be empty in the case of integrations or automations.
  actors {
    ...User
  }
  # The bot that performed the action.
  botActor {
    ...ActorBot
  }
  # The cycle that the issue was moved from.
  fromCycle {
    id
  }
  # The cycle that the issue was moved to.
  toCycle {
    id
  }
  # The id of linked attachment.
  attachmentId
  # The id of linked customer need.
  customerNeedId
  # The id of new cycle of the issue.
  toCycleId
  # The id of new parent of the issue.
  toParentId
  # The id of new project created from the issue.
  toConvertedProjectId
  # The id of new project of the issue.
  toProjectId
  # The id of new workflow state of the issue.
  toStateId
  # The id of previous cycle of the issue.
  fromCycleId
  # The id of previous parent of the issue.
  fromParentId
  # The id of previous project of the issue.
  fromProjectId
  # The id of previous workflow state of the issue.
  fromStateId
  # The id of team from which the issue was moved from.
  fromTeamId
  # The id of team to which the issue was moved to.
  toTeamId
  # The id of user from whom the issue was re-assigned from.
  fromAssigneeId
  # The id of user to whom the issue was assigned to.
  toAssigneeId
  # The id of user who made these changes. If null, possibly means that the change made by an integration.
  actorId
  # The import record.
  issueImport {
    ...IssueImport
  }
  # The issue that was changed.
  issue {
    id
  }
  # The labels that were added to the issue.
  addedLabels {
    ...IssueLabel
  }
  # The labels that were removed from the issue.
  removedLabels {
    ...IssueLabel
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The linked attachment.
  attachment {
    id
  }
  # The new project created from the issue.
  toConvertedProject {
    id
  }
  # The parent issue that the issue was moved from.
  fromParent {
    id
  }
  # The parent issue that the issue was moved to.
  toParent {
    id
  }
  # The project that the issue was moved from.
  fromProject {
    id
  }
  # The project that the issue was moved to.
  toProject {
    id
  }
  # The state that the issue was moved from.
  fromState {
    id
  }
  # The state that the issue was moved to.
  toState {
    id
  }
  # The team that the issue was moved from.
  fromTeam {
    id
  }
  # The team that the issue was moved to.
  toTeam {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that was assigned to the issue.
  toAssignee {
    id
  }
  # The user that was unassigned from the issue.
  fromAssignee {
    id
  }
  # The users that were notified of the issue.
  triageResponsibilityNotifiedUsers {
    ...User
  }
  # What the due date was changed from.
  fromDueDate
  # What the due date was changed to.
  toDueDate
  # What the estimate was changed from.
  fromEstimate
  # What the estimate was changed to.
  toEstimate
  # What the priority was changed from.
  fromPriority
  # What the priority was changed to.
  toPriority
  # What the title was changed from.
  fromTitle
  # What the title was changed to.
  toTitle
  # Whether the issue is archived at the time of this history entry.
  archived
  # Whether the issue was auto-archived.
  autoArchived
  # Whether the issue was auto-closed.
  autoClosed
  # Whether the issue was trashed or un-trashed.
  trashed
  # Whether the issue's description was updated.
  updatedDescription
}

# A relation between two issues.
fragment IssueRelation on IssueRelation {
  __typename
  # The issue whose relationship is being described.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The related issue.
  relatedIssue {
    id
  }
  # The relationship of the issue with the related issue.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A relation between two projects.
fragment ProjectRelation on ProjectRelation {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The last user who created or modified the relation.
  user {
    id
  }
  # The milestone within the project whose relationship is being described.
  projectMilestone {
    id
  }
  # The milestone within the related project whose relationship is being described.
  relatedProjectMilestone {
    id
  }
  # The project whose relationship is being described.
  project {
    id
  }
  # The related project.
  relatedProject {
    id
  }
  # The relationship of the project with the related project.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of anchor on the project end of the relation.
  anchorType
  # The type of anchor on the relatedProject end of the relation.
  relatedAnchorType
  # The unique identifier of the entity.
  id
}

# A relation representing the dependency between two initiatives.
fragment InitiativeRelation on InitiativeRelation {
  __typename
  # The child initiative.
  relatedInitiative {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The last user who created or modified the relation.
  user {
    id
  }
  # The parent initiative.
  initiative {
    id
  }
  # The sort order of the relation within the initiative.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A roadmap for projects.
fragment Roadmap on Roadmap {
  __typename
  # The canonical url for the roadmap.
  url
  # The description of the roadmap.
  description
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the roadmap.
  name
  # The roadmap's color.
  color
  # The roadmap's unique URL slug.
  slugId
  # The sort order of the roadmap within the organization.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the roadmap.
  creator {
    id
  }
  # The user who owns the roadmap.
  owner {
    id
  }
}

# A set of issues to be resolved in a specified amount of time.
fragment Cycle on Cycle {
  __typename
  # The completion time of the cycle. If null, the cycle hasn't been completed.
  completedAt
  # The custom name of the cycle.
  name
  # The cycle inherited from.
  inheritedFrom {
    id
  }
  # The cycle's description.
  description
  # The end time of the cycle.
  endsAt
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The number of completed estimation points after each day.
  completedScopeHistory
  # The number of completed issues in the cycle after each day.
  completedIssueCountHistory
  # The number of in progress estimation points after each day.
  inProgressScopeHistory
  # The number of the cycle.
  number
  # The overall progress of the cycle. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  progress
  # The start time of the cycle.
  startsAt
  # The team that the cycle is associated with.
  team {
    id
  }
  # The time at which the cycle was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The total number of estimation points after each day.
  scopeHistory
  # The total number of issues in the cycle after each day.
  issueCountHistory
  # The unique identifier of the entity.
  id
}

# A state in a team workflow.
fragment WorkflowState on WorkflowState {
  __typename
  # Description of the state.
  description
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The position of the state in the team flow.
  position
  # The state inherited from
  inheritedFrom {
    id
  }
  # The state's UI color as a HEX string.
  color
  # The state's name.
  name
  # The team to which this state belongs to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the state. One of "triage", "backlog", "unstarted", "started", "completed", "canceled".
  type
  # The unique identifier of the entity.
  id
}

# A team notification subscription.
fragment TeamNotificationSubscription on TeamNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team subscribed to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A team's triage responsibility.
fragment TriageResponsibility on TriageResponsibility {
  __typename
  # Set of users used for triage responsibility.
  manualSelection {
    ...TriageResponsibilityManualSelection
  }
  # The action to take when an issue is added to triage.
  action
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team to which the triage responsibility belongs to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time schedule used for scheduling.
  timeSchedule {
    id
  }
  # The unique identifier of the entity.
  id
  # The user currently responsible for triage.
  currentUser {
    id
  }
}

# A template object used for creating entities faster.
fragment Template on Template {
  __typename
  # Template data.
  templateData
  # Template description.
  description
  # The entity type this template is for.
  type
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the template.
  name
  # The original template inherited from.
  inheritedFrom {
    id
  }
  # The sort order of the template.
  sortOrder
  # The team that the template is associated with. If null, the template is global to the workspace.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the template.
  creator {
    id
  }
  # The user who last updated the template.
  lastUpdatedBy {
    id
  }
}

# A time schedule.
fragment TimeSchedule on TimeSchedule {
  __typename
  # The URL to the external schedule.
  externalUrl
  # The identifier of the Linear integration populating the schedule.
  integration {
    id
  }
  # The identifier of the external schedule.
  externalId
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the schedule.
  name
  # The schedule entries.
  entries {
    ...TimeScheduleEntry
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A trigger that updates the issue status according to Git automations.
fragment GitAutomationState on GitAutomationState {
  __typename
  # The associated workflow state.
  state {
    id
  }
  # The event that triggers the automation.
  event
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The target branch associated to this automation state.
  targetBranch {
    ...GitAutomationTargetBranch
  }
  # The team to which this automation state belongs.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # [DEPRECATED] The target branch, if null, the automation will be triggered on any branch.
  branchPattern
}

# A user notification subscription.
fragment UserNotificationSubscription on UserNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user subscribed to.
  user {
    id
  }
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # Whether the subscription is active or not.
  active
}

# A user that has access to the the resources of an organization.
fragment AuthUser on AuthUser {
  __typename
  # An URL to the user's avatar image.
  avatarUrl
  # Organization the user belongs to.
  organization {
    ...AuthOrganization
  }
  # The user's display (nick) name. Unique within each organization.
  displayName
  # The user's email address.
  email
  # The user's full name.
  name
  # User account ID the user belongs to.
  userAccountId
  # Whether the user is active.
  active
  # Whether the user is an organization admin or guest on a database level.
  role
  id
}

# A user that has access to the the resources of an organization.
fragment User on User {
  __typename
  # A date at which the user current status should be cleared.
  statusUntilAt
  # A short description of the user, either its title or bio.
  description
  # An URL to the user's avatar image.
  avatarUrl
  # Number of issues created.
  createdIssueCount
  # Reason why is the account disabled.
  disableReason
  # The background color of the avatar for users without set avatar.
  avatarBackgroundColor
  # The emoji to represent the user current status.
  statusEmoji
  # The initials of the user.
  initials
  # The label of the user current status.
  statusLabel
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The last time the user was seen online.
  lastSeen
  # The local timezone of the user.
  timezone
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user's display (nick) name. Unique within each organization.
  displayName
  # The user's email address.
  email
  # The user's full name.
  name
  # Unique hash for the user to be used in invite URLs.
  inviteHash
  # User's profile URL.
  url
  # Whether the user account is active or disabled (suspended).
  active
  # Whether the user is a guest in the workspace and limited to accessing a subset of teams.
  guest
  # Whether the user is an app.
  app
  # Whether the user is an organization administrator.
  admin
  # Whether the user is the currently authenticated user.
  isMe
  # [DEPRECATED] Hash for the user to be used in calendar URLs.
  calendarHash
}

# A user's notification category preferences.
fragment NotificationCategoryPreferences on NotificationCategoryPreferences {
  __typename
  # The preferences for customer notifications.
  customers {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about apps and integrations.
  appsAndIntegrations {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about assignments.
  assignments {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about comments and replies.
  commentsAndReplies {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about document changes.
  documentChanges {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about mentions.
  mentions {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about posts and updates.
  postsAndUpdates {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about reactions.
  reactions {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about reminders.
  reminders {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about reviews.
  reviews {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about status changes.
  statusChanges {
    ...NotificationChannelPreferences
  }
  # The preferences for notifications about subscriptions.
  subscriptions {
    ...NotificationChannelPreferences
  }
  # The preferences for system notifications.
  system {
    ...NotificationChannelPreferences
  }
  # The preferences for triage notifications.
  triage {
    ...NotificationChannelPreferences
  }
}

# A user's notification channel preferences, indicating if a channel is enabled or not
fragment NotificationChannelPreferences on NotificationChannelPreferences {
  __typename
  # Whether notifications are currently enabled for Slack.
  slack
  # Whether notifications are currently enabled for desktop.
  desktop
  # Whether notifications are currently enabled for email.
  email
  # Whether notifications are currently enabled for mobile.
  mobile
}

# A user's notification delivery preferences.
fragment NotificationDeliveryPreferences on NotificationDeliveryPreferences {
  __typename
  # The delivery preferences for the mobile channel.
  mobile {
    ...NotificationDeliveryPreferencesChannel
  }
}

# A user's notification delivery preferences.
fragment NotificationDeliveryPreferencesChannel on NotificationDeliveryPreferencesChannel {
  __typename
  # The schedule for notifications on this channel.
  schedule {
    ...NotificationDeliveryPreferencesSchedule
  }
  # [DEPRECATED] Whether notifications are enabled for this channel. Use notificationChannelPreferences instead.
  notificationsDisabled
}

# A user's notification delivery schedule for a particular day.
fragment NotificationDeliveryPreferencesDay on NotificationDeliveryPreferencesDay {
  __typename
  # The time notifications end.
  end
  # The time notifications start.
  start
}

# A user's notification delivery schedule for a particular day.
fragment NotificationDeliveryPreferencesSchedule on NotificationDeliveryPreferencesSchedule {
  __typename
  # Delivery preferences for Friday.
  friday {
    ...NotificationDeliveryPreferencesDay
  }
  # Delivery preferences for Monday.
  monday {
    ...NotificationDeliveryPreferencesDay
  }
  # Delivery preferences for Saturday.
  saturday {
    ...NotificationDeliveryPreferencesDay
  }
  # Delivery preferences for Sunday.
  sunday {
    ...NotificationDeliveryPreferencesDay
  }
  # Delivery preferences for Thursday.
  thursday {
    ...NotificationDeliveryPreferencesDay
  }
  # Delivery preferences for Tuesday.
  tuesday {
    ...NotificationDeliveryPreferencesDay
  }
  # Delivery preferences for Wednesday.
  wednesday {
    ...NotificationDeliveryPreferencesDay
  }
  # Whether the schedule is disabled.
  disabled
}

# A user's web or mobile push notification subscription.
fragment PushSubscription on PushSubscription {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A webhook used to send HTTP notifications over data updates.
fragment Webhook on Webhook {
  __typename
  # Secret token for verifying the origin on the recipient side.
  secret
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The resource types this webhook is subscribed to.
  resourceTypes
  # The team that the webhook is associated with. If null, the webhook is associated with all public teams of the organization or multiple teams.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the webhook.
  creator {
    id
  }
  # Webhook URL.
  url
  # Webhook label.
  label
  # Whether the Webhook is enabled for all public teams, including teams created after the webhook was created.
  allPublicTeams
  # Whether the Webhook is enabled.
  enabled
}

# An API key. Grants access to the user's resources.
fragment ApiKey on ApiKey {
  __typename
  # Scopes associated with the API key.
  scope
  # The label of the API key.
  label
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The sync groups that this API key requests access to. If null, the API key has access to all sync groups the user has access to. The final set of sync groups is computed as the intersection of these requested groups with the user's base sync groups.
  requestedSyncGroups
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# An email address that can be used for submitting issues.
fragment EmailIntakeAddress on EmailIntakeAddress {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team that the email address is associated with.
  team {
    id
  }
  # The template that the email address is associated with.
  template {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the email intake address.
  creator {
    id
  }
  # Unique email address user name (before @) used for incoming email.
  address
  # Whether the email address is enabled.
  enabled
}

# An external authenticated (e.g., through Slack) user which doesn't have a Linear account, but can
# create and update entities in Linear from the external system that authenticated them.
fragment ExternalUser on ExternalUser {
  __typename
  # An URL to the external user's avatar image.
  avatarUrl
  # The external user's display name. Unique within each organization. Can match the display name of an actual user.
  displayName
  # The external user's email address.
  email
  # The external user's full name.
  name
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The last time the external user was seen interacting with Linear.
  lastSeen
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# An external link for an entity like initiative, etc...
fragment EntityExternalLink on EntityExternalLink {
  __typename
  # The initiative that the link is associated with.
  initiative {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The link's URL.
  url
  # The link's label.
  label
  # The order of the item in the resources list.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the link.
  creator {
    id
  }
}

# An history associated with a project.
fragment ProjectHistory on ProjectHistory {
  __typename
  # The events that happened while recording that history.
  entries
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the history is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# An import job for data from an external service.
fragment IssueImport on IssueImport {
  __typename
  # Current step progress in % (0-100).
  progress
  # Error code and metadata, if one has occurred during the import.
  errorMetadata
  # File URL for the uploaded CSV for the import, if there is one.
  csvFileUrl
  # Metadata related to import service.
  serviceMetadata
  # New team's name in cases when teamId not set.
  teamName
  # The data mapping configuration for the import job.
  mapping
  # The display name of the import service.
  displayName
  # The id for the user that started the job.
  creatorId
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The service from which data will be imported.
  service
  # The status for the import job.
  status
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # User readable error message, if one has occurred during the import.
  error
}

# An initiative notification subscription.
fragment InitiativeNotificationSubscription on InitiativeNotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The initiative subscribed to.
  initiative {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of subscription.
  notificationSubscriptionTypes
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# An initiative related notification.
fragment InitiativeNotification on InitiativeNotification {
  __typename
  # Name of the reaction emoji related to the notification.
  reactionEmoji
  # Notification type.
  type
  # Related comment ID. Null if the notification is not related to a comment.
  commentId
  # Related initiative ID.
  initiativeId
  # Related initiative update ID.
  initiativeUpdateId
  # Related parent comment ID. Null if the notification is not related to a comment.
  parentCommentId
  # The bot that caused the notification.
  botActor {
    ...ActorBot
  }
  # The external user that caused the notification.
  externalUserActor {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# An initiative to group projects.
fragment Initiative on Initiative {
  __typename
  # A flag that indicates whether the initiative is in the trash bin.
  trashed
  # Initiative URL.
  url
  # Settings for all integrations associated with that initiative.
  integrationsSettings {
    id
  }
  # The day at which to prompt for updates.
  updateRemindersDay
  # The description of the initiative.
  description
  # The estimated completion date of the initiative.
  targetDate
  # The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  updateReminderFrequency
  # The health of the initiative.
  health
  # The hour at which to prompt for updates.
  updateRemindersHour
  # The icon of the initiative.
  icon
  # The initiative's color.
  color
  # The initiative's content in markdown format.
  content
  # The initiative's unique URL slug.
  slugId
  # The last initiative update posted for this initiative.
  lastUpdate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  updateReminderFrequencyInWeeks
  # The name of the initiative.
  name
  # The resolution of the initiative's estimated completion date.
  targetDateResolution
  # The resolution of the reminder frequency.
  frequencyResolution
  # The sort order of the initiative within the organization.
  sortOrder
  # The status of the initiative. One of Planned, Active, Completed
  status
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the initiative health was updated.
  healthUpdatedAt
  # The time at which the initiative was moved into active status.
  startedAt
  # The time at which the initiative was moved into completed status.
  completedAt
  # The unique identifier of the entity.
  id
  # The user who created the initiative.
  creator {
    id
  }
  # The user who owns the initiative.
  owner {
    id
  }
}

# An initiative update.
fragment InitiativeUpdate on InitiativeUpdate {
  __typename
  # Emoji reaction summary, grouped by emoji type.
  reactionData
  # Reactions associated with the initiative update.
  reactions {
    ...Reaction
  }
  # The URL to the initiative update.
  url
  # The diff between the current update and the previous one, formatted as markdown.
  diffMarkdown
  # The diff between the current update and the previous one.
  diff
  # The health at the time of the update.
  health
  # The initiative that the update is associated with.
  initiative {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time the update was edited.
  editedAt
  # The unique identifier of the entity.
  id
  # The update content in markdown format.
  body
  # The update's unique URL slug.
  slugId
  # The user who wrote the update.
  user {
    id
  }
  # Whether initiative update diff should be hidden.
  isDiffHidden
  # Whether the initiative update is stale.
  isStale
}

# An integration with an external service.
fragment Integration on Integration {
  __typename
  # The integration's type.
  service
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team that the integration is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that added the integration.
  creator {
    id
  }
}

# An invitation to the organization that has been sent via email.
fragment OrganizationInvite on OrganizationInvite {
  __typename
  # Extra metadata associated with the organization invite.
  metadata
  # The invite was sent to external address.
  external
  # The invitees email address.
  email
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the invite was accepted. Null, if the invite hasn't been accepted.
  acceptedAt
  # The time at which the invite will be expiring. Null, if the invite shouldn't expire.
  expiresAt
  # The unique identifier of the entity.
  id
  # The user role that the invitee will receive upon accepting the invite.
  role
  # The user who created the invitation.
  inviter {
    id
  }
  # The user who has accepted the invite. Null, if the invite hasn't been accepted.
  invitee {
    id
  }
}

# An issue related notification.
fragment IssueNotification on IssueNotification {
  __typename
  # Name of the reaction emoji related to the notification.
  reactionEmoji
  # Notification type.
  type
  # Related comment ID. Null if the notification is not related to a comment.
  commentId
  # Related issue ID.
  issueId
  # Related parent comment ID. Null if the notification is not related to a comment.
  parentCommentId
  # The bot that caused the notification.
  botActor {
    ...ActorBot
  }
  # The comment related to the notification.
  comment {
    id
  }
  # The external user that caused the notification.
  externalUserActor {
    id
  }
  # The issue related to the notification.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The parent comment related to the notification, if a notification is a reply comment notification.
  parentComment {
    id
  }
  # The subscriptions related to the notification.
  subscriptions {
    ...NotificationSubscription
  }
  # The team related to the issue notification.
  team {
    id
  }
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# An issue.
fragment Issue on Issue {
  __typename
  # A flag that indicates whether the issue is in the trash bin.
  trashed
  # Emoji reaction summary, grouped by emoji type.
  reactionData
  # Id of the labels associated with this issue.
  labelIds
  # Integration type that created this issue, if applicable.
  integrationSourceType
  # Issue URL.
  url
  # Issue's human readable identifier (e.g. ENG-123).
  identifier
  # Label for the priority.
  priorityLabel
  # Previous identifiers of the issue if it has been moved between teams.
  previousIdentifiers
  # Reactions associated with the issue.
  reactions {
    ...Reaction
  }
  # Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
  customerTicketCount
  # Suggested branch name for the issue.
  branchName
  # The bot that created the issue, if applicable.
  botActor {
    ...ActorBot
  }
  # The comment that this issue was created from.
  sourceComment {
    id
  }
  # The cycle that the issue is associated with.
  cycle {
    id
  }
  # The date at which the issue is due.
  dueDate
  # The estimate of the complexity of the issue..
  estimate
  # The external user who created the issue.
  externalUserCreator {
    id
  }
  # The issue's description in markdown format.
  description
  # The issue's title.
  title
  # The issue's unique number.
  number
  # The last template that was applied to this issue.
  lastAppliedTemplate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in its column on the board.
  boardOrder
  # The order of the item in relation to other items in the organization, when ordered by priority.
  prioritySortOrder
  # The order of the item in relation to other items in the organization.
  sortOrder
  # The order of the item in the sub-issue list. Only set if the issue has a parent.
  subIssueSortOrder
  # The parent of the issue.
  parent {
    id
  }
  # The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  priority
  # The project that the issue is associated with.
  project {
    id
  }
  # The projectMilestone that the issue is associated with.
  projectMilestone {
    id
  }
  # The recurring issue template that created this issue.
  recurringIssueTemplate {
    id
  }
  # The team that the issue is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the issue entered triage.
  startedTriageAt
  # The time at which the issue left triage.
  triagedAt
  # The time at which the issue was added to a cycle.
  addedToCycleAt
  # The time at which the issue was added to a project.
  addedToProjectAt
  # The time at which the issue was added to a team.
  addedToTeamAt
  # The time at which the issue was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the issue was automatically closed by the auto pruning process.
  autoClosedAt
  # The time at which the issue was moved into canceled state.
  canceledAt
  # The time at which the issue was moved into completed state.
  completedAt
  # The time at which the issue was moved into started state.
  startedAt
  # The time at which the issue's SLA began.
  slaStartedAt
  # The time at which the issue's SLA will breach.
  slaBreachesAt
  # The time at which the issue's SLA will enter high risk state.
  slaHighRiskAt
  # The time at which the issue's SLA will enter medium risk state.
  slaMediumRiskAt
  # The time until an issue will be snoozed in Triage view.
  snoozedUntilAt
  # The type of SLA set on the issue. Calendar days or business days.
  slaType
  # The unique identifier of the entity.
  id
  # The user to whom the issue is assigned to.
  assignee {
    id
  }
  # The user who created the issue.
  creator {
    id
  }
  # The user who snoozed the issue.
  snoozedBy {
    id
  }
  # The users favorite associated with this issue.
  favorite {
    id
  }
  # The workflow state that the issue is associated with.
  state {
    id
  }
}

# An oauth client approval related notification.
fragment OauthClientApprovalNotification on OauthClientApprovalNotification {
  __typename
  # Notification type.
  type
  # Related OAuth client approval request ID.
  oauthClientApprovalId
  # The OAuth client approval request related to the notification.
  oauthClientApproval {
    ...OauthClientApproval
  }
  # The bot that caused the notification.
  botActor {
    ...ActorBot
  }
  # The external user that caused the notification.
  externalUserActor {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which a notification was unsnoozed..
  unsnoozedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  snoozedUntilAt
  # The unique identifier of the entity.
  id
  # The user that caused the notification.
  actor {
    id
  }
  # The user that received the notification.
  user {
    id
  }
}

# An organization. Organizations are root-level objects that contain user accounts and teams.
fragment Organization on Organization {
  __typename
  # Allowed authentication providers, empty array means all are allowed.
  allowedAuthServices
  # Configuration settings for the Customers feature.
  customersConfiguration
  # Default schedule for how often feed summaries are generated.
  defaultFeedSummarySchedule
  # How git branches are formatted. If null, default formatting will be used.
  gitBranchFormat
  # IP restriction configurations.
  ipRestrictions {
    ...OrganizationIpRestriction
  }
  # Number of active users in the organization.
  userCount
  # Number of customers in the organization.
  customerCount
  # Number of issues in the organization.
  createdIssueCount
  # Previously used URL keys for the organization (last 3 are kept and redirected).
  previousUrlKeys
  # Rolling 30-day total upload volume for the organization, in megabytes.
  periodUploadVolume
  # The day at which to prompt for initiative updates.
  initiativeUpdateRemindersDay
  # The day at which to prompt for project updates.
  projectUpdateRemindersDay
  # The feature release channel the organization belongs to.
  releaseChannel
  # The hour at which to prompt for initiative updates.
  initiativeUpdateRemindersHour
  # The hour at which to prompt for project updates.
  projectUpdateRemindersHour
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The month at which the fiscal year starts. Defaults to January (0).
  fiscalYearStartMonth
  # The n-weekly frequency at which to prompt for initiative updates. When not set, reminders are off.
  initiativeUpdateReminderFrequencyInWeeks
  # The n-weekly frequency at which to prompt for project updates. When not set, reminders are off.
  projectUpdateReminderFrequencyInWeeks
  # The organization's logo URL.
  logoUrl
  # The organization's name.
  name
  # The organization's project statuses.
  projectStatuses {
    ...ProjectStatus
  }
  # The organization's subscription to a paid plan.
  subscription {
    ...PaidSubscription
  }
  # The organization's unique URL key.
  urlKey
  # The time at which deletion of the organization was requested.
  deletionRequestedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the trial will end.
  trialEndsAt
  # The unique identifier of the entity.
  id
  # Whether SAML authentication is enabled for organization.
  samlEnabled
  # Whether SCIM provisioning is enabled for organization.
  scimEnabled
  # Whether member users are allowed to send invites.
  allowMembersToInvite
  # Whether team creation is restricted to admins.
  restrictTeamCreationToAdmins
  # Whether the Git integration linkback messages should be sent to private repositories.
  gitLinkbackMessagesEnabled
  # Whether the Git integration linkback messages should be sent to public repositories.
  gitPublicLinkbackMessagesEnabled
  # Whether the organization has enabled the feed feature.
  feedEnabled
  # Whether the organization is using Customers.
  customersEnabled
  # Whether the organization is using a roadmap.
  roadmapEnabled
  # [DEPRECATED] The frequency at which to prompt for project updates.
  projectUpdatesReminderFrequency
  # [DEPRECATED] Which day count to use for SLA calculations.
  slaDayCount
}

# An organization. Organizations are root-level objects that contain users and teams.
fragment AuthOrganization on AuthOrganization {
  __typename
  # Allowed authentication providers, empty array means all are allowed
  allowedAuthServices
  # Previously used URL keys for the organization (last 3 are kept and redirected).
  previousUrlKeys
  # The email domain or URL key for the organization.
  serviceId
  # The feature release channel the organization belongs to.
  releaseChannel
  # The organization's logo URL.
  logoUrl
  # The organization's name.
  name
  # The organization's unique URL key.
  urlKey
  # The region the organization is hosted in.
  region
  # The time at which deletion of the organization was requested.
  deletionRequestedAt
  # The unique identifier of the entity.
  id
  # Whether SAML authentication is enabled for organization.
  samlEnabled
  # Whether SCIM provisioning is enabled for organization.
  scimEnabled
  # Whether the organization is enabled. Used as a superuser tool to lock down the org.
  enabled
  userCount
}

# An organizational unit that contains issues.
fragment Team on Team {
  __typename
  # Auto assign completed issues to current cycle.
  cycleIssueAutoAssignCompleted
  # Auto assign issues to current cycle if in active status.
  cycleLockToActive
  # Auto assign started issues to current cycle.
  cycleIssueAutoAssignStarted
  # Calendar feed URL (iCal) for cycles.
  cycleCalenderUrl
  # How many upcoming cycles to create.
  upcomingCycleCount
  # Number of issues in the team.
  issueCount
  # Period after which automatically closed and completed issues are automatically archived in months.
  autoArchivePeriod
  # Period after which issues are automatically closed in months. Null/undefined means disabled.
  autoClosePeriod
  # Settings for all integrations associated with that team.
  integrationsSettings {
    id
  }
  # Team's currently active cycle.
  activeCycle {
    id
  }
  # Team's triage responsibility.
  triageResponsibility {
    id
  }
  # The SCIM group name for the team.
  scimGroupName
  # The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
  autoCloseStateId
  # The cooldown time after each cycle in weeks.
  cycleCooldownTime
  # The day of the week that a new cycle starts.
  cycleStartDay
  # The default template to use for new issues created by members of the team.
  defaultTemplateForMembers {
    id
  }
  # The default template to use for new issues created by non-members of the team.
  defaultTemplateForNonMembers {
    id
  }
  # The default template to use for new projects created for the team.
  defaultProjectTemplate {
    id
  }
  # The default workflow state into which issues are set when they are opened by team members.
  defaultIssueState {
    id
  }
  # The duration of a cycle in weeks.
  cycleDuration
  # The icon of the team.
  icon
  # The id of the default template to use for new issues created by members of the team.
  defaultTemplateForMembersId
  # The id of the default template to use for new issues created by non-members of the team.
  defaultTemplateForNonMembersId
  # The issue estimation type to use. Must be one of "notUsed", "exponential", "fibonacci", "linear", "tShirt".
  issueEstimationType
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the team including it's parent team name if it has one.
  displayName
  # The team's color.
  color
  # The team's description.
  description
  # The team's name.
  name
  # The team's unique key. The key is used in URLs.
  key
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The timezone of the team. Defaults to "America/Los_Angeles"
  timezone
  # The unique identifier of the entity.
  id
  # The workflow state into which issues are moved when a PR has been merged.
  mergeWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR has been opened as draft.
  draftWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR has been opened.
  startWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR is ready to be merged.
  mergeableWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a review has been requested for the PR.
  reviewWorkflowState {
    id
  }
  # The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
  markedAsDuplicateWorkflowState {
    id
  }
  # The workflow state into which issues are set when they are opened by non-team members or integrations if triage is enabled.
  triageIssueState {
    id
  }
  # Unique hash for the team to be used in invite URLs.
  inviteHash
  # What to use as a default estimate for unestimated issues.
  defaultIssueEstimate
  # Where to move issues when changing state.
  setIssueSortOrderOnStateChange
  # Whether an issue needs to have a priority set before leaving triage.
  requirePriorityToLeaveTriage
  # Whether child issues should automatically close when their parent issue is closed
  autoCloseChildIssues
  # Whether parent issues should automatically close when all child issues are closed
  autoCloseParentIssues
  # Whether the team is managed by SCIM integration.
  scimManaged
  # Whether the team is private or not.
  private
  # Whether the team should inherit its estimation settings from its parent. Only applies to sub-teams.
  inheritIssueEstimation
  # Whether the team should inherit its workflow statuses from its parent. Only applies to sub-teams.
  inheritWorkflowStatuses
  # Whether the team uses cycles.
  cyclesEnabled
  # Whether to add additional points to the estimate scale.
  issueEstimationExtended
  # Whether to allow zeros in issues estimates.
  issueEstimationAllowZero
  # Whether to group recent issue history entries.
  groupIssueHistory
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
  # Whether triage mode is enabled for the team or not.
  triageEnabled
  # [DEPRECATED] Whether issues without priority should be sorted first.
  issueOrderingNoPriorityFirst
  # [DEPRECATED] Whether to move issues to bottom of the column when changing state.
  issueSortOrderDefaultToBottom
}

# An update associated with a project.
fragment ProjectUpdate on ProjectUpdate {
  __typename
  # Emoji reaction summary, grouped by emoji type.
  reactionData
  # Reactions associated with the project update.
  reactions {
    ...Reaction
  }
  # The URL to the project update.
  url
  # The diff between the current update and the previous one, formatted as markdown.
  diffMarkdown
  # The diff between the current update and the previous one.
  diff
  # The health of the project at the time of the update.
  health
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the update is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time the update was edited.
  editedAt
  # The unique identifier of the entity.
  id
  # The update content in markdown format.
  body
  # The update's unique URL slug.
  slugId
  # The user who wrote the update.
  user {
    id
  }
  # Whether project update diff should be hidden.
  isDiffHidden
  # Whether the project update is stale.
  isStale
}

# Authentication session information.
fragment AuthenticationSessionResponse on AuthenticationSessionResponse {
  __typename
  # Client used for the session
  client
  # Country codes of all seen locations.
  countryCodes
  # Date when the session was created.
  createdAt
  # Date when the session was last updated.
  updatedAt
  # Human readable location
  location
  # IP address.
  ip
  # Identifies the session used to make the request.
  isCurrentSession
  # Location city name.
  locationCity
  # Location country code.
  locationCountryCode
  # Location country name.
  locationCountry
  # Location region code.
  locationRegionCode
  # Name of the session, derived from the client and operating system
  name
  # Operating system used for the session
  operatingSystem
  # Service used for logging in.
  service
  # Session's user-agent.
  userAgent
  # Type of application used to authenticate.
  type
  # Used web browser.
  browserType
  # When was the session last seen
  lastActiveAt
  id
}

# Contains requested archived model objects.
fragment ArchiveResponse on ArchiveResponse {
  __typename
  # A JSON serialized collection of model objects loaded from the archive
  archive
  # The total number of entities in the archive.
  totalCount
  # The version of the remote database. Incremented by 1 for each migration run on the database.
  databaseVersion
  # Whether the dependencies for the model objects are included in the archive.
  includesDependencies
}

# Defines the membership of a user to a team.
fragment TeamMembership on TeamMembership {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in the users team list.
  sortOrder
  # The team that the membership is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that the membership is associated with.
  user {
    id
  }
  # Whether the user is the owner of the team.
  owner
}

# Defines the use of a domain by an organization.
fragment OrganizationDomain on OrganizationDomain {
  __typename
  # Domain name.
  name
  # E-mail used to verify this domain.
  verificationEmail
  # Is this domain verified.
  verified
  # Prevent users with this domain to create new workspaces.
  disableOrganizationCreation
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who added the domain.
  creator {
    id
  }
  # What type of auth is the domain used for.
  authType
  # Whether the domains was claimed by the organization through DNS verification.
  claimed
}

# Details of the app user's authorizing user.
fragment AuthorizingUser on AuthorizingUser {
  __typename
  # The user's display name.
  displayName
  # The user's full name.
  name
}

# Entity representing a webhook execution failure.
fragment WebhookFailureEvent on WebhookFailureEvent {
  __typename
  # The HTTP response body returned by the recipient or error occured.
  responseOrError
  # The HTTP status code returned by the recipient.
  httpStatus
  # The URL that the webhook was trying to push to.
  url
  # The time at which the entity was created.
  createdAt
  # The unique execution ID of the webhook push. This is retained between retries of the same push.
  executionId
  # The unique identifier of the entity.
  id
  # The webhook that this failure event is associated with.
  webhook {
    id
  }
}

# Issue attachment (e.g. support ticket, pull request).
fragment Attachment on Attachment {
  __typename
  # An accessor helper to source.type, defines the source type of the attachment.
  sourceType
  # Content for the subtitle line in the Linear attachment widget.
  subtitle
  # Content for the title line in the Linear attachment widget.
  title
  # Custom metadata related to the attachment.
  metadata
  # Indicates if attachments for the same source application should be grouped in the Linear UI.
  groupBySource
  # Information about the source which created the attachment.
  source
  # Location of the attachment which is also used as an identifier.
  url
  # The creator of the attachment.
  creator {
    id
  }
  # The issue this attachment belongs to.
  issue {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The non-Linear user who created the attachment.
  externalUserCreator {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Issue relation history's payload.
fragment IssueRelationHistoryPayload on IssueRelationHistoryPayload {
  __typename
  # The identifier of the related issue.
  identifier
  # The type of the change.
  type
}

# Join table between projects and initiatives.
fragment InitiativeToProject on InitiativeToProject {
  __typename
  # The initiative that the project is associated with.
  initiative {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the initiative is associated with.
  project {
    id
  }
  # The sort order of the project within the initiative.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Join table between projects and roadmaps.
fragment RoadmapToProject on RoadmapToProject {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The project that the roadmap is associated with.
  project {
    id
  }
  # The roadmap that the project is associated with.
  roadmap {
    id
  }
  # The sort order of the project within the roadmap.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Join table between templates and integrations.
fragment IntegrationTemplate on IntegrationTemplate {
  __typename
  # ID of the foreign entity in the external integration this template is for, e.g., Slack channel ID.
  foreignEntityId
  # The integration that the template is associated with.
  integration {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The template that the integration is associated with.
  template {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Labels that can be associated with issues.
fragment IssueLabel on IssueLabel {
  __typename
  # The label's color as a HEX string.
  color
  # The label's description.
  description
  # The label's name.
  name
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The original label inherited from.
  inheritedFrom {
    id
  }
  # The parent label.
  parent {
    id
  }
  # The team that the label is associated with. If null, the label is associated with the global workspace.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the label.
  creator {
    id
  }
  # Whether this label is considered to be a group.
  isGroup
}

# Notification subscriptions for models.
fragment NotificationSubscription on NotificationSubscription {
  __typename
  # The contextual custom view associated with the notification subscription.
  customView {
    id
  }
  # The contextual cycle view associated with the notification subscription.
  cycle {
    id
  }
  # The contextual initiative view associated with the notification subscription.
  initiative {
    id
  }
  # The contextual label view associated with the notification subscription.
  label {
    id
  }
  # The contextual project view associated with the notification subscription.
  project {
    id
  }
  # The customer associated with the notification subscription.
  customer {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The team associated with the notification subscription.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of user view to which the notification subscription context is associated with.
  userContextViewType
  # The type of view to which the notification subscription context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # The user that subscribed to receive notifications.
  subscriber {
    id
  }
  # The user view associated with the notification subscription.
  user {
    id
  }
  # Whether the subscription is active or not.
  active
}

# Object for mapping Slack channel IDs to names and other settings.
fragment SlackChannelNameMapping on SlackChannelNameMapping {
  __typename
  # The Slack channel ID.
  id
  # The Slack channel name.
  name
  # The optional template ID to use for Asks auto-created in this channel. If not set, auto-created Asks won't use any template.
  autoCreateTemplateId
  # Whether or not @-mentioning the bot should automatically create an Ask with the message.
  autoCreateOnBotMention
  # Whether or not synced Slack threads should be updated with a message and emoji when their Ask is canceled.
  postCancellationUpdates
  # Whether or not synced Slack threads should be updated with a message and emoji when their Ask is completed.
  postCompletionUpdates
  # Whether or not synced Slack threads should be updated with a message when their Ask is accepted from triage.
  postAcceptedFromTriageUpdates
  # Whether or not the Linear Asks bot has been added to this Slack channel.
  botAdded
  # Whether or not the Slack channel is private.
  isPrivate
  # Whether or not the Slack channel is shared with an external org.
  isShared
  # Whether or not to use AI to generate titles for Asks created in this channel.
  aiTitles
  # Whether or not top-level messages in this channel should automatically create Asks.
  autoCreateOnMessage
  # Whether or not using the :ticket: emoji in this channel should automatically create Asks.
  autoCreateOnEmoji
  # Which teams are connected to the channel and settings for those teams.
  teams {
    ...SlackAsksTeamSettings
  }
}

# Object representing Google Cloud upload policy, plus additional data.
fragment UploadFile on UploadFile {
  __typename
  # The asset URL for the uploaded file. (assigned automatically).
  assetUrl
  # The content type.
  contentType
  # The filename.
  filename
  # The signed URL the for the uploaded file. (assigned automatically).
  uploadUrl
  # The size of the uploaded file.
  size
  headers {
    ...UploadFileHeader
  }
  metaData
}

# Public information of the OAuth application, plus whether the application has been authorized for
# the given scopes.
fragment UserAuthorizedApplication on UserAuthorizedApplication {
  __typename
  # Application name.
  name
  # Error associated with the application needing to be requested for approval in the workspace.
  approvalErrorCode
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's ID.
  id
  # OAuth application's client ID.
  clientId
  # Url of the developer (homepage or docs).
  developerUrl
  # Whether or not webhooks are enabled for the application.
  webhooksEnabled
  # Whether the application supports app users.
  appUserEnabled
  # Whether the application was created by Linear.
  createdByLinear
  # Whether the user has authorized the application for the given scopes.
  isAuthorized
}

# Public information of the OAuth application.
fragment Application on Application {
  __typename
  # Application name.
  name
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's ID.
  id
  # OAuth application's client ID.
  clientId
  # Url of the developer (homepage or docs).
  developerUrl
}

# Request to install OAuth clients on organizations and the response to the request.
fragment OauthClientApproval on OauthClientApproval {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The person who requested installing the OAuth client.
  requesterId
  # The person who responded to the request to install the OAuth client.
  responderId
  # The reason the person wants to install this OAuth client.
  requestReason
  # The reason the request for the OAuth client approval was denied.
  denyReason
  # The scopes the app has requested.
  scopes
  # The status for the OAuth client approval request.
  status
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The uuid of the OAuth client being requested for installation.
  oauthClientId
}

# The configuration of all integrations for different entities.
fragment IntegrationsSettings on IntegrationsSettings {
  __typename
  # Initiative which those settings apply to.
  initiative {
    id
  }
  # Project which those settings apply to.
  project {
    id
  }
  # Team which those settings apply to.
  team {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of view to which the integration settings context is associated with.
  contextViewType
  # The unique identifier of the entity.
  id
  # Whether to send a Slack message when a comment is created on any of the project or team's issues.
  slackIssueNewComment
  # Whether to send a Slack message when a initiate update is created.
  slackInitiativeUpdateCreated
  # Whether to send a Slack message when a new issue is added to triage.
  slackIssueAddedToTriage
  # Whether to send a Slack message when a new issue is created for the project or the team.
  slackIssueCreated
  # Whether to send a Slack message when a project update is created.
  slackProjectUpdateCreated
  # Whether to send a Slack message when an SLA is at high risk.
  slackIssueSlaHighRisk
  # Whether to send a Slack message when an SLA is breached.
  slackIssueSlaBreached
  # Whether to send a Slack message when an issue is added to the custom view.
  slackIssueAddedToView
  # Whether to send a Slack message when any of the project or team's issues change to completed or cancelled.
  slackIssueStatusChangedDone
  # Whether to send a Slack message when any of the project or team's issues has a change in status.
  slackIssueStatusChangedAll
  # Whether to send a new project update to team Slack channels.
  slackProjectUpdateCreatedToTeam
  # Whether to send a new project update to workspace Slack channel.
  slackProjectUpdateCreatedToWorkspace
}

# The paid subscription of an organization.
fragment PaidSubscription on PaidSubscription {
  __typename
  # The collection method for this subscription, either automatically charged or invoiced.
  collectionMethod
  # The creator of the subscription.
  creator {
    id
  }
  # The date the subscription is scheduled to be canceled, if any.
  cancelAt
  # The date the subscription was canceled, if any.
  canceledAt
  # The date the subscription will be billed next.
  nextBillingAt
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The maximum number of seats that will be billed in the subscription.
  seatsMaximum
  # The minimum number of seats that will be billed in the subscription.
  seatsMinimum
  # The number of seats in the subscription.
  seats
  # The subscription type of a pending change. Null if no change pending.
  pendingChangeType
  # The subscription type.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# The payload returned by the initiative mutations.
fragment InitiativePayload on InitiativePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The initiative that was created or updated.
  initiative {
    id
  }
  # Whether the operation was successful.
  success
}

# The result of a initiativeToProject mutation.
fragment InitiativeToProjectPayload on InitiativeToProjectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The initiativeToProject that was created or updated.
  initiativeToProject {
    id
  }
  # Whether the operation was successful.
  success
}

# The settings of a user as a JSON object.
fragment UserSettings on UserSettings {
  __typename
  # Hash for the user to be used in calendar URLs.
  calendarHash
  # The email types the user has unsubscribed from.
  unsubscribedFrom
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The notification delivery preferences for the user. Note: notificationDisabled field is deprecated in favor of notificationChannelPreferences.
  notificationDeliveryPreferences {
    ...NotificationDeliveryPreferences
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user associated with these settings.
  user {
    id
  }
  # The user's notification category preferences.
  notificationCategoryPreferences {
    ...NotificationCategoryPreferences
  }
  # The user's notification channel preferences.
  notificationChannelPreferences {
    ...NotificationChannelPreferences
  }
  # Whether this user is subscribed to DPA emails or not.
  subscribedToDPA
  # Whether this user is subscribed to changelog email or not.
  subscribedToChangelog
  # Whether this user is subscribed to invite accepted emails or not.
  subscribedToInviteAccepted
  # Whether this user is subscribed to privacy and legal update emails or not.
  subscribedToPrivacyLegalUpdates
  # Whether to auto-assign newly created issues to the current user by default.
  autoAssignToSelf
  # Whether to show full user names instead of display names.
  showFullUserNames
}

# Tuple for mapping Slack channel IDs to names.
fragment SlackAsksTeamSettings on SlackAsksTeamSettings {
  __typename
  # The Linear team ID.
  id
  # Whether the default Asks template is enabled in the given channel for this team.
  hasDefaultAsk
}

# User favorites presented in the sidebar.
fragment Favorite on Favorite {
  __typename
  # The favorited custom view.
  customView {
    id
  }
  # The favorited customer.
  customer {
    id
  }
  # The favorited cycle.
  cycle {
    id
  }
  # The favorited document.
  document {
    id
  }
  # The favorited initiative.
  initiative {
    id
  }
  # The favorited issue.
  issue {
    id
  }
  # The favorited label.
  label {
    id
  }
  # The favorited project.
  project {
    id
  }
  # The favorited roadmap.
  roadmap {
    id
  }
  # The favorited user.
  user {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The name of the folder. Only applies to favorites of type folder.
  folderName
  # The order of the item in the favorites list.
  sortOrder
  # The owner of the favorite.
  owner {
    id
  }
  # The parent folder of the favorite.
  parent {
    id
  }
  # The targeted tab of the initiative.
  initiativeTab
  # The targeted tab of the project.
  projectTab
  # The team of the favorited predefined view.
  predefinedViewTeam {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of favorited predefined view.
  predefinedViewType
  # The type of the favorite.
  type
  # The unique identifier of the entity.
  id
  # URL of the favorited entity. Folders return 'null' value.
  url
  # [DEPRECATED] The favorited team of the project.
  projectTeam {
    id
  }
}

# View preferences.
fragment ViewPreferences on ViewPreferences {
  __typename
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The view preference type.
  type
  # The view preferences
  preferences {
    ...ViewPreferencesValues
  }
  # The view type.
  viewType
}

# Whether a custom JQL query is valid or not
fragment IssueImportJqlCheckPayload on IssueImportJqlCheckPayload {
  __typename
  # An error message returned by Jira when validating the JQL query.
  error
  # Returns an approximate number of issues matching the JQL query, if available
  count
  # Returns true if the JQL query has been validated successfully, false otherwise
  success
}

# Whether an issue import can be synced at the end of an import or not
fragment IssueImportSyncCheckPayload on IssueImportSyncCheckPayload {
  __typename
  # An error message with a root cause of why the import cannot be synced
  error
  # Returns true if the import can be synced, false otherwise
  canSync
}

# Workspace audit log entry object.
fragment AuditEntry on AuditEntry {
  __typename
  # Additional information related to the request which performed the action.
  requestInformation
  # Additional metadata related to the audit entry.
  metadata
  # Country code of request resulting to audit entry.
  countryCode
  # IP from actor when entry was recorded.
  ip
  # The ID of the user that caused the audit entry to be created.
  actorId
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that caused the audit entry to be created.
  actor {
    id
  }
  type
}

fragment ApiKeyConnection on ApiKeyConnection {
  __typename
  nodes {
    ...ApiKey
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ApiKeyPayload on ApiKeyPayload {
  __typename
  # The API key that was created.
  apiKey {
    ...ApiKey
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment AsksChannelConnectPayload on AsksChannelConnectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # The new Asks Slack channel mapping for the connected channel.
  mapping {
    ...SlackChannelNameMapping
  }
  # Whether the bot needs to be manually added to the channel.
  addBot
  # Whether the operation was successful.
  success
}

fragment AttachmentConnection on AttachmentConnection {
  __typename
  nodes {
    ...Attachment
  }
  pageInfo {
    ...PageInfo
  }
}

fragment AttachmentPayload on AttachmentPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue attachment that was created.
  attachment {
    id
  }
  # Whether the operation was successful.
  success
}

fragment AttachmentSourcesPayload on AttachmentSourcesPayload {
  __typename
  # A unique list of all source types used in this workspace.
  sources
}

fragment AuditEntryConnection on AuditEntryConnection {
  __typename
  nodes {
    ...AuditEntry
  }
  pageInfo {
    ...PageInfo
  }
}

fragment AuditEntryType on AuditEntryType {
  __typename
  # Description of the audit entry type.
  description
  # The audit entry type.
  type
}

fragment AuthResolverResponse on AuthResolverResponse {
  __typename
  # Application token.
  token
  # Email for the authenticated account.
  email
  # ID of the organization last accessed by the user.
  lastUsedOrganizationId
  # List of active users that belong to the user account.
  users {
    ...AuthUser
  }
  # List of locked users that are locked by login restrictions
  lockedUsers {
    ...AuthUser
  }
  # List of organization available to this user account but locked due to the current auth method.
  lockedOrganizations {
    ...AuthOrganization
  }
  # List of organizations allowing this user account to join automatically.
  availableOrganizations {
    ...AuthOrganization
  }
  # Should the signup flow allow access for the domain.
  allowDomainAccess
  # User account ID.
  id
}

fragment CommentConnection on CommentConnection {
  __typename
  nodes {
    ...Comment
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CommentPayload on CommentPayload {
  __typename
  # The comment that was created or updated.
  comment {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ContactPayload on ContactPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment CreateCsvExportReportPayload on CreateCsvExportReportPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment CreateOrJoinOrganizationResponse on CreateOrJoinOrganizationResponse {
  __typename
  organization {
    ...AuthOrganization
  }
  user {
    ...AuthUser
  }
}

fragment CustomViewConnection on CustomViewConnection {
  __typename
  nodes {
    ...CustomView
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomViewHasSubscribersPayload on CustomViewHasSubscribersPayload {
  __typename
  # Whether the custom view has subscribers.
  hasSubscribers
}

fragment CustomViewPayload on CustomViewPayload {
  __typename
  # The custom view that was created or updated.
  customView {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment CustomViewSuggestionPayload on CustomViewSuggestionPayload {
  __typename
  # The suggested view description.
  description
  # The suggested view icon.
  icon
  # The suggested view name.
  name
}

fragment CustomerConnection on CustomerConnection {
  __typename
  nodes {
    ...Customer
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomerNeedConnection on CustomerNeedConnection {
  __typename
  nodes {
    ...CustomerNeed
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomerNeedPayload on CustomerNeedPayload {
  __typename
  # The customer need that was created or updated.
  need {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment CustomerPayload on CustomerPayload {
  __typename
  # The customer that was created or updated.
  customer {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment CustomerStatusConnection on CustomerStatusConnection {
  __typename
  nodes {
    ...CustomerStatus
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomerTierConnection on CustomerTierConnection {
  __typename
  nodes {
    ...CustomerTier
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomerTierPayload on CustomerTierPayload {
  __typename
  # The customer tier that was created or updated.
  tier {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment CycleConnection on CycleConnection {
  __typename
  nodes {
    ...Cycle
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CyclePayload on CyclePayload {
  __typename
  # The Cycle that was created or updated.
  cycle {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment DocumentConnection on DocumentConnection {
  __typename
  nodes {
    ...Document
  }
  pageInfo {
    ...PageInfo
  }
}

fragment DocumentContentHistoryPayload on DocumentContentHistoryPayload {
  __typename
  # The document content history entries.
  history {
    ...DocumentContentHistoryType
  }
  # Whether the operation was successful.
  success
}

fragment DocumentContentHistoryType on DocumentContentHistoryType {
  __typename
  # The ID of the author of the change.
  actorIds
  # The UUID of the document content history entry.
  id
  # The date when the document content history entry was created.
  createdAt
  # The date when the document content history snapshot was taken. This can be different than createdAt since the content is captured from its state at the previously known updatedAt timestamp in the case of an update. On document create, these timestamps can be the same.
  contentDataSnapshotAt
}

fragment DocumentPayload on DocumentPayload {
  __typename
  # The document that was created or updated.
  document {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment DocumentSearchPayload on DocumentSearchPayload {
  __typename
  # Archived entities matching the search term along with all their dependencies.
  archivePayload {
    ...ArchiveResponse
  }
  # Total number of results for query without filters applied.
  totalCount
  nodes {
    ...DocumentSearchResult
  }
  pageInfo {
    ...PageInfo
  }
}

fragment DocumentSearchResult on DocumentSearchResult {
  __typename
  # A flag that indicates whether the document is in the trash bin.
  trashed
  # Metadata related to search result.
  metadata
  # The ID of the document content associated with the document.
  documentContentId
  # The canonical url for the document.
  url
  # The color of the icon.
  color
  # The document title.
  title
  # The document's unique URL slug.
  slugId
  # The documents content in markdown format.
  content
  # The icon of the document.
  icon
  # The initiative that the document is associated with.
  initiative {
    id
  }
  # The last template that was applied to this document.
  lastAppliedTemplate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in the resources list.
  sortOrder
  # The project that the document is associated with.
  project {
    id
  }
  # The time at which the document was hidden. Null if the entity has not been hidden.
  hiddenAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the document.
  creator {
    id
  }
  # The user who last updated the document.
  updatedBy {
    id
  }
}

fragment DraftConnection on DraftConnection {
  __typename
  nodes {
    ...Draft
  }
  pageInfo {
    ...PageInfo
  }
}

fragment EmailIntakeAddressPayload on EmailIntakeAddressPayload {
  __typename
  # The email address that was created or updated.
  emailIntakeAddress {
    ...EmailIntakeAddress
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment EmailUnsubscribePayload on EmailUnsubscribePayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment EmailUserAccountAuthChallengeResponse on EmailUserAccountAuthChallengeResponse {
  __typename
  # Supported challenge for this user account. Can be either verificationCode or password.
  authType
  # Whether the operation was successful.
  success
}

fragment EmojiConnection on EmojiConnection {
  __typename
  nodes {
    ...Emoji
  }
  pageInfo {
    ...PageInfo
  }
}

fragment EmojiPayload on EmojiPayload {
  __typename
  # The emoji that was created.
  emoji {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment EntityExternalLinkConnection on EntityExternalLinkConnection {
  __typename
  nodes {
    ...EntityExternalLink
  }
  pageInfo {
    ...PageInfo
  }
}

fragment EntityExternalLinkPayload on EntityExternalLinkPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The link that was created or updated.
  entityExternalLink {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ExternalUserConnection on ExternalUserConnection {
  __typename
  nodes {
    ...ExternalUser
  }
  pageInfo {
    ...PageInfo
  }
}

fragment FavoriteConnection on FavoriteConnection {
  __typename
  nodes {
    ...Favorite
  }
  pageInfo {
    ...PageInfo
  }
}

fragment FavoritePayload on FavoritePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The object that was added as a favorite.
  favorite {
    id
  }
  # Whether the operation was successful.
  success
}

fragment FrontAttachmentPayload on FrontAttachmentPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue attachment that was created.
  attachment {
    id
  }
  # Whether the operation was successful.
  success
}

fragment GitAutomationStateConnection on GitAutomationStateConnection {
  __typename
  nodes {
    ...GitAutomationState
  }
  pageInfo {
    ...PageInfo
  }
}

fragment GitAutomationStatePayload on GitAutomationStatePayload {
  __typename
  # The automation state that was created or updated.
  gitAutomationState {
    ...GitAutomationState
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment GitAutomationTargetBranchPayload on GitAutomationTargetBranchPayload {
  __typename
  # The Git target branch automation that was created or updated.
  targetBranch {
    ...GitAutomationTargetBranch
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment GitHubCommitIntegrationPayload on GitHubCommitIntegrationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # The webhook secret to provide to GitHub.
  webhookSecret
  # Whether the operation was successful.
  success
}

fragment GitHubEnterpriseServerInstallVerificationPayload on GitHubEnterpriseServerInstallVerificationPayload {
  __typename
  # Has the install been successful.
  success
}

fragment GitHubEnterpriseServerPayload on GitHubEnterpriseServerPayload {
  __typename
  # The app install address.
  installUrl
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # The setup address.
  setupUrl
  # The webhook secret to provide to GitHub.
  webhookSecret
  # Whether the operation was successful.
  success
}

fragment GitLabIntegrationCreatePayload on GitLabIntegrationCreatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # The webhook secret to provide to GitLab.
  webhookSecret
  # Whether the operation was successful.
  success
}

fragment ImageUploadFromUrlPayload on ImageUploadFromUrlPayload {
  __typename
  # The URL containing the image.
  url
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment InitiativeConnection on InitiativeConnection {
  __typename
  nodes {
    ...Initiative
  }
  pageInfo {
    ...PageInfo
  }
}

fragment InitiativeHistoryConnection on InitiativeHistoryConnection {
  __typename
  nodes {
    ...InitiativeHistory
  }
  pageInfo {
    ...PageInfo
  }
}

fragment InitiativeRelationConnection on InitiativeRelationConnection {
  __typename
  nodes {
    ...InitiativeRelation
  }
  pageInfo {
    ...PageInfo
  }
}

fragment InitiativeRelationPayload on InitiativeRelationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The initiative relation that was created or updated.
  initiativeRelation {
    ...InitiativeRelation
  }
  # Whether the operation was successful.
  success
}

fragment InitiativeToProjectConnection on InitiativeToProjectConnection {
  __typename
  nodes {
    ...InitiativeToProject
  }
  pageInfo {
    ...PageInfo
  }
}

fragment InitiativeUpdateConnection on InitiativeUpdateConnection {
  __typename
  nodes {
    ...InitiativeUpdate
  }
  pageInfo {
    ...PageInfo
  }
}

fragment InitiativeUpdatePayload on InitiativeUpdatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The initiative update that was created.
  initiativeUpdate {
    id
  }
  # Whether the operation was successful.
  success
}

fragment InitiativeUpdateReminderPayload on InitiativeUpdateReminderPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment IntegrationConnection on IntegrationConnection {
  __typename
  nodes {
    ...Integration
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IntegrationHasScopesPayload on IntegrationHasScopesPayload {
  __typename
  # The missing scopes.
  missingScopes
  # Whether the integration has the required scopes.
  hasAllScopes
}

fragment IntegrationPayload on IntegrationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IntegrationRequestPayload on IntegrationRequestPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment IntegrationTemplateConnection on IntegrationTemplateConnection {
  __typename
  nodes {
    ...IntegrationTemplate
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IntegrationTemplatePayload on IntegrationTemplatePayload {
  __typename
  # The IntegrationTemplate that was created or updated.
  integrationTemplate {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment IntegrationsSettingsPayload on IntegrationsSettingsPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The settings that were created or updated.
  integrationsSettings {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssueBatchPayload on IssueBatchPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issues that were updated.
  issues {
    ...Issue
  }
  # Whether the operation was successful.
  success
}

fragment IssueConnection on IssueConnection {
  __typename
  nodes {
    ...Issue
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueFilterSuggestionPayload on IssueFilterSuggestionPayload {
  __typename
  # The json filter that is suggested.
  filter
  # The log id of the prompt, that created this filter.
  logId
}

fragment IssueHistoryConnection on IssueHistoryConnection {
  __typename
  nodes {
    ...IssueHistory
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueImportCheckPayload on IssueImportCheckPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment IssueImportDeletePayload on IssueImportDeletePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The import job that was deleted.
  issueImport {
    ...IssueImport
  }
  # Whether the operation was successful.
  success
}

fragment IssueImportPayload on IssueImportPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The import job that was created or updated.
  issueImport {
    ...IssueImport
  }
  # Whether the operation was successful.
  success
}

fragment IssueLabelConnection on IssueLabelConnection {
  __typename
  nodes {
    ...IssueLabel
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueLabelPayload on IssueLabelPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The label that was created or updated.
  issueLabel {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssuePayload on IssuePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue that was created or updated.
  issue {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssuePriorityValue on IssuePriorityValue {
  __typename
  # Priority's label.
  label
  # Priority's number value.
  priority
}

fragment IssueRelationConnection on IssueRelationConnection {
  __typename
  nodes {
    ...IssueRelation
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueRelationPayload on IssueRelationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The issue relation that was created or updated.
  issueRelation {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssueSearchPayload on IssueSearchPayload {
  __typename
  # Archived entities matching the search term along with all their dependencies.
  archivePayload {
    ...ArchiveResponse
  }
  # Total number of results for query without filters applied.
  totalCount
  nodes {
    ...IssueSearchResult
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueSearchResult on IssueSearchResult {
  __typename
  # A flag that indicates whether the issue is in the trash bin.
  trashed
  # Emoji reaction summary, grouped by emoji type.
  reactionData
  # Id of the labels associated with this issue.
  labelIds
  # Integration type that created this issue, if applicable.
  integrationSourceType
  # Issue URL.
  url
  # Issue's human readable identifier (e.g. ENG-123).
  identifier
  # Label for the priority.
  priorityLabel
  # Metadata related to search result.
  metadata
  # Previous identifiers of the issue if it has been moved between teams.
  previousIdentifiers
  # Reactions associated with the issue.
  reactions {
    ...Reaction
  }
  # Returns the number of Attachment resources which are created by customer support ticketing systems (e.g. Zendesk).
  customerTicketCount
  # Suggested branch name for the issue.
  branchName
  # The bot that created the issue, if applicable.
  botActor {
    ...ActorBot
  }
  # The comment that this issue was created from.
  sourceComment {
    id
  }
  # The cycle that the issue is associated with.
  cycle {
    id
  }
  # The date at which the issue is due.
  dueDate
  # The estimate of the complexity of the issue..
  estimate
  # The external user who created the issue.
  externalUserCreator {
    id
  }
  # The issue's description in markdown format.
  description
  # The issue's title.
  title
  # The issue's unique number.
  number
  # The last template that was applied to this issue.
  lastAppliedTemplate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The order of the item in its column on the board.
  boardOrder
  # The order of the item in relation to other items in the organization, when ordered by priority.
  prioritySortOrder
  # The order of the item in relation to other items in the organization.
  sortOrder
  # The order of the item in the sub-issue list. Only set if the issue has a parent.
  subIssueSortOrder
  # The parent of the issue.
  parent {
    id
  }
  # The priority of the issue. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  priority
  # The project that the issue is associated with.
  project {
    id
  }
  # The projectMilestone that the issue is associated with.
  projectMilestone {
    id
  }
  # The recurring issue template that created this issue.
  recurringIssueTemplate {
    id
  }
  # The team that the issue is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the issue entered triage.
  startedTriageAt
  # The time at which the issue left triage.
  triagedAt
  # The time at which the issue was added to a cycle.
  addedToCycleAt
  # The time at which the issue was added to a project.
  addedToProjectAt
  # The time at which the issue was added to a team.
  addedToTeamAt
  # The time at which the issue was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the issue was automatically closed by the auto pruning process.
  autoClosedAt
  # The time at which the issue was moved into canceled state.
  canceledAt
  # The time at which the issue was moved into completed state.
  completedAt
  # The time at which the issue was moved into started state.
  startedAt
  # The time at which the issue's SLA began.
  slaStartedAt
  # The time at which the issue's SLA will breach.
  slaBreachesAt
  # The time at which the issue's SLA will enter high risk state.
  slaHighRiskAt
  # The time at which the issue's SLA will enter medium risk state.
  slaMediumRiskAt
  # The time until an issue will be snoozed in Triage view.
  snoozedUntilAt
  # The type of SLA set on the issue. Calendar days or business days.
  slaType
  # The unique identifier of the entity.
  id
  # The user to whom the issue is assigned to.
  assignee {
    id
  }
  # The user who created the issue.
  creator {
    id
  }
  # The user who snoozed the issue.
  snoozedBy {
    id
  }
  # The users favorite associated with this issue.
  favorite {
    id
  }
  # The workflow state that the issue is associated with.
  state {
    id
  }
}

fragment IssueTitleSuggestionFromCustomerRequestPayload on IssueTitleSuggestionFromCustomerRequestPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The suggested issue title.
  title
}

fragment LogoutResponse on LogoutResponse {
  __typename
  # Whether the operation was successful.
  success
}

fragment Node on Node {
  __typename
  # The unique identifier of the entity.
  id
}

fragment NotificationBatchActionPayload on NotificationBatchActionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The notifications that were updated.
  notifications {
    ...Notification
  }
  # Whether the operation was successful.
  success
}

fragment NotificationConnection on NotificationConnection {
  __typename
  nodes {
    ...Notification
  }
  pageInfo {
    ...PageInfo
  }
}

fragment NotificationPayload on NotificationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The notification that was created or updated.
  notification {
    ...Notification
  }
  # Whether the operation was successful.
  success
}

fragment NotificationSubscriptionConnection on NotificationSubscriptionConnection {
  __typename
  nodes {
    ...NotificationSubscription
  }
  pageInfo {
    ...PageInfo
  }
}

fragment NotificationSubscriptionPayload on NotificationSubscriptionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The notification subscription that was created or updated.
  notificationSubscription {
    ...NotificationSubscription
  }
  # Whether the operation was successful.
  success
}

fragment OrganizationAcceptedOrExpiredInviteDetailsPayload on OrganizationAcceptedOrExpiredInviteDetailsPayload {
  __typename
  # The status of the invite.
  status
}

fragment OrganizationCancelDeletePayload on OrganizationCancelDeletePayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment OrganizationDeletePayload on OrganizationDeletePayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment OrganizationExistsPayload on OrganizationExistsPayload {
  __typename
  # Whether the operation was successful.
  success
  # Whether the organization exists.
  exists
}

fragment OrganizationInviteConnection on OrganizationInviteConnection {
  __typename
  nodes {
    ...OrganizationInvite
  }
  pageInfo {
    ...PageInfo
  }
}

fragment OrganizationInviteFullDetailsPayload on OrganizationInviteFullDetailsPayload {
  __typename
  # Allowed authentication providers, empty array means all are allowed.
  allowedAuthServices
  # ID of the workspace the invite is for.
  organizationId
  # Name of the workspace the invite is for.
  organizationName
  # The email of the invitee.
  email
  # The name of the inviter.
  inviter
  # The status of the invite.
  status
  # URL of the workspace logo the invite is for.
  organizationLogoUrl
  # What user role the invite should grant.
  role
  # When the invite was created.
  createdAt
  # Whether the invite has already been accepted.
  accepted
  # Whether the invite has expired.
  expired
}

fragment OrganizationInvitePayload on OrganizationInvitePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The organization invite that was created or updated.
  organizationInvite {
    id
  }
  # Whether the operation was successful.
  success
}

fragment OrganizationIpRestriction on OrganizationIpRestriction {
  __typename
  # IP range in CIDR format.
  range
  # Optional restriction description.
  description
  # Restriction type.
  type
  # Whether the restriction is enabled.
  enabled
}

fragment OrganizationMeta on OrganizationMeta {
  __typename
  # Allowed authentication providers, empty array means all are allowed.
  allowedAuthServices
  # The region the organization is hosted in.
  region
}

fragment OrganizationPayload on OrganizationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment OrganizationStartTrialPayload on OrganizationStartTrialPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment PageInfo on PageInfo {
  __typename
  # Cursor representing the first result in the paginated results.
  startCursor
  # Cursor representing the last result in the paginated results.
  endCursor
  # Indicates if there are more results when paginating backward.
  hasPreviousPage
  # Indicates if there are more results when paginating forward.
  hasNextPage
}

fragment PasskeyLoginStartResponse on PasskeyLoginStartResponse {
  __typename
  options
  success
}

fragment ProjectConnection on ProjectConnection {
  __typename
  nodes {
    ...Project
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectFilterSuggestionPayload on ProjectFilterSuggestionPayload {
  __typename
  # The json filter that is suggested.
  filter
  # The log id of the prompt, that created this filter.
  logId
}

fragment ProjectHistoryConnection on ProjectHistoryConnection {
  __typename
  nodes {
    ...ProjectHistory
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectMilestoneConnection on ProjectMilestoneConnection {
  __typename
  nodes {
    ...ProjectMilestone
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectMilestoneMoveIssueToTeam on ProjectMilestoneMoveIssueToTeam {
  __typename
  # The issue id in this relationship, you can use * as wildcard if all issues are being moved to the same team
  issueId
  # The team id in this relationship
  teamId
}

fragment ProjectMilestoneMovePayload on ProjectMilestoneMovePayload {
  __typename
  # A snapshot of the issues that were moved to new teams, if the user selected to do it, containing an array of mappings between an issue and its previous team. Store on the client to use for undoing a previous milestone move.
  previousIssueTeamIds {
    ...ProjectMilestoneMoveIssueToTeam
  }
  # A snapshot of the project that had new teams added to it, if the user selected to do it, containing an array of mappings between a project and its previous teams. Store on the client to use for undoing a previous milestone move.
  previousProjectTeamIds {
    ...ProjectMilestoneMoveProjectTeams
  }
  # The identifier of the last sync operation.
  lastSyncId
  # The project milestone that was created or updated.
  projectMilestone {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectMilestoneMoveProjectTeams on ProjectMilestoneMoveProjectTeams {
  __typename
  # The project id
  projectId
  # The team ids for the project
  teamIds
}

fragment ProjectMilestonePayload on ProjectMilestonePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project milestone that was created or updated.
  projectMilestone {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectPayload on ProjectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project that was created or updated.
  project {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectRelationConnection on ProjectRelationConnection {
  __typename
  nodes {
    ...ProjectRelation
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectRelationPayload on ProjectRelationPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project relation that was created or updated.
  projectRelation {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectSearchPayload on ProjectSearchPayload {
  __typename
  # Archived entities matching the search term along with all their dependencies.
  archivePayload {
    ...ArchiveResponse
  }
  # Total number of results for query without filters applied.
  totalCount
  nodes {
    ...ProjectSearchResult
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectSearchResult on ProjectSearchResult {
  __typename
  # A flag that indicates whether the project is in the trash bin.
  trashed
  # Id of the labels associated with this project.
  labelIds
  # Metadata related to search result.
  metadata
  # Project URL.
  url
  # Settings for all integrations associated with that project.
  integrationsSettings {
    id
  }
  # The content of the project description.
  documentContent {
    ...DocumentContent
  }
  # The day at which to prompt for updates.
  updateRemindersDay
  # The estimated completion date of the project.
  targetDate
  # The estimated start date of the project.
  startDate
  # The frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  updateReminderFrequency
  # The health of the project.
  health
  # The hour at which to prompt for updates.
  updateRemindersHour
  # The icon of the project.
  icon
  # The last project update posted for this project.
  lastUpdate {
    id
  }
  # The last template that was applied to this project.
  lastAppliedTemplate {
    id
  }
  # The last time at which the entity was meaningfully updated. This is the same as the creation time if the entity hasn't
  #     been updated after creation.
  updatedAt
  # The n-weekly frequency at which to prompt for updates. When not set, reminders are inherited from workspace.
  updateReminderFrequencyInWeeks
  # The number of completed estimation points after each week.
  completedScopeHistory
  # The number of completed issues in the project after each week.
  completedIssueCountHistory
  # The number of in progress estimation points after each week.
  inProgressScopeHistory
  # The overall progress of the project. This is the (completed estimate points + 0.25 * in progress estimate points) / total estimate points.
  progress
  # The overall scope (total estimate points) of the project.
  scope
  # The priority of the project as a label.
  priorityLabel
  # The priority of the project. 0 = No priority, 1 = Urgent, 2 = High, 3 = Normal, 4 = Low.
  priority
  # The project lead.
  lead {
    id
  }
  # The project was created based on this issue.
  convertedFromIssue {
    id
  }
  # The project's color.
  color
  # The project's content in markdown format.
  content
  # The project's description.
  description
  # The project's name.
  name
  # The project's unique URL slug.
  slugId
  # The resolution of the project's estimated completion date.
  targetDateResolution
  # The resolution of the project's start date.
  startDateResolution
  # The resolution of the reminder frequency.
  frequencyResolution
  # The sort order for the project within the organization, when ordered by priority.
  prioritySortOrder
  # The sort order for the project within the organization.
  sortOrder
  # The status that the project is associated with.
  status {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the project health was updated.
  healthUpdatedAt
  # The time at which the project was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the project was moved into canceled state.
  canceledAt
  # The time at which the project was moved into completed state.
  completedAt
  # The time at which the project was moved into started state.
  startedAt
  # The time until which project update reminders are paused.
  projectUpdateRemindersPausedUntilAt
  # The total number of estimation points after each week.
  scopeHistory
  # The total number of issues in the project after each week.
  issueCountHistory
  # The unique identifier of the entity.
  id
  # The user who created the project.
  creator {
    id
  }
  # The user's favorite associated with this project.
  favorite {
    id
  }
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
  # [DEPRECATED] The type of the state.
  state
}

fragment ProjectStatusConnection on ProjectStatusConnection {
  __typename
  nodes {
    ...ProjectStatus
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectStatusCountPayload on ProjectStatusCountPayload {
  __typename
  # Total number of projects using this project status that are not visible to the user because they are in a private team.
  privateCount
  # Total number of projects using this project status that are not visible to the user because they are in an archived team.
  archivedTeamCount
  # Total number of projects using this project status.
  count
}

fragment ProjectStatusPayload on ProjectStatusPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project status that was created or updated.
  status {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectUpdateConnection on ProjectUpdateConnection {
  __typename
  nodes {
    ...ProjectUpdate
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectUpdatePayload on ProjectUpdatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The project update that was created or updated.
  projectUpdate {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectUpdateReminderPayload on ProjectUpdateReminderPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment PushSubscriptionPayload on PushSubscriptionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The push subscription that was created or updated.
  entity {
    ...PushSubscription
  }
  # Whether the operation was successful.
  success
}

fragment PushSubscriptionTestPayload on PushSubscriptionTestPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment RateLimitPayload on RateLimitPayload {
  __typename
  # The identifier we rate limit on.
  identifier
  # The kind of rate limit selected for this request.
  kind
  # The state of the rate limit.
  limits {
    ...RateLimitResultPayload
  }
}

fragment RateLimitResultPayload on RateLimitResultPayload {
  __typename
  # The period in which the rate limit is fully replenished in ms.
  period
  # The remaining quantity for this type of limit after this request.
  remainingAmount
  # The requested quantity for this type of limit.
  requestedAmount
  # The timestamp after the rate limit is fully replenished as a UNIX timestamp.
  reset
  # The total allowed quantity for this type of limit.
  allowedAmount
  # What is being rate limited.
  type
}

fragment ReactionPayload on ReactionPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  reaction {
    ...Reaction
  }
  success
}

fragment RoadmapConnection on RoadmapConnection {
  __typename
  nodes {
    ...Roadmap
  }
  pageInfo {
    ...PageInfo
  }
}

fragment RoadmapPayload on RoadmapPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The roadmap that was created or updated.
  roadmap {
    id
  }
  # Whether the operation was successful.
  success
}

fragment RoadmapToProjectConnection on RoadmapToProjectConnection {
  __typename
  nodes {
    ...RoadmapToProject
  }
  pageInfo {
    ...PageInfo
  }
}

fragment RoadmapToProjectPayload on RoadmapToProjectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The roadmapToProject that was created or updated.
  roadmapToProject {
    id
  }
  # Whether the operation was successful.
  success
}

fragment SlackChannelConnectPayload on SlackChannelConnectPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # Whether it's recommended to connect main Slack integration.
  nudgeToConnectMainSlackIntegration
  # Whether it's recommended to update main Slack integration.
  nudgeToUpdateMainSlackIntegration
  # Whether the bot needs to be manually added to the channel.
  addBot
  # Whether the operation was successful.
  success
}

fragment SsoUrlFromEmailResponse on SsoUrlFromEmailResponse {
  __typename
  # SAML SSO sign-in URL.
  samlSsoUrl
  # Whether the operation was successful.
  success
}

fragment SuccessPayload on SuccessPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment SummaryPayload on SummaryPayload {
  __typename
  # Summary for project updates.
  summary
}

fragment TeamConnection on TeamConnection {
  __typename
  nodes {
    ...Team
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TeamMembershipConnection on TeamMembershipConnection {
  __typename
  nodes {
    ...TeamMembership
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TeamMembershipPayload on TeamMembershipPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The team membership that was created or updated.
  teamMembership {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TeamPayload on TeamPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The team that was created or updated.
  team {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TemplateConnection on TemplateConnection {
  __typename
  nodes {
    ...Template
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TemplatePayload on TemplatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The template that was created or updated.
  template {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TimeScheduleConnection on TimeScheduleConnection {
  __typename
  nodes {
    ...TimeSchedule
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TimeScheduleEntry on TimeScheduleEntry {
  __typename
  # The Linear user id of the user on schedule. If the user cannot be mapped to a Linear user then `userEmail` can be used as a reference.
  userId
  # The email, name or reference to the user on schedule. This is used in case the external user could not be mapped to a Linear user id.
  userEmail
  # The end date of the schedule in ISO 8601 date-time format.
  endsAt
  # The start date of the schedule in ISO 8601 date-time format.
  startsAt
}

fragment TimeSchedulePayload on TimeSchedulePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
  timeSchedule {
    id
  }
}

fragment TriageResponsibilityConnection on TriageResponsibilityConnection {
  __typename
  nodes {
    ...TriageResponsibility
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TriageResponsibilityManualSelection on TriageResponsibilityManualSelection {
  __typename
  # The set of users responsible for triage.
  userIds
}

fragment TriageResponsibilityPayload on TriageResponsibilityPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
  triageResponsibility {
    id
  }
}

fragment UploadFileHeader on UploadFileHeader {
  __typename
  # Upload file header key.
  key
  # Upload file header value.
  value
}

fragment UploadPayload on UploadPayload {
  __typename
  # Object describing the file to be uploaded.
  uploadFile {
    ...UploadFile
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserAdminPayload on UserAdminPayload {
  __typename
  # Whether the operation was successful.
  success
}

fragment UserConnection on UserConnection {
  __typename
  nodes {
    ...User
  }
  pageInfo {
    ...PageInfo
  }
}

fragment UserPayload on UserPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The user that was created or updated.
  user {
    id
  }
  # Whether the operation was successful.
  success
}

fragment UserSettingsFlagPayload on UserSettingsFlagPayload {
  __typename
  # The flag key which was updated.
  flag
  # The flag value after update.
  value
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSettingsFlagsResetPayload on UserSettingsFlagsResetPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSettingsPayload on UserSettingsPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ViewPreferencesPayload on ViewPreferencesPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The view preferences entity being mutated.
  viewPreferences {
    ...ViewPreferences
  }
  # Whether the operation was successful.
  success
}

fragment ViewPreferencesValues on ViewPreferencesValues {
  __typename
  # The issue grouping.
  issueGrouping
  # The issue ordering.
  viewOrdering
  # Whether to show completed issues.
  showCompletedIssues
}

fragment WebhookConnection on WebhookConnection {
  __typename
  nodes {
    ...Webhook
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WebhookPayload on WebhookPayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The webhook entity being mutated.
  webhook {
    id
  }
  # Whether the operation was successful.
  success
}

fragment WorkflowStateConnection on WorkflowStateConnection {
  __typename
  nodes {
    ...WorkflowState
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WorkflowStatePayload on WorkflowStatePayload {
  __typename
  # The identifier of the last sync operation.
  lastSyncId
  # The state that was created or updated.
  workflowState {
    id
  }
  # Whether the operation was successful.
  success
}

# All teams you the user can administrate. Administrable teams are teams whose settings the user can
# change, but to whose issues the user doesn't necessarily have access to.
query administrableTeams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  administrableTeams(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamConnection
  }
}
# All API keys for the user.
query apiKeys(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  apiKeys(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ApiKeyConnection
  }
}
# Get basic information for an application.
query applicationInfo(
  # The client ID of the application.
  $clientId: String!
) {
  applicationInfo(clientId: $clientId) {
    ...Application
  }
}
# Get information for an application and whether a user has approved it for the given scopes.
query applicationWithAuthorization(
  # Actor mode used for the authorization.
  $actor: String
  # The client ID of the application.
  $clientId: String!
  # Redirect URI for the application.
  $redirectUri: String
  # Scopes being requested by the application.
  $scope: [String!]!
) {
  applicationWithAuthorization(actor: $actor, clientId: $clientId, redirectUri: $redirectUri, scope: $scope) {
    ...UserAuthorizedApplication
  }
}
# One specific issue attachment.
# [Deprecated] 'url' can no longer be used as the 'id' parameter. Use 'attachmentsForUrl' instead
query attachment($id: String!) {
  attachment(id: $id) {
    ...Attachment
  }
}
# Query an issue by its associated attachment, and its id.
query attachmentIssue(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
) {
  attachmentIssue(id: $id) {
    ...Issue
  }
}
# Attachments associated with the issue.
query attachmentIssue_attachments(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    attachments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# The bot that created the issue, if applicable.
query attachmentIssue_botActor(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
) {
  attachmentIssue(id: $id) {
    botActor {
      ...ActorBot
    }
  }
}
# Children of the issue.
query attachmentIssue_children(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query attachmentIssue_comments(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query attachmentIssue_history(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query attachmentIssue_inverseRelations(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query attachmentIssue_labels(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Customer needs associated with the issue.
query attachmentIssue_needs(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned needs.
  $filter: CustomerNeedFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    needs(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CustomerNeedConnection
    }
  }
}
# Relations associated with this issue.
query attachmentIssue_relations(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query attachmentIssue_subscribers(
  # `id` of the attachment for which you'll want to get the issue for. [Deprecated] `url` as the `id` parameter.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned subscribers.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    subscribers(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# All issue attachments.
#
# To get attachments for a given URL, use `attachmentsForURL` query.
query attachments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachments(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...AttachmentConnection
  }
}
# Returns issue attachments for a given `url`.
query attachmentsForURL(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # The attachment URL.
  $url: String!
) {
  attachmentsForURL(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
    url: $url
  ) {
    ...AttachmentConnection
  }
}
# All audit log entries.
query auditEntries(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned audit entries.
  $filter: AuditEntryFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  auditEntries(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...AuditEntryConnection
  }
}
# List of audit entry types.
query auditEntryTypes {
  auditEntryTypes {
    ...AuditEntryType
  }
}
# User's active sessions.
query authenticationSessions {
  authenticationSessions {
    ...AuthenticationSessionResponse
  }
}
# Fetch users belonging to this user account.
query availableUsers {
  availableUsers {
    ...AuthResolverResponse
  }
}
# A specific comment.
query comment(
  # The hash of the comment to retrieve.
  $hash: String
  # The identifier of the comment to retrieve.
  $id: String
) {
  comment(hash: $hash, id: $id) {
    ...Comment
  }
}
# The bot that created the comment.
query comment_botActor(
  # The hash of the comment to retrieve.
  $hash: String
  # The identifier of the comment to retrieve.
  $id: String
) {
  comment(hash: $hash, id: $id) {
    botActor {
      ...ActorBot
    }
  }
}
# The children of the comment.
query comment_children(
  # The hash of the comment to retrieve.
  $hash: String
  # The identifier of the comment to retrieve.
  $id: String
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  comment(hash: $hash, id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# The document content that the comment is associated with.
query comment_documentContent(
  # The hash of the comment to retrieve.
  $hash: String
  # The identifier of the comment to retrieve.
  $id: String
) {
  comment(hash: $hash, id: $id) {
    documentContent {
      ...DocumentContent
    }
  }
}
# The external thread that the comment is synced with.
query comment_externalThread(
  # The hash of the comment to retrieve.
  $hash: String
  # The identifier of the comment to retrieve.
  $id: String
) {
  comment(hash: $hash, id: $id) {
    externalThread {
      ...SyncedExternalThread
    }
  }
}
# All comments.
query comments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  comments(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CommentConnection
  }
}
# One specific custom view.
query customView($id: String!) {
  customView(id: $id) {
    ...CustomView
  }
}
# Issues associated with the custom view.
query customView_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # [INTERNAL] Sort returned issues.
  $sort: [IssueSortInput!]
) {
  customView(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
      sort: $sort
    ) {
      ...IssueConnection
    }
  }
}
# The organizations default view preferences for this custom view.
query customView_organizationViewPreferences($id: String!) {
  customView(id: $id) {
    organizationViewPreferences {
      ...ViewPreferences
    }
  }
}
# The view preferences
query customView_organizationViewPreferences_preferences($id: String!) {
  customView(id: $id) {
    organizationViewPreferences {
      preferences {
        ...ViewPreferencesValues
      }
    }
  }
}
# Projects associated with the custom view.
query customView_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customView(id: $id) {
    projects(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# The current users view preferences for this custom view.
query customView_userViewPreferences($id: String!) {
  customView(id: $id) {
    userViewPreferences {
      ...ViewPreferences
    }
  }
}
# The view preferences
query customView_userViewPreferences_preferences($id: String!) {
  customView(id: $id) {
    userViewPreferences {
      preferences {
        ...ViewPreferencesValues
      }
    }
  }
}
# The calculated view preferences values for this custom view.
query customView_viewPreferencesValues($id: String!) {
  customView(id: $id) {
    viewPreferencesValues {
      ...ViewPreferencesValues
    }
  }
}
# Whether a custom view has other subscribers than the current user in the organization.
query customViewHasSubscribers(
  # The identifier of the custom view.
  $id: String!
) {
  customViewHasSubscribers(id: $id) {
    ...CustomViewHasSubscribersPayload
  }
}
# Custom views for the user.
query customViews(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customViews(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CustomViewConnection
  }
}
# One specific customer.
query customer($id: String!) {
  customer(id: $id) {
    ...Customer
  }
}
# One specific customer need
query customerNeed($id: String!) {
  customerNeed(id: $id) {
    ...CustomerNeed
  }
}
# All customer needs.
query customerNeeds(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned customers needs.
  $filter: CustomerNeedFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customerNeeds(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CustomerNeedConnection
  }
}
# One specific customer status.
query customerStatus($id: String!) {
  customerStatus(id: $id) {
    ...CustomerStatus
  }
}
# All customer statuses.
query customerStatuses(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customerStatuses(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CustomerStatusConnection
  }
}
# One specific customer tier.
query customerTier($id: String!) {
  customerTier(id: $id) {
    ...CustomerTier
  }
}
# All customer tiers.
query customerTiers(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customerTiers(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CustomerTierConnection
  }
}
# All customers.
query customers(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned customers.
  $filter: CustomerFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Sort returned customers.
  $sorts: [CustomerSortInput!]
) {
  customers(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
    sorts: $sorts
  ) {
    ...CustomerConnection
  }
}
# One specific cycle.
query cycle($id: String!) {
  cycle(id: $id) {
    ...Cycle
  }
}
# Issues associated with the cycle.
query cycle_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycle(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues that weren't completed when the cycle was closed.
query cycle_uncompletedIssuesUponClose(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycle(id: $id) {
    uncompletedIssuesUponClose(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All cycles.
query cycles(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: CycleFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycles(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CycleConnection
  }
}
# One specific document.
query document($id: String!) {
  document(id: $id) {
    ...Document
  }
}
# Comments associated with the document.
query document_comments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  document(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# A collection of document content history entries.
query documentContentHistory($id: String!) {
  documentContentHistory(id: $id) {
    ...DocumentContentHistoryPayload
  }
}
# All documents in the workspace.
query documents(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned documents.
  $filter: DocumentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  documents(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...DocumentConnection
  }
}
# A specific emoji.
query emoji(
  # The identifier or the name of the emoji to retrieve.
  $id: String!
) {
  emoji(id: $id) {
    ...Emoji
  }
}
# All custom emojis.
query emojis(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  emojis(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...EmojiConnection
  }
}
# One specific entity link.
query entityExternalLink($id: String!) {
  entityExternalLink(id: $id) {
    ...EntityExternalLink
  }
}
# One specific external user.
query externalUser(
  # The identifier of the external user to retrieve.
  $id: String!
) {
  externalUser(id: $id) {
    ...ExternalUser
  }
}
# All external users for the organization.
query externalUsers(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  externalUsers(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ExternalUserConnection
  }
}
# One specific favorite.
query favorite($id: String!) {
  favorite(id: $id) {
    ...Favorite
  }
}
# Children of the favorite. Only applies to favorites of type folder.
query favorite_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  favorite(id: $id) {
    children(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...FavoriteConnection
    }
  }
}
# The user's favorites.
query favorites(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  favorites(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...FavoriteConnection
  }
}
# One specific initiative.
query initiative($id: String!) {
  initiative(id: $id) {
    ...Initiative
  }
}
# History entries associated with the initiative.
query initiative_history(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiative(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...InitiativeHistoryConnection
    }
  }
}
# Links associated with the initiative.
query initiative_links(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiative(id: $id) {
    links(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...EntityExternalLinkConnection
    }
  }
}
# Projects associated with the initiative.
query initiative_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiative(id: $id) {
    projects(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# One specific initiative relation.
query initiativeRelation($id: String!) {
  initiativeRelation(id: $id) {
    ...ProjectRelation
  }
}
# All initiative relationships.
query initiativeRelations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiativeRelations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...InitiativeRelationConnection
  }
}
# One specific initiativeToProject.
query initiativeToProject($id: String!) {
  initiativeToProject(id: $id) {
    ...InitiativeToProject
  }
}
# returns a list of initiative to project entities.
query initiativeToProjects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiativeToProjects(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...InitiativeToProjectConnection
  }
}
# A specific  initiative update.
query initiativeUpdate(
  # The identifier of the  initiative update to retrieve.
  $id: String!
) {
  initiativeUpdate(id: $id) {
    ...InitiativeUpdate
  }
}
# Comments associated with the initiative update.
query initiativeUpdate_comments(
  # The identifier of the  initiative update to retrieve.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiativeUpdate(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# All  InitiativeUpdates.
query initiativeUpdates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned initiative updates.
  $filter: InitiativeUpdateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiativeUpdates(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...InitiativeUpdateConnection
  }
}
# All initiatives in the workspace.
query initiatives(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned initiatives.
  $filter: InitiativeFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  initiatives(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...InitiativeConnection
  }
}
# One specific integration.
query integration($id: String!) {
  integration(id: $id) {
    ...Integration
  }
}
# Checks if the integration has all required scopes.
query integrationHasScopes(
  # The integration ID.
  $integrationId: String!
  # Required scopes.
  $scopes: [String!]!
) {
  integrationHasScopes(integrationId: $integrationId, scopes: $scopes) {
    ...IntegrationHasScopesPayload
  }
}
# One specific integrationTemplate.
query integrationTemplate($id: String!) {
  integrationTemplate(id: $id) {
    ...IntegrationTemplate
  }
}
# Template and integration connections.
query integrationTemplates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  integrationTemplates(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IntegrationTemplateConnection
  }
}
# All integrations.
query integrations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  integrations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IntegrationConnection
  }
}
# One specific set of settings.
query integrationsSettings($id: String!) {
  integrationsSettings(id: $id) {
    ...IntegrationsSettings
  }
}
# One specific issue.
query issue($id: String!) {
  issue(id: $id) {
    ...Issue
  }
}
# Attachments associated with the issue.
query issue_attachments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    attachments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# The bot that created the issue, if applicable.
query issue_botActor($id: String!) {
  issue(id: $id) {
    botActor {
      ...ActorBot
    }
  }
}
# Children of the issue.
query issue_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query issue_comments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query issue_history(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query issue_inverseRelations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query issue_labels(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Customer needs associated with the issue.
query issue_needs(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned needs.
  $filter: CustomerNeedFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    needs(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CustomerNeedConnection
    }
  }
}
# Relations associated with this issue.
query issue_relations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query issue_subscribers(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned subscribers.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    subscribers(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Find issues that are related to a given Figma file key.
query issueFigmaFileKeySearch(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The Figma file key.
  $fileKey: String!
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueFigmaFileKeySearch(
    after: $after
    before: $before
    fileKey: $fileKey
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueConnection
  }
}
# Suggests filters for an issue view based on a text prompt.
query issueFilterSuggestion(
  # The ID of the project if filtering a project view
  $projectId: String
  $prompt: String!
) {
  issueFilterSuggestion(projectId: $projectId, prompt: $prompt) {
    ...IssueFilterSuggestionPayload
  }
}
# Checks a CSV file validity against a specific import service.
query issueImportCheckCSV(
  # CSV storage url.
  $csvUrl: String!
  # The service the CSV containing data from.
  $service: String!
) {
  issueImportCheckCSV(csvUrl: $csvUrl, service: $service) {
    ...IssueImportCheckPayload
  }
}
# Checks whether it will be possible to setup sync for this project or repository at the end of import
query issueImportCheckSync(
  # The ID of the issue import for which to check sync eligibility
  $issueImportId: String!
) {
  issueImportCheckSync(issueImportId: $issueImportId) {
    ...IssueImportSyncCheckPayload
  }
}
# Checks whether a custom JQL query is valid and can be used to filter issues of a Jira import
query issueImportJqlCheck(
  # Jira user account email.
  $jiraEmail: String!
  # Jira installation or cloud hostname.
  $jiraHostname: String!
  # Jira project key to use as the base filter of the query.
  $jiraProject: String!
  # Jira personal access token to access Jira REST API.
  $jiraToken: String!
  # The JQL query to validate.
  $jql: String!
) {
  issueImportJqlCheck(
    jiraEmail: $jiraEmail
    jiraHostname: $jiraHostname
    jiraProject: $jiraProject
    jiraToken: $jiraToken
    jql: $jql
  ) {
    ...IssueImportJqlCheckPayload
  }
}
# One specific label.
query issueLabel($id: String!) {
  issueLabel(id: $id) {
    ...IssueLabel
  }
}
# Children of the label.
query issueLabel_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabel(id: $id) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Issues associated with the label.
query issueLabel_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabel(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All issue labels.
query issueLabels(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabels(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueLabelConnection
  }
}
# Issue priority values and corresponding labels.
query issuePriorityValues {
  issuePriorityValues {
    ...IssuePriorityValue
  }
}
# One specific issue relation.
query issueRelation($id: String!) {
  issueRelation(id: $id) {
    ...IssueRelation
  }
}
# All issue relationships.
query issueRelations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueRelations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueRelationConnection
  }
}
# [DEPRECATED] Search issues. This endpoint is deprecated and will be removed in the future – use
# `searchIssues` instead.
query issueSearch(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # [Deprecated] Search string to look for.
  $query: String
) {
  issueSearch(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
    query: $query
  ) {
    ...IssueConnection
  }
}
# Suggests issue title based on a customer request.
query issueTitleSuggestionFromCustomerRequest($request: String!) {
  issueTitleSuggestionFromCustomerRequest(request: $request) {
    ...IssueTitleSuggestionFromCustomerRequestPayload
  }
}
# Find issue based on the VCS branch name.
query issueVcsBranchSearch(
  # The VCS branch name to search for.
  $branchName: String!
) {
  issueVcsBranchSearch(branchName: $branchName) {
    ...Issue
  }
}
# Attachments associated with the issue.
query issueVcsBranchSearch_attachments(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned attachments.
  $filter: AttachmentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    attachments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# The bot that created the issue, if applicable.
query issueVcsBranchSearch_botActor(
  # The VCS branch name to search for.
  $branchName: String!
) {
  issueVcsBranchSearch(branchName: $branchName) {
    botActor {
      ...ActorBot
    }
  }
}
# Children of the issue.
query issueVcsBranchSearch_children(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    children(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query issueVcsBranchSearch_comments(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query issueVcsBranchSearch_history(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query issueVcsBranchSearch_inverseRelations(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query issueVcsBranchSearch_labels(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Customer needs associated with the issue.
query issueVcsBranchSearch_needs(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned needs.
  $filter: CustomerNeedFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    needs(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CustomerNeedConnection
    }
  }
}
# Relations associated with this issue.
query issueVcsBranchSearch_relations(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query issueVcsBranchSearch_subscribers(
  # The VCS branch name to search for.
  $branchName: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned subscribers.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueVcsBranchSearch(branchName: $branchName) {
    subscribers(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# All issues.
query issues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # [INTERNAL] Sort returned issues.
  $sort: [IssueSortInput!]
) {
  issues(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
    sort: $sort
  ) {
    ...IssueConnection
  }
}
# One specific notification.
query notification($id: String!) {
  notification(id: $id) {
    ...Notification
  }
}
# One specific notification subscription.
query notificationSubscription($id: String!) {
  notificationSubscription(id: $id) {
    ...NotificationSubscription
  }
}
# The user's notification subscriptions.
query notificationSubscriptions(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  notificationSubscriptions(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...NotificationSubscriptionConnection
  }
}
# All notifications.
query notifications(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filters returned notifications.
  $filter: NotificationFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  notifications(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...NotificationConnection
  }
}
# The user's organization.
query organization {
  organization {
    ...Organization
  }
}
# Integrations associated with the organization.
query organization_integrations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    integrations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IntegrationConnection
    }
  }
}
# Labels associated with the organization.
query organization_labels(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# The organization's subscription to a paid plan.
query organization_subscription {
  organization {
    subscription {
      ...PaidSubscription
    }
  }
}
# Teams associated with the organization.
query organization_teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# Templates associated with the organization.
query organization_templates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned templates.
  $filter: NullableTemplateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    templates(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TemplateConnection
    }
  }
}
# Users associated with the organization.
query organization_users(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    users(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Does the organization exist.
query organizationExists($urlKey: String!) {
  organizationExists(urlKey: $urlKey) {
    ...OrganizationExistsPayload
  }
}
# One specific organization invite.
query organizationInvite($id: String!) {
  organizationInvite(id: $id) {
    ...OrganizationInvite
  }
}
# All invites for the organization.
query organizationInvites(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organizationInvites(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...OrganizationInviteConnection
  }
}
# One specific project.
query project($id: String!) {
  project(id: $id) {
    ...Project
  }
}
# Comments associated with the project overview.
query project_comments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# The content of the project description.
query project_documentContent($id: String!) {
  project(id: $id) {
    documentContent {
      ...DocumentContent
    }
  }
}
# Documents associated with the project.
query project_documents(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned documents.
  $filter: DocumentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    documents(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...DocumentConnection
    }
  }
}
# External links associated with the project.
query project_externalLinks(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    externalLinks(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...EntityExternalLinkConnection
    }
  }
}
# History entries associated with the project.
query project_history(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectHistoryConnection
    }
  }
}
# Initiatives that this project belongs to.
query project_initiatives(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    initiatives(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...InitiativeConnection
    }
  }
}
# Inverse relations associated with this project.
query project_inverseRelations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectRelationConnection
    }
  }
}
# Issues associated with the project.
query project_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Users that are members of the project.
query project_members(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    members(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Milestones associated with the project.
query project_projectMilestones(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned milestones.
  $filter: ProjectMilestoneFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    projectMilestones(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectMilestoneConnection
    }
  }
}
# Project updates associated with the project.
query project_projectUpdates(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    projectUpdates(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectUpdateConnection
    }
  }
}
# Relations associated with this project.
query project_relations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectRelationConnection
    }
  }
}
# Teams associated with this project.
query project_teams(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# Suggests filters for a project view based on a text prompt.
query projectFilterSuggestion($prompt: String!) {
  projectFilterSuggestion(prompt: $prompt) {
    ...ProjectFilterSuggestionPayload
  }
}
# One specific project milestone.
query projectMilestone($id: String!) {
  projectMilestone(id: $id) {
    ...ProjectMilestone
  }
}
# The content of the project milestone description.
query projectMilestone_documentContent($id: String!) {
  projectMilestone(id: $id) {
    documentContent {
      ...DocumentContent
    }
  }
}
# Issues associated with the project milestone.
query projectMilestone_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectMilestone(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All milestones for the project.
query projectMilestones(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned project milestones.
  $filter: ProjectMilestoneFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectMilestones(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectMilestoneConnection
  }
}
# One specific project relation.
query projectRelation($id: String!) {
  projectRelation(id: $id) {
    ...ProjectRelation
  }
}
# All project relationships.
query projectRelations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectRelations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectRelationConnection
  }
}
# One specific project status.
query projectStatus($id: String!) {
  projectStatus(id: $id) {
    ...ProjectStatus
  }
}
# All project statuses.
query projectStatuses(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectStatuses(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectStatusConnection
  }
}
# A specific project update.
query projectUpdate(
  # The identifier of the project update to retrieve.
  $id: String!
) {
  projectUpdate(id: $id) {
    ...ProjectUpdate
  }
}
# Comments associated with the project update.
query projectUpdate_comments(
  # The identifier of the project update to retrieve.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned comments.
  $filter: CommentFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectUpdate(id: $id) {
    comments(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# All project updates.
query projectUpdates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned project updates.
  $filter: ProjectUpdateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectUpdates(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectUpdateConnection
  }
}
# All projects.
query projects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projects(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectConnection
  }
}
# Sends a test push message.
query pushSubscriptionTest(
  # The send strategy to use.
  $sendStrategy: SendStrategy
  # Whether to send to mobile devices.
  $targetMobile: Boolean
) {
  pushSubscriptionTest(sendStrategy: $sendStrategy, targetMobile: $targetMobile) {
    ...PushSubscriptionTestPayload
  }
}
# The status of the rate limiter.
query rateLimitStatus {
  rateLimitStatus {
    ...RateLimitPayload
  }
}
# One specific roadmap.
query roadmap($id: String!) {
  roadmap(id: $id) {
    ...Roadmap
  }
}
# Projects associated with the roadmap.
query roadmap_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  roadmap(id: $id) {
    projects(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# One specific roadmapToProject.
query roadmapToProject($id: String!) {
  roadmapToProject(id: $id) {
    ...RoadmapToProject
  }
}
# Custom views for the user.
query roadmapToProjects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  roadmapToProjects(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...RoadmapToProjectConnection
  }
}
# All roadmaps in the workspace.
query roadmaps(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  roadmaps(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...RoadmapConnection
  }
}
# Search documents.
query searchDocuments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should associated comments be searched (default: false).
  $includeComments: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Size of search snippet to return (default: 100)
  $snippetSize: Float
  # UUID of a team to use as a boost.
  $teamId: String
  # Search string to look for.
  $term: String!
) {
  searchDocuments(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    includeComments: $includeComments
    last: $last
    orderBy: $orderBy
    snippetSize: $snippetSize
    teamId: $teamId
    term: $term
  ) {
    ...DocumentSearchPayload
  }
}
# Archived entities matching the search term along with all their dependencies.
query searchDocuments_archivePayload(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should associated comments be searched (default: false).
  $includeComments: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Size of search snippet to return (default: 100)
  $snippetSize: Float
  # UUID of a team to use as a boost.
  $teamId: String
  # Search string to look for.
  $term: String!
) {
  searchDocuments(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    includeComments: $includeComments
    last: $last
    orderBy: $orderBy
    snippetSize: $snippetSize
    teamId: $teamId
    term: $term
  ) {
    archivePayload {
      ...ArchiveResponse
    }
  }
}
# Search issues.
query searchIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should associated comments be searched (default: false).
  $includeComments: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Size of search snippet to return (default: 100)
  $snippetSize: Float
  # UUID of a team to use as a boost.
  $teamId: String
  # Search string to look for.
  $term: String!
) {
  searchIssues(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    includeComments: $includeComments
    last: $last
    orderBy: $orderBy
    snippetSize: $snippetSize
    teamId: $teamId
    term: $term
  ) {
    ...IssueSearchPayload
  }
}
# Archived entities matching the search term along with all their dependencies.
query searchIssues_archivePayload(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should associated comments be searched (default: false).
  $includeComments: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Size of search snippet to return (default: 100)
  $snippetSize: Float
  # UUID of a team to use as a boost.
  $teamId: String
  # Search string to look for.
  $term: String!
) {
  searchIssues(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    includeComments: $includeComments
    last: $last
    orderBy: $orderBy
    snippetSize: $snippetSize
    teamId: $teamId
    term: $term
  ) {
    archivePayload {
      ...ArchiveResponse
    }
  }
}
# Search projects.
query searchProjects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should associated comments be searched (default: false).
  $includeComments: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Size of search snippet to return (default: 100)
  $snippetSize: Float
  # UUID of a team to use as a boost.
  $teamId: String
  # Search string to look for.
  $term: String!
) {
  searchProjects(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    includeComments: $includeComments
    last: $last
    orderBy: $orderBy
    snippetSize: $snippetSize
    teamId: $teamId
    term: $term
  ) {
    ...ProjectSearchPayload
  }
}
# Archived entities matching the search term along with all their dependencies.
query searchProjects_archivePayload(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should associated comments be searched (default: false).
  $includeComments: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Size of search snippet to return (default: 100)
  $snippetSize: Float
  # UUID of a team to use as a boost.
  $teamId: String
  # Search string to look for.
  $term: String!
) {
  searchProjects(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    includeComments: $includeComments
    last: $last
    orderBy: $orderBy
    snippetSize: $snippetSize
    teamId: $teamId
    term: $term
  ) {
    archivePayload {
      ...ArchiveResponse
    }
  }
}
# Fetch SSO login URL for the email provided.
query ssoUrlFromEmail(
  # Email to query the SSO login URL by.
  $email: String!
  # Whether the client is the desktop app.
  $isDesktop: Boolean
) {
  ssoUrlFromEmail(email: $email, isDesktop: $isDesktop) {
    ...SsoUrlFromEmailResponse
  }
}
# One specific team.
query team($id: String!) {
  team(id: $id) {
    ...Team
  }
}
# Cycles associated with the team.
query team_cycles(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned cycles.
  $filter: CycleFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    cycles(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CycleConnection
    }
  }
}
# The Git automation states for the team.
query team_gitAutomationStates(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    gitAutomationStates(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...GitAutomationStateConnection
    }
  }
}
# Issues associated with the team.
query team_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Include issues from sub-teams.
  $includeSubTeams: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeSubTeams: $includeSubTeams
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Labels associated with the team.
query team_labels(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issue labels.
  $filter: IssueLabelFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    labels(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Users who are members of this team.
query team_members(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    members(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeDisabled: $includeDisabled
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Memberships associated with the team. For easier access of the same data, use `members` query.
query team_memberships(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    memberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Projects associated with the team.
query team_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned projects.
  $filter: ProjectFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Include projects from sub-teams.
  $includeSubTeams: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    projects(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      includeSubTeams: $includeSubTeams
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# The states that define the workflow associated with the team.
query team_states(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned workflow states.
  $filter: WorkflowStateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    states(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...WorkflowStateConnection
    }
  }
}
# Templates associated with the team.
query team_templates(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned templates.
  $filter: NullableTemplateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    templates(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TemplateConnection
    }
  }
}
# Webhooks associated with the team.
query team_webhooks(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    webhooks(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...WebhookConnection
    }
  }
}
# One specific team membership.
query teamMembership($id: String!) {
  teamMembership(id: $id) {
    ...TeamMembership
  }
}
# All team memberships.
query teamMemberships(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  teamMemberships(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamMembershipConnection
  }
}
# All teams whose issues can be accessed by the user. This might be different from
# `administrableTeams`, which also includes teams whose settings can be changed by the user.
query teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  teams(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamConnection
  }
}
# A specific template.
query template(
  # The identifier of the template to retrieve.
  $id: String!
) {
  template(id: $id) {
    ...Template
  }
}
# All templates from all users.
query templates {
  templates {
    ...Template
  }
}
# Returns all templates that are associated with the integration type.
query templatesForIntegration(
  # The type of integration for which to return associated templates.
  $integrationType: String!
) {
  templatesForIntegration(integrationType: $integrationType) {
    ...Template
  }
}
# A specific time schedule.
query timeSchedule(
  # The identifier of the time schedule to retrieve.
  $id: String!
) {
  timeSchedule(id: $id) {
    ...TimeSchedule
  }
}
# All time schedules.
query timeSchedules(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  timeSchedules(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TimeScheduleConnection
  }
}
# All triage responsibilities.
query triageResponsibilities(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  triageResponsibilities(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TriageResponsibilityConnection
  }
}
# A specific triage responsibility.
query triageResponsibility(
  # The identifier of the triage responsibility to retrieve.
  $id: String!
) {
  triageResponsibility(id: $id) {
    ...TriageResponsibility
  }
}
# Set of users used for triage responsibility.
query triageResponsibility_manualSelection(
  # The identifier of the triage responsibility to retrieve.
  $id: String!
) {
  triageResponsibility(id: $id) {
    manualSelection {
      ...TriageResponsibilityManualSelection
    }
  }
}
# One specific user.
query user(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
) {
  user(id: $id) {
    ...User
  }
}
# Issues assigned to the user.
query user_assignedIssues(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    assignedIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues created by the user.
query user_createdIssues(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    createdIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# The user's drafts
query user_drafts(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    drafts(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...DraftConnection
    }
  }
}
# Memberships associated with the user. For easier access of the same data, use `teams` query.
query user_teamMemberships(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    teamMemberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Teams the user is part of.
query user_teams(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# The user's settings.
query userSettings {
  userSettings {
    ...UserSettings
  }
}
# The user's notification category preferences.
query userSettings_notificationCategoryPreferences {
  userSettings {
    notificationCategoryPreferences {
      ...NotificationCategoryPreferences
    }
  }
}
# The preferences for notifications about apps and integrations.
query userSettings_notificationCategoryPreferences_appsAndIntegrations {
  userSettings {
    notificationCategoryPreferences {
      appsAndIntegrations {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about assignments.
query userSettings_notificationCategoryPreferences_assignments {
  userSettings {
    notificationCategoryPreferences {
      assignments {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about comments and replies.
query userSettings_notificationCategoryPreferences_commentsAndReplies {
  userSettings {
    notificationCategoryPreferences {
      commentsAndReplies {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for customer notifications.
query userSettings_notificationCategoryPreferences_customers {
  userSettings {
    notificationCategoryPreferences {
      customers {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about document changes.
query userSettings_notificationCategoryPreferences_documentChanges {
  userSettings {
    notificationCategoryPreferences {
      documentChanges {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about mentions.
query userSettings_notificationCategoryPreferences_mentions {
  userSettings {
    notificationCategoryPreferences {
      mentions {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about posts and updates.
query userSettings_notificationCategoryPreferences_postsAndUpdates {
  userSettings {
    notificationCategoryPreferences {
      postsAndUpdates {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about reactions.
query userSettings_notificationCategoryPreferences_reactions {
  userSettings {
    notificationCategoryPreferences {
      reactions {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about reminders.
query userSettings_notificationCategoryPreferences_reminders {
  userSettings {
    notificationCategoryPreferences {
      reminders {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about reviews.
query userSettings_notificationCategoryPreferences_reviews {
  userSettings {
    notificationCategoryPreferences {
      reviews {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about status changes.
query userSettings_notificationCategoryPreferences_statusChanges {
  userSettings {
    notificationCategoryPreferences {
      statusChanges {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for notifications about subscriptions.
query userSettings_notificationCategoryPreferences_subscriptions {
  userSettings {
    notificationCategoryPreferences {
      subscriptions {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for system notifications.
query userSettings_notificationCategoryPreferences_system {
  userSettings {
    notificationCategoryPreferences {
      system {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The preferences for triage notifications.
query userSettings_notificationCategoryPreferences_triage {
  userSettings {
    notificationCategoryPreferences {
      triage {
        ...NotificationChannelPreferences
      }
    }
  }
}
# The user's notification channel preferences.
query userSettings_notificationChannelPreferences {
  userSettings {
    notificationChannelPreferences {
      ...NotificationChannelPreferences
    }
  }
}
# The notification delivery preferences for the user. Note: notificationDisabled field is deprecated
# in favor of notificationChannelPreferences.
query userSettings_notificationDeliveryPreferences {
  userSettings {
    notificationDeliveryPreferences {
      ...NotificationDeliveryPreferences
    }
  }
}
# The delivery preferences for the mobile channel.
query userSettings_notificationDeliveryPreferences_mobile {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        ...NotificationDeliveryPreferencesChannel
      }
    }
  }
}
# The schedule for notifications on this channel.
query userSettings_notificationDeliveryPreferences_mobile_schedule {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          ...NotificationDeliveryPreferencesSchedule
        }
      }
    }
  }
}
# Delivery preferences for Friday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_friday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          friday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# Delivery preferences for Monday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_monday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          monday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# Delivery preferences for Saturday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_saturday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          saturday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# Delivery preferences for Sunday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_sunday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          sunday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# Delivery preferences for Thursday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_thursday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          thursday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# Delivery preferences for Tuesday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_tuesday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          tuesday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# Delivery preferences for Wednesday.
query userSettings_notificationDeliveryPreferences_mobile_schedule_wednesday {
  userSettings {
    notificationDeliveryPreferences {
      mobile {
        schedule {
          wednesday {
            ...NotificationDeliveryPreferencesDay
          }
        }
      }
    }
  }
}
# All users for the organization.
query users(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned users.
  $filter: UserFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # Should query return disabled/suspended users (default: false).
  $includeDisabled: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  users(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    includeDisabled: $includeDisabled
    last: $last
    orderBy: $orderBy
  ) {
    ...UserConnection
  }
}
# Verify that we received the correct response from the GitHub Enterprise Server.
query verifyGitHubEnterpriseServerInstallation {
  verifyGitHubEnterpriseServerInstallation {
    ...GitHubEnterpriseServerInstallVerificationPayload
  }
}
# The currently authenticated user.
query viewer {
  viewer {
    ...User
  }
}
# Issues assigned to the user.
query viewer_assignedIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    assignedIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues created by the user.
query viewer_createdIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    createdIssues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# The user's drafts
query viewer_drafts(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    drafts(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...DraftConnection
    }
  }
}
# Memberships associated with the user. For easier access of the same data, use `teams` query.
query viewer_teamMemberships(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    teamMemberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Teams the user is part of.
query viewer_teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned teams.
  $filter: TeamFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    teams(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# A specific webhook.
query webhook(
  # The identifier of the webhook to retrieve.
  $id: String!
) {
  webhook(id: $id) {
    ...Webhook
  }
}
# All webhooks.
query webhooks(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  webhooks(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...WebhookConnection
  }
}
# One specific state.
query workflowState($id: String!) {
  workflowState(id: $id) {
    ...WorkflowState
  }
}
# Issues belonging in this state.
query workflowState_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned issues.
  $filter: IssueFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  workflowState(id: $id) {
    issues(
      after: $after
      before: $before
      filter: $filter
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All issue workflow states.
query workflowStates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # Filter returned workflow states.
  $filter: WorkflowStateFilter
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  workflowStates(
    after: $after
    before: $before
    filter: $filter
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...WorkflowStateConnection
  }
}
# Creates an integration api key for Airbyte to connect with Linear.
mutation airbyteIntegrationConnect(
  # Airbyte integration settings.
  $input: AirbyteConfigurationInput!
) {
  airbyteIntegrationConnect(input: $input) {
    ...IntegrationPayload
  }
}
# Creates a new attachment, or updates existing if the same `url` and `issueId` is used.
mutation createAttachment(
  # The attachment object to create.
  $input: AttachmentCreateInput!
) {
  attachmentCreate(input: $input) {
    ...AttachmentPayload
  }
}
# Deletes an issue attachment.
mutation deleteAttachment(
  # The identifier of the attachment to delete.
  $id: String!
) {
  attachmentDelete(id: $id) {
    ...DeletePayload
  }
}
# Link an existing Discord message to an issue.
mutation attachmentLinkDiscord(
  # The Discord channel ID for the message to link.
  $channelId: String!
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the Discord message.
  $issueId: String!
  # The Discord message ID for the message to link.
  $messageId: String!
  # The title to use for the attachment.
  $title: String
  # The Discord message URL for the message to link.
  $url: String!
) {
  attachmentLinkDiscord(
    channelId: $channelId
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    messageId: $messageId
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link an existing Front conversation to an issue.
mutation attachmentLinkFront(
  # The Front conversation ID to link.
  $conversationId: String!
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the Front conversation.
  $issueId: String!
  # The title to use for the attachment.
  $title: String
) {
  attachmentLinkFront(
    conversationId: $conversationId
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    title: $title
  ) {
    ...FrontAttachmentPayload
  }
}
# Link a GitHub issue to a Linear issue.
mutation attachmentLinkGitHubIssue(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The Linear issue for which to link the GitHub issue.
  $issueId: String!
  # The title to use for the attachment.
  $title: String
  # The URL of the GitHub issue to link.
  $url: String!
) {
  attachmentLinkGitHubIssue(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link a GitHub pull request to an issue.
mutation attachmentLinkGitHubPR(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the GitHub pull request.
  $issueId: String!
  # [Internal] The kind of link between the issue and the pull request.
  $linkKind: GitLinkKind
  # The title to use for the attachment.
  $title: String
  # The URL of the GitHub pull request to link.
  $url: String!
) {
  attachmentLinkGitHubPR(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    linkKind: $linkKind
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link an existing GitLab MR to an issue.
mutation attachmentLinkGitLabMR(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the GitLab merge request.
  $issueId: String!
  # The GitLab merge request number to link.
  $number: Float!
  # The path name to the project including any (sub)groups. E.g. linear/main/client.
  $projectPathWithNamespace: String!
  # The title to use for the attachment.
  $title: String
  # The URL of the GitLab merge request to link.
  $url: String!
) {
  attachmentLinkGitLabMR(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    number: $number
    projectPathWithNamespace: $projectPathWithNamespace
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link an existing Intercom conversation to an issue.
mutation attachmentLinkIntercom(
  # The Intercom conversation ID to link.
  $conversationId: String!
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the Intercom conversation.
  $issueId: String!
  # An optional Intercom conversation part ID to link to
  $partId: String
  # The title to use for the attachment.
  $title: String
) {
  attachmentLinkIntercom(
    conversationId: $conversationId
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    partId: $partId
    title: $title
  ) {
    ...AttachmentPayload
  }
}
# Link an existing Jira issue to an issue.
mutation attachmentLinkJiraIssue(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the Jira issue.
  $issueId: String!
  # The Jira issue key or ID to link.
  $jiraIssueId: String!
  # The title to use for the attachment.
  $title: String
  # Optional fallback URL to use if the Jira issue cannot be found.
  $url: String
) {
  attachmentLinkJiraIssue(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    jiraIssueId: $jiraIssueId
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link an existing Slack message to an issue.
mutation attachmentLinkSlack(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue to which to link the Slack message.
  $issueId: String!
  # Whether to begin syncing the message's Slack thread with a comment thread on the issue.
  $syncToCommentThread: Boolean
  # The title to use for the attachment.
  $title: String
  # The Slack message URL for the message to link.
  $url: String!
) {
  attachmentLinkSlack(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    syncToCommentThread: $syncToCommentThread
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link any url to an issue.
mutation attachmentLinkURL(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # The id for the attachment.
  $id: String
  # The issue for which to link the url.
  $issueId: String!
  # The title to use for the attachment.
  $title: String
  # The url to link.
  $url: String!
) {
  attachmentLinkURL(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Link an existing Zendesk ticket to an issue.
mutation attachmentLinkZendesk(
  # Create attachment as a user with the provided name. This option is only available to OAuth applications creating attachments in `actor=application` mode.
  $createAsUser: String
  # Provide an external user avatar URL. Can only be used in conjunction with the `createAsUser` options. This option is only available to OAuth applications creating comments in `actor=application` mode.
  $displayIconUrl: String
  # Optional attachment ID that may be provided through the API.
  $id: String
  # The issue for which to link the Zendesk ticket.
  $issueId: String!
  # The Zendesk ticket ID to link.
  $ticketId: String!
  # The title to use for the attachment.
  $title: String
  # The URL of the Zendesk ticket to link.
  $url: String
) {
  attachmentLinkZendesk(
    createAsUser: $createAsUser
    displayIconUrl: $displayIconUrl
    id: $id
    issueId: $issueId
    ticketId: $ticketId
    title: $title
    url: $url
  ) {
    ...AttachmentPayload
  }
}
# Begin syncing the thread for an existing Slack message attachment with a comment thread on its
# issue.
mutation attachmentSyncToSlack(
  # The ID of the Slack attachment to begin syncing.
  $id: String!
) {
  attachmentSyncToSlack(id: $id) {
    ...AttachmentPayload
  }
}
# Updates an existing issue attachment.
mutation updateAttachment(
  # The identifier of the attachment to update.
  $id: String!
  # A partial attachment object to update the attachment with.
  $input: AttachmentUpdateInput!
) {
  attachmentUpdate(id: $id, input: $input) {
    ...AttachmentPayload
  }
}
# Creates a new comment.
mutation createComment(
  # The comment object to create.
  $input: CommentCreateInput!
) {
  commentCreate(input: $input) {
    ...CommentPayload
  }
}
# Deletes a comment.
mutation deleteComment(
  # The identifier of the comment to delete.
  $id: String!
) {
  commentDelete(id: $id) {
    ...DeletePayload
  }
}
# Resolves a comment.
mutation commentResolve(
  # The identifier of the comment to update.
  $id: String!
  $resolvingCommentId: String
) {
  commentResolve(id: $id, resolvingCommentId: $resolvingCommentId) {
    ...CommentPayload
  }
}
# Unresolves a comment.
mutation commentUnresolve(
  # The identifier of the comment to update.
  $id: String!
) {
  commentUnresolve(id: $id) {
    ...CommentPayload
  }
}
# Updates a comment.
mutation updateComment(
  # The identifier of the comment to update.
  $id: String!
  # A partial comment object to update the comment with.
  $input: CommentUpdateInput!
) {
  commentUpdate(id: $id, input: $input) {
    ...CommentPayload
  }
}
# Saves user message.
mutation createContact(
  # The contact entry to create.
  $input: ContactCreateInput!
) {
  contactCreate(input: $input) {
    ...ContactPayload
  }
}
# Create CSV export report for the organization.
mutation createCsvExportReport($includePrivateTeamIds: [String!]) {
  createCsvExportReport(includePrivateTeamIds: $includePrivateTeamIds) {
    ...CreateCsvExportReportPayload
  }
}
# Create a notification to remind a user about an initiative update.
mutation createInitiativeUpdateReminder(
  # The identifier of the initiative to remind about.
  $initiativeId: String!
  # The user identifier to whom the notification will be sent. By default, it is set to the initiative owner.
  $userId: String
) {
  createInitiativeUpdateReminder(initiativeId: $initiativeId, userId: $userId) {
    ...InitiativeUpdateReminderPayload
  }
}
# Creates an organization from onboarding.
mutation createOrganizationFromOnboarding(
  # Organization details for the new organization.
  $input: CreateOrganizationInput!
  # Onboarding survey.
  $survey: OnboardingCustomerSurvey
) {
  createOrganizationFromOnboarding(input: $input, survey: $survey) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Create a notification to remind a user about a project update.
mutation createProjectUpdateReminder(
  # The identifier of the project to remind about.
  $projectId: String!
  # The user identifier to whom the notification will be sent. By default, it is set to the project lead.
  $userId: String
) {
  createProjectUpdateReminder(projectId: $projectId, userId: $userId) {
    ...ProjectUpdateReminderPayload
  }
}
# Creates a new custom view.
mutation createCustomView(
  # The properties of the custom view to create.
  $input: CustomViewCreateInput!
) {
  customViewCreate(input: $input) {
    ...CustomViewPayload
  }
}
# Deletes a custom view.
mutation deleteCustomView(
  # The identifier of the custom view to delete.
  $id: String!
) {
  customViewDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a custom view.
mutation updateCustomView(
  # The identifier of the custom view to update.
  $id: String!
  # The properties of the custom view to update.
  $input: CustomViewUpdateInput!
) {
  customViewUpdate(id: $id, input: $input) {
    ...CustomViewPayload
  }
}
# Creates a new customer.
mutation createCustomer(
  # The customer to create.
  $input: CustomerCreateInput!
) {
  customerCreate(input: $input) {
    ...CustomerPayload
  }
}
# Deletes a customer.
mutation deleteCustomer(
  # The identifier of the customer to delete.
  $id: String!
) {
  customerDelete(id: $id) {
    ...DeletePayload
  }
}
# Merges two customers.
mutation customerMerge(
  # The ID of the customer to merge. The needs of this customer will be transferred before it gets deleted.
  $sourceCustomerId: String!
  # The ID of the target customer to merge into. The needs of this customer will be retained
  $targetCustomerId: String!
) {
  customerMerge(sourceCustomerId: $sourceCustomerId, targetCustomerId: $targetCustomerId) {
    ...CustomerPayload
  }
}
# Archives a customer need.
mutation archiveCustomerNeed(
  # The identifier of the customer need to archive.
  $id: String!
) {
  customerNeedArchive(id: $id) {
    ...CustomerNeedArchivePayload
  }
}
# Creates a new customer need.
mutation createCustomerNeed(
  # The customer need to create.
  $input: CustomerNeedCreateInput!
) {
  customerNeedCreate(input: $input) {
    ...CustomerNeedPayload
  }
}
# Creates a new customer need out of an attachment
mutation customerNeedCreateFromAttachment(
  # The customer need to create.
  $input: CustomerNeedCreateFromAttachmentInput!
) {
  customerNeedCreateFromAttachment(input: $input) {
    ...CustomerNeedPayload
  }
}
# Deletes a customer need.
mutation deleteCustomerNeed(
  # The identifier of the customer need to delete.
  $id: String!
  # Whether to keep the attachment associated with the customer need.
  $keepAttachment: Boolean
) {
  customerNeedDelete(id: $id, keepAttachment: $keepAttachment) {
    ...DeletePayload
  }
}
# Unarchives a customer need.
mutation unarchiveCustomerNeed(
  # The identifier of the customer need to unarchive.
  $id: String!
) {
  customerNeedUnarchive(id: $id) {
    ...CustomerNeedArchivePayload
  }
}
# Updates a customer need
mutation updateCustomerNeed(
  # The identifier of the customer need to update.
  $id: String!
  # The properties of the customer need to update.
  $input: CustomerNeedUpdateInput!
) {
  customerNeedUpdate(id: $id, input: $input) {
    ...CustomerNeedPayload
  }
}
# Creates a new customer tier.
mutation createCustomerTier(
  # The CustomerTier object to create.
  $input: CustomerTierCreateInput!
) {
  customerTierCreate(input: $input) {
    ...CustomerTierPayload
  }
}
# Deletes a customer tier.
mutation deleteCustomerTier(
  # The identifier of the customer tier to delete.
  $id: String!
) {
  customerTierDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a customer tier.
mutation updateCustomerTier(
  # The identifier of the customer tier to update.
  $id: String!
  # A partial CustomerTier object to update the CustomerTier with.
  $input: CustomerTierUpdateInput!
) {
  customerTierUpdate(id: $id, input: $input) {
    ...CustomerTierPayload
  }
}
# Updates a customer
mutation updateCustomer(
  # The identifier of the customer to update.
  $id: String!
  # The properties of the customer to update.
  $input: CustomerUpdateInput!
) {
  customerUpdate(id: $id, input: $input) {
    ...CustomerPayload
  }
}
# Upserts a customer, creating it if it doesn't exists, updating it otherwise. Matches against an
# existing customer with `id` or `externalId`
mutation customerUpsert(
  # The customer to create.
  $input: CustomerUpsertInput!
) {
  customerUpsert(input: $input) {
    ...CustomerPayload
  }
}
# Archives a cycle.
mutation archiveCycle(
  # The identifier of the cycle to archive.
  $id: String!
) {
  cycleArchive(id: $id) {
    ...CycleArchivePayload
  }
}
# Creates a new cycle.
mutation createCycle(
  # The cycle object to create.
  $input: CycleCreateInput!
) {
  cycleCreate(input: $input) {
    ...CyclePayload
  }
}
# Shifts all cycles starts and ends by a certain number of days, starting from the provided cycle
# onwards.
mutation cycleShiftAll(
  # A partial cycle object to update the cycle with.
  $input: CycleShiftAllInput!
) {
  cycleShiftAll(input: $input) {
    ...CyclePayload
  }
}
# Shifts all cycles starts and ends by a certain number of days, starting from the provided cycle
# onwards.
mutation cycleStartUpcomingCycleToday(
  # The identifier of the cycle to start as of midnight today. Must be the upcoming cycle.
  $id: String!
) {
  cycleStartUpcomingCycleToday(id: $id) {
    ...CyclePayload
  }
}
# Updates a cycle.
mutation updateCycle(
  # The identifier of the cycle to update.
  $id: String!
  # A partial cycle object to update the cycle with.
  $input: CycleUpdateInput!
) {
  cycleUpdate(id: $id, input: $input) {
    ...CyclePayload
  }
}
# Creates a new document.
mutation createDocument(
  # The document to create.
  $input: DocumentCreateInput!
) {
  documentCreate(input: $input) {
    ...DocumentPayload
  }
}
# Deletes (trashes) a document.
mutation deleteDocument(
  # The identifier of the document to delete.
  $id: String!
) {
  documentDelete(id: $id) {
    ...DocumentArchivePayload
  }
}
# Restores a document.
mutation unarchiveDocument(
  # The identifier of the document to restore.
  $id: String!
) {
  documentUnarchive(id: $id) {
    ...DocumentArchivePayload
  }
}
# Updates a document.
mutation updateDocument(
  # The identifier of the document to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial document object to update the document with.
  $input: DocumentUpdateInput!
) {
  documentUpdate(id: $id, input: $input) {
    ...DocumentPayload
  }
}
# Creates a new email intake address.
mutation createEmailIntakeAddress(
  # The email intake address object to create.
  $input: EmailIntakeAddressCreateInput!
) {
  emailIntakeAddressCreate(input: $input) {
    ...EmailIntakeAddressPayload
  }
}
# Deletes an email intake address object.
mutation deleteEmailIntakeAddress(
  # The identifier of the email intake address to delete.
  $id: String!
) {
  emailIntakeAddressDelete(id: $id) {
    ...DeletePayload
  }
}
# Rotates an existing email intake address.
mutation emailIntakeAddressRotate(
  # The identifier of the email intake address.
  $id: String!
) {
  emailIntakeAddressRotate(id: $id) {
    ...EmailIntakeAddressPayload
  }
}
# Updates an existing email intake address.
mutation updateEmailIntakeAddress(
  # The identifier of the email intake address.
  $id: String!
  # The properties of the email intake address to update.
  $input: EmailIntakeAddressUpdateInput!
) {
  emailIntakeAddressUpdate(id: $id, input: $input) {
    ...EmailIntakeAddressPayload
  }
}
# Authenticates a user account via email and authentication token.
mutation emailTokenUserAccountAuth(
  # The data used for token authentication.
  $input: TokenUserAccountAuthInput!
) {
  emailTokenUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Unsubscribes the user from one type of email.
mutation emailUnsubscribe(
  # Unsubscription details.
  $input: EmailUnsubscribeInput!
) {
  emailUnsubscribe(input: $input) {
    ...EmailUnsubscribePayload
  }
}
# Finds or creates a new user account by email and sends an email with token.
mutation emailUserAccountAuthChallenge(
  # The data used for email authentication.
  $input: EmailUserAccountAuthChallengeInput!
) {
  emailUserAccountAuthChallenge(input: $input) {
    ...EmailUserAccountAuthChallengeResponse
  }
}
# Creates a custom emoji.
mutation createEmoji(
  # The emoji object to create.
  $input: EmojiCreateInput!
) {
  emojiCreate(input: $input) {
    ...EmojiPayload
  }
}
# Deletes an emoji.
mutation deleteEmoji(
  # The identifier of the emoji to delete.
  $id: String!
) {
  emojiDelete(id: $id) {
    ...DeletePayload
  }
}
# Creates a new entity link.
mutation createEntityExternalLink(
  # The entity link object to create.
  $input: EntityExternalLinkCreateInput!
) {
  entityExternalLinkCreate(input: $input) {
    ...EntityExternalLinkPayload
  }
}
# Deletes an entity link.
mutation deleteEntityExternalLink(
  # The identifier of the entity link to delete.
  $id: String!
) {
  entityExternalLinkDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an entity link.
mutation updateEntityExternalLink(
  # The identifier of the entity link to update.
  $id: String!
  # The entity link object to update.
  $input: EntityExternalLinkUpdateInput!
) {
  entityExternalLinkUpdate(id: $id, input: $input) {
    ...EntityExternalLinkPayload
  }
}
# Creates a new favorite (project, cycle etc).
mutation createFavorite(
  # The favorite object to create.
  $input: FavoriteCreateInput!
) {
  favoriteCreate(input: $input) {
    ...FavoritePayload
  }
}
# Deletes a favorite reference.
mutation deleteFavorite(
  # The identifier of the favorite reference to delete.
  $id: String!
) {
  favoriteDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a favorite.
mutation updateFavorite(
  # The identifier of the favorite to update.
  $id: String!
  # A partial favorite object to update the favorite with.
  $input: FavoriteUpdateInput!
) {
  favoriteUpdate(id: $id, input: $input) {
    ...FavoritePayload
  }
}
# XHR request payload to upload an images, video and other attachments directly to Linear's cloud
# storage.
mutation fileUpload(
  # MIME type of the uploaded file.
  $contentType: String!
  # Filename of the uploaded file.
  $filename: String!
  # Should the file be made publicly accessible (default: false).
  $makePublic: Boolean
  # Optional metadata.
  $metaData: JSON
  # File size of the uploaded file.
  $size: Int!
) {
  fileUpload(
    contentType: $contentType
    filename: $filename
    makePublic: $makePublic
    metaData: $metaData
    size: $size
  ) {
    ...UploadPayload
  }
}
# Creates a new automation state.
mutation createGitAutomationState(
  # The automation state to create.
  $input: GitAutomationStateCreateInput!
) {
  gitAutomationStateCreate(input: $input) {
    ...GitAutomationStatePayload
  }
}
# Archives an automation state.
mutation deleteGitAutomationState(
  # The identifier of the automation state to archive.
  $id: String!
) {
  gitAutomationStateDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an existing state.
mutation updateGitAutomationState(
  # The identifier of the state to update.
  $id: String!
  # The state to update.
  $input: GitAutomationStateUpdateInput!
) {
  gitAutomationStateUpdate(id: $id, input: $input) {
    ...GitAutomationStatePayload
  }
}
# Creates a Git target branch automation.
mutation createGitAutomationTargetBranch(
  # The Git target branch automation to create.
  $input: GitAutomationTargetBranchCreateInput!
) {
  gitAutomationTargetBranchCreate(input: $input) {
    ...GitAutomationTargetBranchPayload
  }
}
# Archives a Git target branch automation.
mutation deleteGitAutomationTargetBranch(
  # The identifier of the Git target branch automation to archive.
  $id: String!
) {
  gitAutomationTargetBranchDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an existing Git target branch automation.
mutation updateGitAutomationTargetBranch(
  # The identifier of the Git target branch automation to update.
  $id: String!
  # The updates.
  $input: GitAutomationTargetBranchUpdateInput!
) {
  gitAutomationTargetBranchUpdate(id: $id, input: $input) {
    ...GitAutomationTargetBranchPayload
  }
}
# Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
mutation googleUserAccountAuth(
  # The data used for Google authentication.
  $input: GoogleUserAccountAuthInput!
) {
  googleUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Upload an image from an URL to Linear.
mutation imageUploadFromUrl(
  # URL of the file to be uploaded to Linear.
  $url: String!
) {
  imageUploadFromUrl(url: $url) {
    ...ImageUploadFromUrlPayload
  }
}
# XHR request payload to upload a file for import, directly to Linear's cloud storage.
mutation importFileUpload(
  # MIME type of the uploaded file.
  $contentType: String!
  # Filename of the uploaded file.
  $filename: String!
  # Optional metadata.
  $metaData: JSON
  # File size of the uploaded file.
  $size: Int!
) {
  importFileUpload(contentType: $contentType, filename: $filename, metaData: $metaData, size: $size) {
    ...UploadPayload
  }
}
# Archives a initiative.
mutation archiveInitiative(
  # The identifier of the initiative to archive.
  $id: String!
) {
  initiativeArchive(id: $id) {
    ...InitiativeArchivePayload
  }
}
# Creates a new initiative.
mutation createInitiative(
  # The properties of the initiative to create.
  $input: InitiativeCreateInput!
) {
  initiativeCreate(input: $input) {
    ...InitiativePayload
  }
}
# Deletes (trashes) an initiative.
mutation deleteInitiative(
  # The identifier of the initiative to delete.
  $id: String!
) {
  initiativeDelete(id: $id) {
    ...DeletePayload
  }
}
# Creates a new initiative relation.
mutation createInitiativeRelation(
  # The initiative relation to create.
  $input: InitiativeRelationCreateInput!
) {
  initiativeRelationCreate(input: $input) {
    ...InitiativeRelationPayload
  }
}
# Deletes an initiative relation.
mutation deleteInitiativeRelation(
  # The identifier of the initiative relation to delete.
  $id: String!
) {
  initiativeRelationDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an initiative relation.
mutation updateInitiativeRelation(
  # The identifier of the initiative relation to update.
  $id: String!
  # The properties of the initiative relation to update.
  $input: InitiativeRelationUpdateInput!
) {
  initiativeRelationUpdate(id: $id, input: $input) {
    ...DeletePayload
  }
}
# Creates a new initiativeToProject join.
mutation createInitiativeToProject(
  # The properties of the initiativeToProject to create.
  $input: InitiativeToProjectCreateInput!
) {
  initiativeToProjectCreate(input: $input) {
    ...InitiativeToProjectPayload
  }
}
# Deletes a initiativeToProject.
mutation deleteInitiativeToProject(
  # The identifier of the initiativeToProject to delete.
  $id: String!
) {
  initiativeToProjectDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a initiativeToProject.
mutation updateInitiativeToProject(
  # The identifier of the initiativeToProject to update.
  $id: String!
  # The properties of the initiativeToProject to update.
  $input: InitiativeToProjectUpdateInput!
) {
  initiativeToProjectUpdate(id: $id, input: $input) {
    ...InitiativeToProjectPayload
  }
}
# Unarchives a initiative.
mutation unarchiveInitiative(
  # The identifier of the initiative to unarchive.
  $id: String!
) {
  initiativeUnarchive(id: $id) {
    ...InitiativeArchivePayload
  }
}
# Updates a initiative.
mutation updateInitiative(
  # The identifier of the initiative to update.
  $id: String!
  # The properties of the initiative to update.
  $input: InitiativeUpdateInput!
) {
  initiativeUpdate(id: $id, input: $input) {
    ...InitiativePayload
  }
}
# Archives an initiative update.
mutation archiveInitiativeUpdate(
  # The identifier of the initiative update to archive.
  $id: String!
) {
  initiativeUpdateArchive(id: $id) {
    ...InitiativeUpdateArchivePayload
  }
}
# Creates a initiative update.
mutation createInitiativeUpdate(
  # The initiative update object to create.
  $input: InitiativeUpdateCreateInput!
) {
  initiativeUpdateCreate(input: $input) {
    ...InitiativeUpdatePayload
  }
}
# Unarchives an initiative update.
mutation unarchiveInitiativeUpdate(
  # The identifier of the initiative update to unarchive.
  $id: String!
) {
  initiativeUpdateUnarchive(id: $id) {
    ...InitiativeUpdateArchivePayload
  }
}
# Updates an update.
mutation updateInitiativeUpdate(
  # The identifier of the update to update.
  $id: String!
  # A data to update the update with.
  $input: InitiativeUpdateUpdateInput!
) {
  initiativeUpdateUpdate(id: $id, input: $input) {
    ...InitiativeUpdatePayload
  }
}
# Archives an integration.
mutation archiveIntegration(
  # The identifier of the integration to archive.
  $id: String!
) {
  integrationArchive(id: $id) {
    ...DeletePayload
  }
}
# Connect a Slack channel to Asks.
mutation integrationAsksConnectChannel(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationAsksConnectChannel(code: $code, redirectUri: $redirectUri) {
    ...AsksChannelConnectPayload
  }
}
# Deletes an integration.
mutation deleteIntegration(
  # The identifier of the integration to delete.
  $id: String!
) {
  integrationDelete(id: $id) {
    ...DeletePayload
  }
}
# Integrates the organization with Discord.
mutation integrationDiscord(
  # The Discord OAuth code.
  $code: String!
  # The Discord OAuth redirect URI.
  $redirectUri: String!
) {
  integrationDiscord(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Figma.
mutation integrationFigma(
  # The Figma OAuth code.
  $code: String!
  # The Figma OAuth redirect URI.
  $redirectUri: String!
) {
  integrationFigma(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Front.
mutation integrationFront(
  # The Front OAuth code.
  $code: String!
  # The Front OAuth redirect URI.
  $redirectUri: String!
) {
  integrationFront(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Connects the organization with a GitHub Enterprise Server.
mutation integrationGitHubEnterpriseServerConnect(
  # The base URL of the GitHub Enterprise Server installation.
  $githubUrl: String!
  # The name of GitHub organization.
  $organizationName: String
) {
  integrationGitHubEnterpriseServerConnect(githubUrl: $githubUrl, organizationName: $organizationName) {
    ...GitHubEnterpriseServerPayload
  }
}
# Connect your GitHub account to Linear.
mutation integrationGitHubPersonal(
  # The GitHub OAuth code.
  $code: String!
) {
  integrationGitHubPersonal(code: $code) {
    ...IntegrationPayload
  }
}
# Generates a webhook for the GitHub commit integration.
mutation createIntegrationGithubCommit {
  integrationGithubCommitCreate {
    ...GitHubCommitIntegrationPayload
  }
}
# Connects the organization with the GitHub App.
mutation integrationGithubConnect(
  # The GitHub grant code that's exchanged for OAuth tokens.
  $code: String!
  # The GitHub data to connect with.
  $installationId: String!
) {
  integrationGithubConnect(code: $code, installationId: $installationId) {
    ...IntegrationPayload
  }
}
# Connects the organization with the GitHub Import App.
mutation integrationGithubImportConnect(
  # The GitHub grant code that's exchanged for OAuth tokens.
  $code: String!
  # The GitHub data to connect with.
  $installationId: String!
) {
  integrationGithubImportConnect(code: $code, installationId: $installationId) {
    ...IntegrationPayload
  }
}
# Refreshes the data for a GitHub import integration.
mutation integrationGithubImportRefresh(
  # The id of the integration to update.
  $id: String!
) {
  integrationGithubImportRefresh(id: $id) {
    ...IntegrationPayload
  }
}
# Connects the organization with a GitLab Access Token.
mutation integrationGitlabConnect(
  # The GitLab Access Token to connect with.
  $accessToken: String!
  # The URL of the GitLab installation.
  $gitlabUrl: String!
) {
  integrationGitlabConnect(accessToken: $accessToken, gitlabUrl: $gitlabUrl) {
    ...GitLabIntegrationCreatePayload
  }
}
# Integrates the organization with Google Sheets.
mutation integrationGoogleSheets(
  # The Google OAuth code.
  $code: String!
) {
  integrationGoogleSheets(code: $code) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Intercom.
mutation integrationIntercom(
  # The Intercom OAuth code.
  $code: String!
  # The Intercom domain URL to use for the integration. Defaults to app.intercom.com if not provided.
  $domainUrl: String
  # The Intercom OAuth redirect URI.
  $redirectUri: String!
) {
  integrationIntercom(code: $code, domainUrl: $domainUrl, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Disconnects the organization from Intercom.
mutation deleteIntegrationIntercom {
  integrationIntercomDelete {
    ...IntegrationPayload
  }
}
# [DEPRECATED] Updates settings on the Intercom integration.
mutation updateIntegrationIntercomSettings(
  # A partial Intercom integration settings object to update the integration settings with.
  $input: IntercomSettingsInput!
) {
  integrationIntercomSettingsUpdate(input: $input) {
    ...IntegrationPayload
  }
}
# Connect your Jira account to Linear.
mutation integrationJiraPersonal(
  # The Jira personal access token, when connecting using a PAT.
  $accessToken: String
  # The Jira OAuth code, when connecting using OAuth.
  $code: String
) {
  integrationJiraPersonal(accessToken: $accessToken, code: $code) {
    ...IntegrationPayload
  }
}
# Enables Loom integration for the organization.
mutation integrationLoom {
  integrationLoom {
    ...IntegrationPayload
  }
}
# Requests a currently unavailable integration.
mutation integrationRequest(
  # Integration request details.
  $input: IntegrationRequestInput!
) {
  integrationRequest(input: $input) {
    ...IntegrationRequestPayload
  }
}
# Integrates the organization with Sentry.
mutation integrationSentryConnect(
  # The Sentry grant code that's exchanged for OAuth tokens.
  $code: String!
  # The Sentry installationId to connect with.
  $installationId: String!
  # The slug of the Sentry organization being connected.
  $organizationSlug: String!
) {
  integrationSentryConnect(code: $code, installationId: $installationId, organizationSlug: $organizationSlug) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Slack.
mutation integrationSlack(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
  $shouldUseV2Auth: Boolean
) {
  integrationSlack(code: $code, redirectUri: $redirectUri, shouldUseV2Auth: $shouldUseV2Auth) {
    ...IntegrationPayload
  }
}
# Integrates the organization with the Slack Asks app.
mutation integrationSlackAsks(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackAsks(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Slack integration for custom view notifications.
mutation integrationSlackCustomViewNotifications(
  # The Slack OAuth code.
  $code: String!
  # Integration's associated custom view.
  $customViewId: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackCustomViewNotifications(code: $code, customViewId: $customViewId, redirectUri: $redirectUri) {
    ...SlackChannelConnectPayload
  }
}
# Integrates a Slack Asks channel with a Customer.
mutation integrationSlackCustomerChannelLink(
  # The Slack OAuth code.
  $code: String!
  # The customer to link the Slack channel with
  $customerId: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackCustomerChannelLink(code: $code, customerId: $customerId, redirectUri: $redirectUri) {
    ...SuccessPayload
  }
}
# Imports custom emojis from your Slack workspace.
mutation integrationSlackImportEmojis(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackImportEmojis(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Slack integration for organization level project update notifications.
mutation integrationSlackOrgProjectUpdatesPost(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackOrgProjectUpdatesPost(code: $code, redirectUri: $redirectUri) {
    ...SlackChannelConnectPayload
  }
}
# Integrates your personal notifications with Slack.
mutation integrationSlackPersonal(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackPersonal(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Slack integration for team notifications.
mutation integrationSlackPost(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # [DEPRECATED] Whether or not v2 of Slack OAuth should be used. No longer used.
  $shouldUseV2Auth: Boolean
  # Integration's associated team.
  $teamId: String!
) {
  integrationSlackPost(code: $code, redirectUri: $redirectUri, shouldUseV2Auth: $shouldUseV2Auth, teamId: $teamId) {
    ...SlackChannelConnectPayload
  }
}
# Slack integration for project notifications.
mutation integrationSlackProjectPost(
  # The Slack OAuth code.
  $code: String!
  # Integration's associated project.
  $projectId: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # The service to enable once connected, either 'notifications' or 'updates'.
  $service: String!
) {
  integrationSlackProjectPost(code: $code, projectId: $projectId, redirectUri: $redirectUri, service: $service) {
    ...SlackChannelConnectPayload
  }
}
# Creates a new integrationTemplate join.
mutation createIntegrationTemplate(
  # The properties of the integrationTemplate to create.
  $input: IntegrationTemplateCreateInput!
) {
  integrationTemplateCreate(input: $input) {
    ...IntegrationTemplatePayload
  }
}
# Deletes a integrationTemplate.
mutation deleteIntegrationTemplate(
  # The identifier of the integrationTemplate to delete.
  $id: String!
) {
  integrationTemplateDelete(id: $id) {
    ...DeletePayload
  }
}
# Integrates the organization with Zendesk.
mutation integrationZendesk(
  # The Zendesk OAuth code.
  $code: String!
  # The Zendesk OAuth redirect URI.
  $redirectUri: String!
  # The Zendesk OAuth scopes.
  $scope: String!
  # The Zendesk installation subdomain.
  $subdomain: String!
) {
  integrationZendesk(code: $code, redirectUri: $redirectUri, scope: $scope, subdomain: $subdomain) {
    ...IntegrationPayload
  }
}
# Creates new settings for one or more integrations.
mutation createIntegrationsSettings(
  # The settings to create.
  $input: IntegrationsSettingsCreateInput!
) {
  integrationsSettingsCreate(input: $input) {
    ...IntegrationsSettingsPayload
  }
}
# Updates settings related to integrations for a project or a team.
mutation updateIntegrationsSettings(
  # The identifier of the settings to update.
  $id: String!
  # A settings object to update the settings with.
  $input: IntegrationsSettingsUpdateInput!
) {
  integrationsSettingsUpdate(id: $id, input: $input) {
    ...IntegrationsSettingsPayload
  }
}
# Adds a label to an issue.
mutation issueAddLabel(
  # The identifier of the issue to add the label to.
  $id: String!
  # The identifier of the label to add.
  $labelId: String!
) {
  issueAddLabel(id: $id, labelId: $labelId) {
    ...IssuePayload
  }
}
# Archives an issue.
mutation archiveIssue(
  # The identifier of the issue to archive.
  $id: String!
  # Whether to trash the issue.
  $trash: Boolean
) {
  issueArchive(id: $id, trash: $trash) {
    ...IssueArchivePayload
  }
}
# Creates a list of issues in one transaction.
mutation createIssueBatch(
  # A list of issue objects to create.
  $input: IssueBatchCreateInput!
) {
  issueBatchCreate(input: $input) {
    ...IssueBatchPayload
  }
}
# Updates multiple issues at once.
mutation updateIssueBatch(
  # The id's of the issues to update. Can't be more than 50 at a time.
  $ids: [UUID!]!
  # A partial issue object to update the issues with.
  $input: IssueUpdateInput!
) {
  issueBatchUpdate(ids: $ids, input: $input) {
    ...IssueBatchPayload
  }
}
# Creates a new issue.
mutation createIssue(
  # The issue object to create.
  $input: IssueCreateInput!
) {
  issueCreate(input: $input) {
    ...IssuePayload
  }
}
# Deletes (trashes) an issue.
mutation deleteIssue(
  # The identifier of the issue to delete.
  $id: String!
  # Whether to permanently delete the issue and skip the grace period of 30 days. Available only to admins!
  $permanentlyDelete: Boolean
) {
  issueDelete(id: $id, permanentlyDelete: $permanentlyDelete) {
    ...IssueArchivePayload
  }
}
# Kicks off an Asana import job.
mutation issueImportCreateAsana(
  # Asana team name to choose which issues we should import.
  $asanaTeamName: String!
  # Asana token to fetch information from the Asana API.
  $asanaToken: String!
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the team into which to import data.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateAsana(
    asanaTeamName: $asanaTeamName
    asanaToken: $asanaToken
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Jira import job from a CSV.
mutation issueImportCreateCSVJira(
  # URL for the CSV.
  $csvUrl: String!
  # Jira user account email.
  $jiraEmail: String
  # Jira installation or cloud hostname.
  $jiraHostname: String
  # Jira personal access token to access Jira REST API.
  $jiraToken: String
  # ID of the team into which to import data. Empty to create new team.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateCSVJira(
    csvUrl: $csvUrl
    jiraEmail: $jiraEmail
    jiraHostname: $jiraHostname
    jiraToken: $jiraToken
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Shortcut (formerly Clubhouse) import job.
mutation issueImportCreateClubhouse(
  # Shortcut (formerly Clubhouse) group name to choose which issues we should import.
  $clubhouseGroupName: String!
  # Shortcut (formerly Clubhouse) token to fetch information from the Clubhouse API.
  $clubhouseToken: String!
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the team into which to import data.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateClubhouse(
    clubhouseGroupName: $clubhouseGroupName
    clubhouseToken: $clubhouseToken
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a GitHub import job.
mutation issueImportCreateGithub(
  # Labels to use to filter the import data. Only issues matching any of these filters will be imported.
  $githubLabels: [String!]
  # IDs of the Github repositories from which we will import data.
  $githubRepoIds: [Int!]
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the team into which to import data.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateGithub(
    githubLabels: $githubLabels
    githubRepoIds: $githubRepoIds
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Jira import job.
mutation issueImportCreateJira(
  # ID of issue import. If not provided it will be generated.
  $id: String
  # Whether or not we should collect the data for closed issues.
  $includeClosedIssues: Boolean
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # Jira user account email.
  $jiraEmail: String!
  # Jira installation or cloud hostname.
  $jiraHostname: String!
  # Jira project key from which we will import data.
  $jiraProject: String!
  # Jira personal access token to access Jira REST API.
  $jiraToken: String!
  # A custom JQL query to filter issues being imported
  $jql: String
  # ID of the team into which to import data. Empty to create new team.
  $teamId: String
  # Name of new team. When teamId is not set.
  $teamName: String
) {
  issueImportCreateJira(
    id: $id
    includeClosedIssues: $includeClosedIssues
    instantProcess: $instantProcess
    jiraEmail: $jiraEmail
    jiraHostname: $jiraHostname
    jiraProject: $jiraProject
    jiraToken: $jiraToken
    jql: $jql
    teamId: $teamId
    teamName: $teamName
  ) {
    ...IssueImportPayload
  }
}
# Deletes an import job.
mutation deleteIssueImport(
  # ID of the issue import to delete.
  $issueImportId: String!
) {
  issueImportDelete(issueImportId: $issueImportId) {
    ...IssueImportDeletePayload
  }
}
# Kicks off import processing.
mutation issueImportProcess(
  # ID of the issue import which we're going to process.
  $issueImportId: String!
  # The mapping configuration to use for processing the import.
  $mapping: JSONObject!
) {
  issueImportProcess(issueImportId: $issueImportId, mapping: $mapping) {
    ...IssueImportPayload
  }
}
# Updates the mapping for the issue import.
mutation updateIssueImport(
  # The identifier of the issue import.
  $id: String!
  # The properties of the issue import to update.
  $input: IssueImportUpdateInput!
) {
  issueImportUpdate(id: $id, input: $input) {
    ...IssueImportPayload
  }
}
# Creates a new label.
mutation createIssueLabel(
  # The issue label to create.
  $input: IssueLabelCreateInput!
  # Whether to replace all team-specific labels with the same name with this newly created workspace label (default: false).
  $replaceTeamLabels: Boolean
) {
  issueLabelCreate(input: $input, replaceTeamLabels: $replaceTeamLabels) {
    ...IssueLabelPayload
  }
}
# Deletes an issue label.
mutation deleteIssueLabel(
  # The identifier of the label to delete.
  $id: String!
) {
  issueLabelDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an label.
mutation updateIssueLabel(
  # The identifier of the label to update.
  $id: String!
  # A partial label object to update.
  $input: IssueLabelUpdateInput!
  # Whether to replace all team-specific labels with the same name with this updated workspace label (default: false).
  $replaceTeamLabels: Boolean
) {
  issueLabelUpdate(id: $id, input: $input, replaceTeamLabels: $replaceTeamLabels) {
    ...IssueLabelPayload
  }
}
# Creates a new issue relation.
mutation createIssueRelation(
  # The issue relation to create.
  $input: IssueRelationCreateInput!
  # Used by client undo operations. Should not be set directly.
  $overrideCreatedAt: DateTime
) {
  issueRelationCreate(input: $input, overrideCreatedAt: $overrideCreatedAt) {
    ...IssueRelationPayload
  }
}
# Deletes an issue relation.
mutation deleteIssueRelation(
  # The identifier of the issue relation to delete.
  $id: String!
) {
  issueRelationDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an issue relation.
mutation updateIssueRelation(
  # The identifier of the issue relation to update.
  $id: String!
  # The properties of the issue relation to update.
  $input: IssueRelationUpdateInput!
) {
  issueRelationUpdate(id: $id, input: $input) {
    ...IssueRelationPayload
  }
}
# Adds an issue reminder. Will cause a notification to be sent when the issue reminder time is
# reached.
mutation issueReminder(
  # The identifier of the issue to add a reminder for.
  $id: String!
  # The time when a reminder notification will be sent.
  $reminderAt: DateTime!
) {
  issueReminder(id: $id, reminderAt: $reminderAt) {
    ...IssuePayload
  }
}
# Removes a label from an issue.
mutation issueRemoveLabel(
  # The identifier of the issue to remove the label from.
  $id: String!
  # The identifier of the label to remove.
  $labelId: String!
) {
  issueRemoveLabel(id: $id, labelId: $labelId) {
    ...IssuePayload
  }
}
# Subscribes a user to an issue.
mutation issueSubscribe(
  # The identifier of the issue to subscribe to.
  $id: String!
  # The identifier of the user to subscribe, default is the current user.
  $userId: String
) {
  issueSubscribe(id: $id, userId: $userId) {
    ...IssuePayload
  }
}
# Unarchives an issue.
mutation unarchiveIssue(
  # The identifier of the issue to archive.
  $id: String!
) {
  issueUnarchive(id: $id) {
    ...IssueArchivePayload
  }
}
# Unsubscribes a user from an issue.
mutation issueUnsubscribe(
  # The identifier of the issue to unsubscribe from.
  $id: String!
  # The identifier of the user to unsubscribe, default is the current user.
  $userId: String
) {
  issueUnsubscribe(id: $id, userId: $userId) {
    ...IssuePayload
  }
}
# Updates an issue.
mutation updateIssue(
  # The identifier of the issue to update.
  $id: String!
  # A partial issue object to update the issue with.
  $input: IssueUpdateInput!
) {
  issueUpdate(id: $id, input: $input) {
    ...IssuePayload
  }
}
# Join an organization from onboarding.
mutation joinOrganizationFromOnboarding(
  # Organization details for the organization to join.
  $input: JoinOrganizationInput!
) {
  joinOrganizationFromOnboarding(input: $input) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Leave an organization.
mutation leaveOrganization(
  # ID of the organization to leave.
  $organizationId: String!
) {
  leaveOrganization(organizationId: $organizationId) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Logout the client.
mutation logout(
  # The reason for logging out.
  $reason: String
) {
  logout(reason: $reason) {
    ...LogoutResponse
  }
}
# Logout all of user's sessions including the active one.
mutation logoutAllSessions(
  # The reason for logging out.
  $reason: String
) {
  logoutAllSessions(reason: $reason) {
    ...LogoutResponse
  }
}
# Logout all of user's sessions excluding the current one.
mutation logoutOtherSessions(
  # The reason for logging out.
  $reason: String
) {
  logoutOtherSessions(reason: $reason) {
    ...LogoutResponse
  }
}
# Logout an individual session with its ID.
mutation logoutSession(
  # ID of the session to logout.
  $sessionId: String!
) {
  logoutSession(sessionId: $sessionId) {
    ...LogoutResponse
  }
}
# Archives a notification.
mutation archiveNotification(
  # The id of the notification to archive.
  $id: String!
) {
  notificationArchive(id: $id) {
    ...NotificationArchivePayload
  }
}
# Archives a notification and all related notifications.
mutation notificationArchiveAll(
  # The type and id of the entity to archive notifications for.
  $input: NotificationEntityInput!
) {
  notificationArchiveAll(input: $input) {
    ...NotificationBatchActionPayload
  }
}
# Subscribes to or unsubscribes from a notification category for a given notification channel for the
# user
mutation updateNotificationCategoryChannelSubscription(
  # The notification category to subscribe to or unsubscribe from
  $category: NotificationCategory!
  # The notification channel in which to subscribe to or unsubscribe from the category
  $channel: NotificationChannel!
  # True if the user wants to subscribe, false if the user wants to unsubscribe
  $subscribe: Boolean!
) {
  notificationCategoryChannelSubscriptionUpdate(category: $category, channel: $channel, subscribe: $subscribe) {
    ...UserSettingsPayload
  }
}
# Marks notification and all related notifications as read.
mutation notificationMarkReadAll(
  # The type and id of the entity to archive notifications for.
  $input: NotificationEntityInput!
  # The time when notification was marked as read.
  $readAt: DateTime!
) {
  notificationMarkReadAll(input: $input, readAt: $readAt) {
    ...NotificationBatchActionPayload
  }
}
# Marks notification and all related notifications as unread.
mutation notificationMarkUnreadAll(
  # The type and id of the entity to archive notifications for.
  $input: NotificationEntityInput!
) {
  notificationMarkUnreadAll(input: $input) {
    ...NotificationBatchActionPayload
  }
}
# Snoozes a notification and all related notifications.
mutation notificationSnoozeAll(
  # The type and id of the entity to archive notifications for.
  $input: NotificationEntityInput!
  # The time until a notification will be snoozed. After that it will appear in the inbox again.
  $snoozedUntilAt: DateTime!
) {
  notificationSnoozeAll(input: $input, snoozedUntilAt: $snoozedUntilAt) {
    ...NotificationBatchActionPayload
  }
}
# Creates a new notification subscription for a cycle, custom view, label, project or team.
mutation createNotificationSubscription(
  # The subscription object to create.
  $input: NotificationSubscriptionCreateInput!
) {
  notificationSubscriptionCreate(input: $input) {
    ...NotificationSubscriptionPayload
  }
}
# Deletes a notification subscription reference.
mutation deleteNotificationSubscription(
  # The identifier of the notification subscription reference to delete.
  $id: String!
) {
  notificationSubscriptionDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a notification subscription.
mutation updateNotificationSubscription(
  # The identifier of the notification subscription to update.
  $id: String!
  # A partial notification subscription object to update the notification subscription with.
  $input: NotificationSubscriptionUpdateInput!
) {
  notificationSubscriptionUpdate(id: $id, input: $input) {
    ...NotificationSubscriptionPayload
  }
}
# Unarchives a notification.
mutation unarchiveNotification(
  # The id of the notification to archive.
  $id: String!
) {
  notificationUnarchive(id: $id) {
    ...NotificationArchivePayload
  }
}
# Unsnoozes a notification and all related notifications.
mutation notificationUnsnoozeAll(
  # The type and id of the entity to archive notifications for.
  $input: NotificationEntityInput!
  # The time when the notification was unsnoozed.
  $unsnoozedAt: DateTime!
) {
  notificationUnsnoozeAll(input: $input, unsnoozedAt: $unsnoozedAt) {
    ...NotificationBatchActionPayload
  }
}
# Updates a notification.
mutation updateNotification(
  # The identifier of the notification to update.
  $id: String!
  # A partial notification object to update the notification with.
  $input: NotificationUpdateInput!
) {
  notificationUpdate(id: $id, input: $input) {
    ...NotificationPayload
  }
}
# Cancels the deletion of an organization. Administrator privileges required.
mutation deleteOrganizationCancel {
  organizationCancelDelete {
    ...OrganizationCancelDeletePayload
  }
}
# Delete's an organization. Administrator privileges required.
mutation deleteOrganization(
  # Information required to delete an organization.
  $input: DeleteOrganizationInput!
) {
  organizationDelete(input: $input) {
    ...OrganizationDeletePayload
  }
}
# Get an organization's delete confirmation token. Administrator privileges required.
mutation organizationDeleteChallenge {
  organizationDeleteChallenge {
    ...OrganizationDeletePayload
  }
}
# Deletes a domain.
mutation deleteOrganizationDomain(
  # The identifier of the domain to delete.
  $id: String!
) {
  organizationDomainDelete(id: $id) {
    ...DeletePayload
  }
}
# Creates a new organization invite.
mutation createOrganizationInvite(
  # The organization invite object to create.
  $input: OrganizationInviteCreateInput!
) {
  organizationInviteCreate(input: $input) {
    ...OrganizationInvitePayload
  }
}
# Deletes an organization invite.
mutation deleteOrganizationInvite(
  # The identifier of the organization invite to delete.
  $id: String!
) {
  organizationInviteDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an organization invite.
mutation updateOrganizationInvite(
  # The identifier of the organization invite to update.
  $id: String!
  # The updates to make to the organization invite object.
  $input: OrganizationInviteUpdateInput!
) {
  organizationInviteUpdate(id: $id, input: $input) {
    ...OrganizationInvitePayload
  }
}
# [DEPRECATED] Starts a trial for the organization. Administrator privileges required.
mutation organizationStartTrial {
  organizationStartTrial {
    ...OrganizationStartTrialPayload
  }
}
# Starts a trial for the organization on the specified plan type. Administrator privileges required.
mutation organizationStartTrialForPlan(
  # Plan details for trial
  $input: OrganizationStartTrialInput!
) {
  organizationStartTrialForPlan(input: $input) {
    ...OrganizationStartTrialPayload
  }
}
# Updates the user's organization.
mutation updateOrganization(
  # A partial organization object to update the organization with.
  $input: OrganizationUpdateInput!
) {
  organizationUpdate(input: $input) {
    ...OrganizationPayload
  }
}
# Archives a project.
mutation archiveProject(
  # The identifier of the project to archive. Also the identifier from the URL is accepted.
  $id: String!
  # Whether to trash the project.
  $trash: Boolean
) {
  projectArchive(id: $id, trash: $trash) {
    ...ProjectArchivePayload
  }
}
# Creates a new project.
mutation createProject(
  # Whether to connect a Slack channel to the project.
  $connectSlackChannel: Boolean
  # The issue object to create.
  $input: ProjectCreateInput!
) {
  projectCreate(connectSlackChannel: $connectSlackChannel, input: $input) {
    ...ProjectPayload
  }
}
# Deletes (trashes) a project.
mutation deleteProject(
  # The identifier of the project to delete.
  $id: String!
) {
  projectDelete(id: $id) {
    ...ProjectArchivePayload
  }
}
# Creates a new project milestone.
mutation createProjectMilestone(
  # The project milestone to create.
  $input: ProjectMilestoneCreateInput!
) {
  projectMilestoneCreate(input: $input) {
    ...ProjectMilestonePayload
  }
}
# Deletes a project milestone.
mutation deleteProjectMilestone(
  # The identifier of the project milestone to delete.
  $id: String!
) {
  projectMilestoneDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a project milestone.
mutation updateProjectMilestone(
  # The identifier of the project milestone to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial object to update the project milestone with.
  $input: ProjectMilestoneUpdateInput!
) {
  projectMilestoneUpdate(id: $id, input: $input) {
    ...ProjectMilestonePayload
  }
}
# Creates a new project relation.
mutation createProjectRelation(
  # The project relation to create.
  $input: ProjectRelationCreateInput!
) {
  projectRelationCreate(input: $input) {
    ...ProjectRelationPayload
  }
}
# Deletes a project relation.
mutation deleteProjectRelation(
  # The identifier of the project relation to delete.
  $id: String!
) {
  projectRelationDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a project relation.
mutation updateProjectRelation(
  # The identifier of the project relation to update.
  $id: String!
  # The properties of the project relation to update.
  $input: ProjectRelationUpdateInput!
) {
  projectRelationUpdate(id: $id, input: $input) {
    ...ProjectRelationPayload
  }
}
# Archives a project status.
mutation archiveProjectStatus(
  # The identifier of the project status to archive.
  $id: String!
) {
  projectStatusArchive(id: $id) {
    ...ProjectStatusArchivePayload
  }
}
# Creates a new project status.
mutation createProjectStatus(
  # The ProjectStatus object to create.
  $input: ProjectStatusCreateInput!
) {
  projectStatusCreate(input: $input) {
    ...ProjectStatusPayload
  }
}
# Unarchives a project status.
mutation unarchiveProjectStatus(
  # The identifier of the project status to unarchive.
  $id: String!
) {
  projectStatusUnarchive(id: $id) {
    ...ProjectStatusArchivePayload
  }
}
# Updates a project status.
mutation updateProjectStatus(
  # The identifier of the project status to update.
  $id: String!
  # A partial ProjectStatus object to update the ProjectStatus with.
  $input: ProjectStatusUpdateInput!
) {
  projectStatusUpdate(id: $id, input: $input) {
    ...ProjectStatusPayload
  }
}
# Unarchives a project.
mutation unarchiveProject(
  # The identifier of the project to restore. Also the identifier from the URL is accepted.
  $id: String!
) {
  projectUnarchive(id: $id) {
    ...ProjectArchivePayload
  }
}
# Updates a project.
mutation updateProject(
  # The identifier of the project to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial project object to update the project with.
  $input: ProjectUpdateInput!
) {
  projectUpdate(id: $id, input: $input) {
    ...ProjectPayload
  }
}
# Archives a project update.
mutation archiveProjectUpdate(
  # The identifier of the project update to archive.
  $id: String!
) {
  projectUpdateArchive(id: $id) {
    ...ProjectUpdateArchivePayload
  }
}
# Creates a new project update.
mutation createProjectUpdate(
  # Data for the project update to create.
  $input: ProjectUpdateCreateInput!
) {
  projectUpdateCreate(input: $input) {
    ...ProjectUpdatePayload
  }
}
# Deletes a project update.
mutation deleteProjectUpdate(
  # The identifier of the project update to delete.
  $id: String!
) {
  projectUpdateDelete(id: $id) {
    ...DeletePayload
  }
}
# Unarchives a project update.
mutation unarchiveProjectUpdate(
  # The identifier of the project update to unarchive.
  $id: String!
) {
  projectUpdateUnarchive(id: $id) {
    ...ProjectUpdateArchivePayload
  }
}
# Updates a project update.
mutation updateProjectUpdate(
  # The identifier of the project update to update.
  $id: String!
  # A data to update the project update with.
  $input: ProjectUpdateUpdateInput!
) {
  projectUpdateUpdate(id: $id, input: $input) {
    ...ProjectUpdatePayload
  }
}
# Creates a push subscription.
mutation createPushSubscription(
  # The push subscription to create.
  $input: PushSubscriptionCreateInput!
) {
  pushSubscriptionCreate(input: $input) {
    ...PushSubscriptionPayload
  }
}
# Deletes a push subscription.
mutation deletePushSubscription(
  # The identifier of the push subscription to delete.
  $id: String!
) {
  pushSubscriptionDelete(id: $id) {
    ...PushSubscriptionPayload
  }
}
# Creates a new reaction.
mutation createReaction(
  # The reaction object to create.
  $input: ReactionCreateInput!
) {
  reactionCreate(input: $input) {
    ...ReactionPayload
  }
}
# Deletes a reaction.
mutation deleteReaction(
  # The identifier of the reaction to delete.
  $id: String!
) {
  reactionDelete(id: $id) {
    ...DeletePayload
  }
}
# Manually update Google Sheets data.
mutation refreshGoogleSheetsData(
  # The identifier of the Google Sheets integration to update.
  $id: String!
) {
  refreshGoogleSheetsData(id: $id) {
    ...IntegrationPayload
  }
}
# Re-send an organization invite.
mutation resendOrganizationInvite(
  # The identifier of the organization invite to re-send.
  $id: String!
) {
  resendOrganizationInvite(id: $id) {
    ...DeletePayload
  }
}
# Re-send an organization invite tied to an email address.
mutation resendOrganizationInviteByEmail(
  # The email address tied to the organization invite to re-send.
  $email: String!
) {
  resendOrganizationInviteByEmail(email: $email) {
    ...DeletePayload
  }
}
# Archives a roadmap.
mutation archiveRoadmap(
  # The identifier of the roadmap to archive.
  $id: String!
) {
  roadmapArchive(id: $id) {
    ...RoadmapArchivePayload
  }
}
# Creates a new roadmap.
mutation createRoadmap(
  # The properties of the roadmap to create.
  $input: RoadmapCreateInput!
) {
  roadmapCreate(input: $input) {
    ...RoadmapPayload
  }
}
# Deletes a roadmap.
mutation deleteRoadmap(
  # The identifier of the roadmap to delete.
  $id: String!
) {
  roadmapDelete(id: $id) {
    ...DeletePayload
  }
}
# Creates a new roadmapToProject join.
mutation createRoadmapToProject(
  # The properties of the roadmapToProject to create.
  $input: RoadmapToProjectCreateInput!
) {
  roadmapToProjectCreate(input: $input) {
    ...RoadmapToProjectPayload
  }
}
# Deletes a roadmapToProject.
mutation deleteRoadmapToProject(
  # The identifier of the roadmapToProject to delete.
  $id: String!
) {
  roadmapToProjectDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates a roadmapToProject.
mutation updateRoadmapToProject(
  # The identifier of the roadmapToProject to update.
  $id: String!
  # The properties of the roadmapToProject to update.
  $input: RoadmapToProjectUpdateInput!
) {
  roadmapToProjectUpdate(id: $id, input: $input) {
    ...RoadmapToProjectPayload
  }
}
# Unarchives a roadmap.
mutation unarchiveRoadmap(
  # The identifier of the roadmap to unarchive.
  $id: String!
) {
  roadmapUnarchive(id: $id) {
    ...RoadmapArchivePayload
  }
}
# Updates a roadmap.
mutation updateRoadmap(
  # The identifier of the roadmap to update.
  $id: String!
  # The properties of the roadmap to update.
  $input: RoadmapUpdateInput!
) {
  roadmapUpdate(id: $id, input: $input) {
    ...RoadmapPayload
  }
}
# Authenticates a user account via email and authentication token for SAML.
mutation samlTokenUserAccountAuth(
  # The data used for token authentication.
  $input: TokenUserAccountAuthInput!
) {
  samlTokenUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Creates a new team. The user who creates the team will automatically be added as a member to the
# newly created team.
mutation createTeam(
  # The team id to copy settings from, if any.
  $copySettingsFromTeamId: String
  # The team object to create.
  $input: TeamCreateInput!
) {
  teamCreate(copySettingsFromTeamId: $copySettingsFromTeamId, input: $input) {
    ...TeamPayload
  }
}
# Deletes team's cycles data
mutation deleteTeamCycles(
  # The identifier of the team, which cycles will be deleted.
  $id: String!
) {
  teamCyclesDelete(id: $id) {
    ...TeamPayload
  }
}
# Deletes a team.
mutation deleteTeam(
  # The identifier of the team to delete.
  $id: String!
) {
  teamDelete(id: $id) {
    ...DeletePayload
  }
}
# Deletes a previously used team key.
mutation deleteTeamKey(
  # The identifier of the team key to delete.
  $id: String!
) {
  teamKeyDelete(id: $id) {
    ...DeletePayload
  }
}
# Creates a new team membership.
mutation createTeamMembership(
  # The team membership object to create.
  $input: TeamMembershipCreateInput!
) {
  teamMembershipCreate(input: $input) {
    ...TeamMembershipPayload
  }
}
# Deletes a team membership.
mutation deleteTeamMembership(
  # Whether to leave the parent teams.
  $alsoLeaveParentTeams: Boolean
  # The identifier of the team membership to delete.
  $id: String!
) {
  teamMembershipDelete(alsoLeaveParentTeams: $alsoLeaveParentTeams, id: $id) {
    ...DeletePayload
  }
}
# Updates a team membership.
mutation updateTeamMembership(
  # The identifier of the team membership to update.
  $id: String!
  # A partial team membership object to update the team membership with.
  $input: TeamMembershipUpdateInput!
) {
  teamMembershipUpdate(id: $id, input: $input) {
    ...TeamMembershipPayload
  }
}
# Unarchives a team and cancels deletion.
mutation unarchiveTeam(
  # The identifier of the team to delete.
  $id: String!
) {
  teamUnarchive(id: $id) {
    ...TeamArchivePayload
  }
}
# Updates a team.
mutation updateTeam(
  # The identifier of the team to update.
  $id: String!
  # A partial team object to update the team with.
  $input: TeamUpdateInput!
  # [INTERNAL] Mapping of existing team entities to those inherited from the parent team
  $mapping: InheritanceEntityMapping
) {
  teamUpdate(id: $id, input: $input, mapping: $mapping) {
    ...TeamPayload
  }
}
# Creates a new template.
mutation createTemplate(
  # The template object to create.
  $input: TemplateCreateInput!
) {
  templateCreate(input: $input) {
    ...TemplatePayload
  }
}
# Deletes a template.
mutation deleteTemplate(
  # The identifier of the template to delete.
  $id: String!
) {
  templateDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an existing template.
mutation updateTemplate(
  # The identifier of the template.
  $id: String!
  # The properties of the template to update.
  $input: TemplateUpdateInput!
) {
  templateUpdate(id: $id, input: $input) {
    ...TemplatePayload
  }
}
# Creates a new time schedule.
mutation createTimeSchedule(
  # The properties of the time schedule to create.
  $input: TimeScheduleCreateInput!
) {
  timeScheduleCreate(input: $input) {
    ...TimeSchedulePayload
  }
}
# Deletes a time schedule.
mutation deleteTimeSchedule(
  # The identifier of the time schedule to delete.
  $id: String!
) {
  timeScheduleDelete(id: $id) {
    ...DeletePayload
  }
}
# Refresh the integration schedule information.
mutation timeScheduleRefreshIntegrationSchedule(
  # The identifier of the time schedule to refresh.
  $id: String!
) {
  timeScheduleRefreshIntegrationSchedule(id: $id) {
    ...TimeSchedulePayload
  }
}
# Updates a time schedule.
mutation updateTimeSchedule(
  # The identifier of the time schedule to update.
  $id: String!
  # The properties of the time schedule to update.
  $input: TimeScheduleUpdateInput!
) {
  timeScheduleUpdate(id: $id, input: $input) {
    ...TimeSchedulePayload
  }
}
# Upsert an external time schedule.
mutation timeScheduleUpsertExternal(
  # The unique identifier of the external schedule.
  $externalId: String!
  # The properties of the time schedule to insert or update.
  $input: TimeScheduleUpdateInput!
) {
  timeScheduleUpsertExternal(externalId: $externalId, input: $input) {
    ...TimeSchedulePayload
  }
}
# Creates a new triage responsibility.
mutation createTriageResponsibility(
  # The properties of the triage responsibility to create.
  $input: TriageResponsibilityCreateInput!
) {
  triageResponsibilityCreate(input: $input) {
    ...TriageResponsibilityPayload
  }
}
# Deletes a triage responsibility.
mutation deleteTriageResponsibility(
  # The identifier of the triage responsibility to delete.
  $id: String!
) {
  triageResponsibilityDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an existing triage responsibility.
mutation updateTriageResponsibility(
  # The identifier of the triage responsibility to update.
  $id: String!
  # The properties of the triage responsibility to update.
  $input: TriageResponsibilityUpdateInput!
) {
  triageResponsibilityUpdate(id: $id, input: $input) {
    ...TriageResponsibilityPayload
  }
}
# Makes user a regular user. Can only be called by an admin.
mutation userDemoteAdmin(
  # The identifier of the user to make a regular user.
  $id: String!
) {
  userDemoteAdmin(id: $id) {
    ...UserAdminPayload
  }
}
# Makes user a guest. Can only be called by an admin.
mutation userDemoteMember(
  # The identifier of the user to make a guest.
  $id: String!
) {
  userDemoteMember(id: $id) {
    ...UserAdminPayload
  }
}
# Connects the Discord user to this Linear account via OAuth2.
mutation userDiscordConnect(
  # The Discord OAuth code.
  $code: String!
  # The Discord OAuth redirect URI.
  $redirectUri: String!
) {
  userDiscordConnect(code: $code, redirectUri: $redirectUri) {
    ...UserPayload
  }
}
# Disconnects the external user from this Linear account.
mutation userExternalUserDisconnect(
  # The external service to disconnect.
  $service: String!
) {
  userExternalUserDisconnect(service: $service) {
    ...UserPayload
  }
}
# Updates a user's settings flag.
mutation updateUserFlag(
  # Settings flag to increment.
  $flag: UserFlagType!
  # Flag operation to perform.
  $operation: UserFlagUpdateOperation!
) {
  userFlagUpdate(flag: $flag, operation: $operation) {
    ...UserSettingsFlagPayload
  }
}
# Makes user an admin. Can only be called by an admin.
mutation userPromoteAdmin(
  # The identifier of the user to make an admin.
  $id: String!
) {
  userPromoteAdmin(id: $id) {
    ...UserAdminPayload
  }
}
# Makes user a regular user. Can only be called by an admin.
mutation userPromoteMember(
  # The identifier of the user to make a regular user.
  $id: String!
) {
  userPromoteMember(id: $id) {
    ...UserAdminPayload
  }
}
# Resets user's setting flags.
mutation userSettingsFlagsReset(
  # The flags to reset. If not provided all flags will be reset.
  $flags: [UserFlagType!]
) {
  userSettingsFlagsReset(flags: $flags) {
    ...UserSettingsFlagsResetPayload
  }
}
# Updates the user's settings.
mutation updateUserSettings(
  # The identifier of the userSettings to update.
  $id: String!
  # A partial notification object to update the settings with.
  $input: UserSettingsUpdateInput!
) {
  userSettingsUpdate(id: $id, input: $input) {
    ...UserSettingsPayload
  }
}
# Suspends a user. Can only be called by an admin.
mutation suspendUser(
  # The identifier of the user to suspend.
  $id: String!
) {
  userSuspend(id: $id) {
    ...UserAdminPayload
  }
}
# Un-suspends a user. Can only be called by an admin.
mutation unsuspendUser(
  # The identifier of the user to unsuspend.
  $id: String!
) {
  userUnsuspend(id: $id) {
    ...UserAdminPayload
  }
}
# Updates a user. Only available to organization admins and the user themselves.
mutation updateUser(
  # The identifier of the user to update. Use `me` to reference currently authenticated user.
  $id: String!
  # A partial user object to update the user with.
  $input: UserUpdateInput!
) {
  userUpdate(id: $id, input: $input) {
    ...UserPayload
  }
}
# Creates a new ViewPreferences object.
mutation createViewPreferences(
  # The ViewPreferences object to create.
  $input: ViewPreferencesCreateInput!
) {
  viewPreferencesCreate(input: $input) {
    ...ViewPreferencesPayload
  }
}
# Deletes a ViewPreferences.
mutation deleteViewPreferences(
  # The identifier of the ViewPreferences to delete.
  $id: String!
) {
  viewPreferencesDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an existing ViewPreferences object.
mutation updateViewPreferences(
  # The identifier of the ViewPreferences object.
  $id: String!
  # The properties of the view preferences.
  $input: ViewPreferencesUpdateInput!
) {
  viewPreferencesUpdate(id: $id, input: $input) {
    ...ViewPreferencesPayload
  }
}
# Creates a new webhook.
mutation createWebhook(
  # The webhook object to create.
  $input: WebhookCreateInput!
) {
  webhookCreate(input: $input) {
    ...WebhookPayload
  }
}
# Deletes a Webhook.
mutation deleteWebhook(
  # The identifier of the Webhook to delete.
  $id: String!
) {
  webhookDelete(id: $id) {
    ...DeletePayload
  }
}
# Updates an existing Webhook.
mutation updateWebhook(
  # The identifier of the Webhook.
  $id: String!
  # The properties of the Webhook.
  $input: WebhookUpdateInput!
) {
  webhookUpdate(id: $id, input: $input) {
    ...WebhookPayload
  }
}
# Archives a state. Only states with issues that have all been archived can be archived.
mutation archiveWorkflowState(
  # The identifier of the state to archive.
  $id: String!
) {
  workflowStateArchive(id: $id) {
    ...WorkflowStateArchivePayload
  }
}
# Creates a new state, adding it to the workflow of a team.
mutation createWorkflowState(
  # The state to create.
  $input: WorkflowStateCreateInput!
) {
  workflowStateCreate(input: $input) {
    ...WorkflowStatePayload
  }
}
# Updates a state.
mutation updateWorkflowState(
  # The identifier of the state to update.
  $id: String!
  # A partial state object to update.
  $input: WorkflowStateUpdateInput!
) {
  workflowStateUpdate(id: $id, input: $input) {
    ...WorkflowStatePayload
  }
}
