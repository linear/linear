# A comment associated with an issue.
fragment Comment on Comment {
  # Comment's URL.
  url
  # The comment content in markdown format.
  body
  # The issue that the comment is associated with.
  issue {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time user edited the comment.
  editedAt
  # The unique identifier of the entity.
  id
  # The user who wrote the comment.
  user {
    id
  }
}

# A custom emoji.
fragment Emoji on Emoji {
  # The emoji image URL.
  url
  # The emoji's name.
  name
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The source of the emoji.
  source
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the emoji.
  creator {
    id
  }
}

# A custom view that has been saved by a user.
fragment CustomView on CustomView {
  # The color of the icon of the custom view.
  color
  # The description of the custom view.
  description
  # The filters applied to issues in the custom view.
  filters
  # The icon of the custom view.
  icon
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The name of the custom view.
  name
  # The team associated with the custom view.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the custom view.
  creator {
    id
  }
  # Whether the custom view is shared with everyone in the organization.
  shared
}

# A milestone that contains projects.
fragment Milestone on Milestone {
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The name of the milestone.
  name
  # The sort order for the milestone.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A notification sent to a user.
fragment Notification on Notification {
  # Name of the reaction emoji associated with the notification.
  reactionEmoji
  # Notification type
  type
  # The comment which the notification is associated with.
  comment {
    id
  }
  # The issue that the notification is associated with.
  issue {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The recipient of the notification.
  user {
    id
  }
  # The team which the notification is associated with.
  team {
    id
  }
  # The time at when an email reminder for this notification was sent to the user. Null, if no email
  #     reminder has been sent.
  emailedAt
  # The time at when the user marked the notification as read. Null, if the the user hasn't read the notification
  readAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A project.
fragment Project on Project {
  # The estimated completion date of the project.
  targetDate
  # The icon of the project.
  icon
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The milestone that this project is associated with.
  milestone {
    id
  }
  # The number of completed estimation points after each week.
  completedScopeHistory
  # The number of completed issues in the project after each week.
  completedIssueCountHistory
  # The project lead.
  lead {
    id
  }
  # The project's color.
  color
  # The project's description.
  description
  # The project's name.
  name
  # The project's unique URL slug.
  slugId
  # The sort order for the project within its milestone.
  sortOrder
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the project was moved into canceled state.
  canceledAt
  # The time at which the project was moved into completed state.
  completedAt
  # The time at which the project was moved into started state.
  startedAt
  # The total number of estimation points after each week.
  scopeHistory
  # The total number of issues in the project after each week.
  issueCountHistory
  # The type of the state.
  state
  # The unique identifier of the entity.
  id
  # The user who created the project.
  creator {
    id
  }
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
  # [Internal] The estimated start date of the project.
  startDate
}

# A reaction associated with a comment.
fragment Reaction on Reaction {
  # Name of the reaction's emoji.
  emoji
  # The comment that the reaction is associated with.
  comment {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who reacted.
  user {
    id
  }
}

# A record of changes to an issue.
fragment IssueHistory on IssueHistory {
  # Changed issue relationships.
  relationChanges {
    ...IssueRelationHistoryPayload
  }
  # ID's of labels that were added.
  addedLabelIds
  # ID's of labels that were removed.
  removedLabelIds
  # Information about the integration or application which created this history entry.
  source
  # The issue that was changed.
  issue {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The new cycle of the issue.
  toCycle {
    id
  }
  # The new parent of the issue.
  toParent {
    id
  }
  # The new project of the issue.
  toProject {
    id
  }
  # The new workflow state of the issue.
  toState {
    id
  }
  # The previous cycle of the issue.
  fromCycle {
    id
  }
  # The previous parent of the issue.
  fromParent {
    id
  }
  # The previous project of the issue.
  fromProject {
    id
  }
  # The previous workflow state of the issue.
  fromState {
    id
  }
  # The team from which the issue was moved from.
  fromTeam {
    id
  }
  # The team to which the issue was moved to.
  toTeam {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user from whom the issue was re-assigned from.
  fromAssignee {
    id
  }
  # The user to whom the issue was assigned to.
  toAssignee {
    id
  }
  # The user who made these changes. If null, possibly means that the change made by an integration.
  actor {
    id
  }
  # What the due date was changed from
  fromDueDate
  # What the due date was changed to
  toDueDate
  # What the estimate was changed from.
  fromEstimate
  # What the estimate was changed to.
  toEstimate
  # What the priority was changed from.
  fromPriority
  # What the priority was changed to.
  toPriority
  # What the title was changed from.
  fromTitle
  # What the title was changed to.
  toTitle
  # Whether the issue was archived or un-archived.
  archived
  # Whether the issue's description was updated.
  updatedDescription
  autoArchived
  autoClosed
}

# A recorded entry of a file uploaded by a user.
fragment FileUpload on FileUpload {
  # Additional metadata of the file.
  metaData
  # Size of the uploaded file in bytes.
  size
  # The MIME type of the uploaded file.
  contentType
  # The asset URL this file is available at.
  assetUrl
  # The name of the uploaded file.
  filename
  # The unique identifier of the entity.
  id
  # The user who uploaded the file.
  creator {
    id
  }
}

# A relation between two issues.
fragment IssueRelation on IssueRelation {
  # The issue whose relationship is being described.
  issue {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The related issue.
  relatedIssue {
    id
  }
  # The relationship of the issue with the related issue.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A set of issues to be resolved in a specified amount of time.
fragment Cycle on Cycle {
  # The completion time of the cycle. If null, the cycle hasn't been completed.
  completedAt
  # The custom name of the cycle.
  name
  # The end time of the cycle.
  endsAt
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The number of completed estimation points after each day.
  completedScopeHistory
  # The number of completed issues in the cycle after each day.
  completedIssueCountHistory
  # The number of the cycle.
  number
  # The start time of the cycle.
  startsAt
  # The team that the cycle is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The total number of estimation points after each day.
  scopeHistory
  # The total number of issues in the cycle after each day.
  issueCountHistory
  # The unique identifier of the entity.
  id
}

# A state in a team workflow.
fragment WorkflowState on WorkflowState {
  # Description of the state.
  description
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The position of the state in the team flow.
  position
  # The state's UI color as a HEX string.
  color
  # The state's name.
  name
  # The team to which this state belongs to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the state.
  type
  # The unique identifier of the entity.
  id
}

# A template object used for creating new issues faster.
fragment Template on Template {
  # Template data.
  templateData
  # Template description.
  description
  # The entity type this template is for.
  type
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The name of the template.
  name
  # The team that the template is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the template.
  creator {
    id
  }
}

# A user account.
fragment UserAccount on UserAccount {
  # The authentication service used to create the account.
  service
  # The models identifier.
  id
  # The time at which the model was archived.
  archivedAt
  # The time at which the model was created.
  createdAt
  # The time at which the model was updated.
  updatedAt
  # The user's email address.
  email
  # The user's name.
  name
  # Users belonging to the account.
  users {
    ...User
  }
}

# A user that has access to the the resources of an organization.
fragment User on User {
  # An URL to the user's avatar image.
  avatarUrl
  # Number of issues created.
  createdIssueCount
  # Reason why is the account disabled.
  disableReason
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The last time the user was seen online. If null, the user is currently online.
  lastSeen
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user's display (nick) name. Unique within each organization.
  displayName
  # The user's email address.
  email
  # The user's full name.
  name
  # Unique hash for the user to be used in invite URLs.
  inviteHash
  # Whether the user account is active or disabled.
  active
  # Whether the user is an organization administrator.
  admin
}

# A user's web browser push notification subscription.
fragment PushSubscription on PushSubscription {
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# A webhook used to send HTTP notifications over data updates
fragment Webhook on Webhook {
  # Secret token for verifying the origin on the recipient side.
  secret
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The resource types this webhook is subscribed to.
  resourceTypes
  # The team that the webhook is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the webhook.
  creator {
    id
  }
  # Webhook URL
  url
  # Webhook label
  label
  # Whether the Webhook is enabled.
  enabled
}

# An API key. Grants access to the user's resources.
fragment ApiKey on ApiKey {
  # The label of the API key.
  label
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# An external link for a project.
fragment ProjectLink on ProjectLink {
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The link's URL.
  url
  # The link's label.
  label
  # The project that the link is associated with.
  project {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the link.
  creator {
    id
  }
}

# An import job for data from an external service
fragment IssueImport on IssueImport {
  # The data mapping configuration for the import job.
  mapping
  # The id for the user that started the job.
  creatorId
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The service from which data will be imported.
  service
  # The status for the import job.
  status
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # User readable error message, if one has occurred during the import.
  error
}

# An integration resource created by an external service.
fragment IntegrationResource on IntegrationResource {
  # Detailed information about the external resource.
  data {
    ...IntegrationResourceData
  }
  # Pull request information for GitHub pull requests and GitLab merge requests.
  pullRequest {
    ...PullRequestPayload
  }
  # The external service resource ID.
  resourceId
  # The integration that the resource is associated with.
  integration {
    id
  }
  # The integration's type.
  resourceType
  # The issue that the resource is associated with.
  issue {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# An integration with an external service.
fragment Integration on Integration {
  # The integration's type.
  service
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The team that the integration is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that added the integration.
  creator {
    id
  }
}

# An invitation to the organization that has been sent via email.
fragment OrganizationInvite on OrganizationInvite {
  # The invite was sent to external address.
  external
  # The invitees email address.
  email
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the invite was accepted. Null, if the invite hasn't been accepted
  acceptedAt
  # The time at which the invite will be expiring. Null, if the invite shouldn't expire
  expiresAt
  # The unique identifier of the entity.
  id
  # The user who created the invitation.
  inviter {
    id
  }
  # The user who has accepted the invite. Null, if the invite hasn't been accepted.
  invitee {
    id
  }
}

# An issue.
fragment Issue on Issue {
  # A flag that indicates whether the issue is in the trash bin.
  trashed
  # Issue URL.
  url
  # Issue's human readable identifier (e.g. ENG-123).
  identifier
  # Label for the priority.
  priorityLabel
  # Previous identifiers of the issue if it has been moved between teams.
  previousIdentifiers
  # Suggested branch name for the issue.
  branchName
  # The cycle that the issue is associated with.
  cycle {
    id
  }
  # The date at which the issue is due.
  dueDate
  # The estimate of the complexity of the issue..
  estimate
  # The issue's description in markdown format.
  description
  # The issue's title.
  title
  # The issue's unique number.
  number
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The order of the item in its column on the board.
  boardOrder
  # The order of the item in the sub-issue list. Only set if the issue has a parent.
  subIssueSortOrder
  # The parent of the issue.
  parent {
    id
  }
  # The priority of the issue.
  priority
  # The project that the issue is associated with.
  project {
    id
  }
  # The team that the issue is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The time at which the issue was automatically archived by the auto pruning process.
  autoArchivedAt
  # The time at which the issue was automatically closed by the auto pruning process.
  autoClosedAt
  # The time at which the issue was moved into canceled state.
  canceledAt
  # The time at which the issue was moved into completed state.
  completedAt
  # The time at which the issue was moved into started state.
  startedAt
  # The unique identifier of the entity.
  id
  # The user to whom the issue is assigned to.
  assignee {
    id
  }
  # The user who created the issue.
  creator {
    id
  }
  # The workflow state that the issue is associated with.
  state {
    id
  }
}

# An organization. Organizations are root-level objects that contain user accounts and teams.
fragment Organization on Organization {
  # Allowed authentication providers, empty array means all are allowed
  allowedAuthServices
  # How git branches are formatted. If null, default formatting will be used.
  gitBranchFormat
  # Number of active users in the organization.
  userCount
  # Number of issues in the organization.
  createdIssueCount
  # Rolling 30-day total upload volume for the organization, in megabytes.
  periodUploadVolume
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The organization's logo URL.
  logoUrl
  # The organization's name.
  name
  # The organization's unique URL key.
  urlKey
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # Whether SAML authentication is enabled for organization.
  samlEnabled
  # Whether the Git integration linkback messages should be sent to private repositories.
  gitLinkbackMessagesEnabled
  # Whether the Git integration linkback messages should be sent to public repositories.
  gitPublicLinkbackMessagesEnabled
  # Whether the organization is using a roadmap.
  roadmapEnabled
}

# An organizational unit that contains issues.
fragment Team on Team {
  # Auto assign completed issues to current cycle.
  cycleIssueAutoAssignCompleted
  # Auto assign started issues to current cycle.
  cycleIssueAutoAssignStarted
  # Calender feed (iCal) for cycles.
  cycleCalenderUrl
  # How many upcoming cycles to create.
  upcomingCycleCount
  # Internal. Whether the team is private or not.
  private
  # Only allow issues issues with cycles in Active Issues.
  cycleLockToActive
  # Period after which automatically closed and completed issues are automatically archived in months. Null/undefined means disabled.
  autoArchivePeriod
  # Period after which issues are automatically closed in months. Null/undefined means disabled.
  autoClosePeriod
  # Team's currently active cycle.
  activeCycle {
    id
  }
  # The canceled workflow state which auto closed issues will be set to. Defaults to the first canceled state.
  autoCloseStateId
  # The cooldown time after each cycle in weeks.
  cycleCooldownTime
  # The day of the week that a new cycle starts.
  cycleStartDay
  # The default template to use for new issues created by members of the team.
  defaultTemplateForMembersId
  # The default template to use for new issues created by non-members of the team.
  defaultTemplateForNonMembersId
  # The duration of a cycle in weeks.
  cycleDuration
  # The issue estimation type to use.
  issueEstimationType
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The team's description.
  description
  # The team's name.
  name
  # The team's unique key. The key is used in URLs.
  key
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The timezone of the team. Defaults to "America/Los_Angeles"
  timezone
  # The unique identifier of the entity.
  id
  # The workflow state into which issues are moved when a PR has been merged.
  mergeWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR has been opened as draft.
  draftWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a PR has been opened.
  startWorkflowState {
    id
  }
  # The workflow state into which issues are moved when a review has been requested for the PR.
  reviewWorkflowState {
    id
  }
  # The workflow state into which issues are moved when they are marked as a duplicate of another issue. Defaults to the first canceled state.
  markedAsDuplicateWorkflowState {
    id
  }
  # Unique hash for the team to be used in invite URLs.
  inviteHash
  # What to use as an default estimate for unestimated issues.
  defaultIssueEstimate
  # Whether the team uses cycles.
  cyclesEnabled
  # Whether to add additional points to the estimate scale.
  issueEstimationExtended
  # Whether to allow zeros in issues estimates.
  issueEstimationAllowZero
  # Whether to group recent issue history entries.
  groupIssueHistory
  # Whether to send new issue comment notifications to Slack.
  slackIssueComments
  # Whether to send new issue notifications to Slack.
  slackNewIssue
  # Whether to send new issue status updates to Slack.
  slackIssueStatuses
}

# Collaborative editing steps for documents.
fragment DocumentStep on DocumentStep {
  # Connected client ID.
  clientId
  # Step data.
  step
  # Step version.
  version
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# Contains either the full serialized state of the application or delta packets that the requester can
# apply to the local data set in order to be up-to-date.
fragment SyncResponse on SyncResponse {
  # JSON serialized delta changes that the client can apply to its local state
  #     in order to catch up with the state of the world.
  delta
  # The full state of the organization as a serialized JSON object.
  #     Mutually exclusive with the delta property
  state
  # The last sync id covered by the response.
  lastSyncId
  # The sync groups that the user is subscribed to.
  subscribedSyncGroups
  # The version of the remote database. Incremented by 1 for each migration run on the database.
  databaseVersion
}

# Contains requested archived model objects.
fragment ArchiveResponse on ArchiveResponse {
  # A JSON serialized collection of model objects loaded from the archive
  archive
  # The total number of entities in the archive.
  totalCount
  # The version of the remote database. Incremented by 1 for each migration run on the database.
  databaseVersion
}

# Defines the membership of a user to a team.
fragment TeamMembership on TeamMembership {
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The team that the membership is associated with.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user that the membership is associated with.
  user {
    id
  }
  # Whether the user is the owner of the team
  owner
}

# Defines the use of a domain by an organization.
fragment OrganizationDomain on OrganizationDomain {
  # Domain name
  name
  # E-mail used to verify this domain
  verificationEmail
  # Is this domain verified
  verified
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who added the domain.
  creator {
    id
  }
}

# GitHub OAuth token, plus information about the organizations the user is a member of.
fragment GithubOAuthTokenPayload on GithubOAuthTokenPayload {
  # A list of the GitHub organizations the user is a member of with attached repositories.
  organizations {
    ...GithubOrg
  }
  # The OAuth token if the operation to fetch it was successful.
  token
}

# GitHub's commit data
fragment CommitPayload on CommitPayload {
  added
  id
  message
  modified
  removed
  timestamp
  url
}

# Google Sheets specific settings.
fragment GoogleSheetsSettings on GoogleSheetsSettings {
  sheetId
  spreadsheetId
  spreadsheetUrl
  updatedIssuesAt
}

# Integration resource's payload
fragment IntegrationResourceData on IntegrationResourceData {
  # The payload for an IntegrationResource of type 'githubCommit'
  githubCommit {
    ...CommitPayload
  }
  # The payload for an IntegrationResource of type 'githubPullRequest'
  githubPullRequest {
    ...PullRequestPayload
  }
  # The payload for an IntegrationResource of type 'gitlabMergeRequest'
  gitlabMergeRequest {
    ...PullRequestPayload
  }
  # The payload for an IntegrationResource of type 'sentryIssue'
  sentryIssue {
    ...SentryIssuePayload
  }
}

# Issue relation history's payload
fragment IssueRelationHistoryPayload on IssueRelationHistoryPayload {
  # The identifier of the related issue.
  identifier
  # The type of the change.
  type
}

# Labels that can be associated with issues.
fragment IssueLabel on IssueLabel {
  # The label's color as a HEX string.
  color
  # The label's description.
  description
  # The label's name.
  name
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The team to which the label belongs to.
  team {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user who created the label.
  creator {
    id
  }
}

# Notification subscriptions for models.
fragment NotificationSubscription on NotificationSubscription {
  # Subscribed project.
  project {
    id
  }
  # Subscribed team.
  team {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the subscription.
  type
  # The unique identifier of the entity.
  id
  # The user associated with notification subscriptions.
  user {
    id
  }
}

# OAuth2 client application
fragment OauthClient on OauthClient {
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # List of allowed redirect URIs for the application.
  redirectUris
  # Name of the developer.
  developer
  # OAuth application's client ID.
  clientId
  # OAuth application's client name.
  name
  # OAuth application's client secret.
  clientSecret
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # Url of the developer.
  developerUrl
}

# Object representing Figma preview information.
fragment FigmaEmbed on FigmaEmbed {
  # Date when the file was updated at the time of embedding.
  lastModified
  # Figma file name.
  name
  # Figma screenshot URL.
  url
  # Node name.
  nodeName
}

# Object representing Google Cloud upload policy, plus additional data.
fragment UploadFile on UploadFile {
  # The asset URL for the uploaded file. (assigned automatically)
  assetUrl
  # The content type.
  contentType
  # The filename.
  filename
  # The signed URL the for the uploaded file. (assigned automatically)
  uploadUrl
  # The size of the uploaded file.
  size
  headers {
    ...UploadFileHeader
  }
  metaData
}

# Public information of the OAuth application, plus the authorized scopes for a given user.
fragment AuthorizedApplication on AuthorizedApplication {
  # Application name.
  name
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's ID.
  appId
  # OAuth application's client ID.
  clientId
  # Scopes that are authorized for this application for a given user.
  scope
  # Url of the developer (homepage or docs).
  developerUrl
}

# Public information of the OAuth application, plus whether the application has been authorized for
# the given scopes.
fragment UserAuthorizedApplication on UserAuthorizedApplication {
  # Application name.
  name
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's client ID.
  clientId
  # Url of the developer (homepage or docs).
  developerUrl
  # Whether the user has authorized the application for the given scopes.
  isAuthorized
}

# Public information of the OAuth application.
fragment Application on Application {
  # Application name.
  name
  # Image of the application.
  imageUrl
  # Information about the application.
  description
  # Name of the developer.
  developer
  # OAuth application's client ID.
  clientId
  # Url of the developer (homepage or docs).
  developerUrl
}

# Pull request data
fragment PullRequestPayload on PullRequestPayload {
  branch
  closedAt
  createdAt
  draft
  id
  mergedAt
  number
  repoLogin
  repoName
  status
  title
  updatedAt
  url
  userId
  userLogin
}

# Relevant information for the GitHub organization.
fragment GithubOrg on GithubOrg {
  # GitHub organization id.
  id
  # Repositories that the organization owns.
  repositories {
    ...GithubRepo
  }
  # The login for the GitHub organization.
  login
  # The name of the GitHub organization.
  name
}

# Relevant information for the GitHub repository.
fragment GithubRepo on GithubRepo {
  # The id of the GitHub repository.
  id
  # The name of the GitHub repository.
  name
}

# Sentry issue data
fragment SentryIssuePayload on SentryIssuePayload {
  # The Sentry identifier for the issue.
  issueId
  # The Sentry identifier of the actor who created the issue.
  actorId
  # The Sentry identifier of the project this issue belongs to.
  projectId
  # The date this issue was first seen.
  firstSeen
  # The description of the issue.
  webUrl
  # The name of the Sentry actor who created this issue.
  actorName
  # The name of the first release version this issue appeared on, if available.
  firstVersion
  # The shortId of the issue.
  shortId
  # The slug of the project this issue belongs to.
  projectSlug
  # The title of the issue.
  issueTitle
  # The type of the actor who created the issue.
  actorType
}

# Sentry specific settings.
fragment SentrySettings on SentrySettings {
  # The slug of the Sentry organization being connected.
  organizationSlug
}

# Slack notification specific settings.
fragment SlackPostSettings on SlackPostSettings {
  channel
  channelId
  configurationUrl
}

# The integration resource's settings
fragment IntegrationSettings on IntegrationSettings {
  googleSheets {
    ...GoogleSheetsSettings
  }
  sentry {
    ...SentrySettings
  }
  slackPost {
    ...SlackPostSettings
  }
  slackProjectPost {
    ...SlackPostSettings
  }
  zendesk {
    ...ZendeskSettings
  }
}

# The integration resource's settings
fragment SamlConfiguration on SamlConfiguration {
  # Binding method for authentication call. Can be either `post` (default) or `redirect`.
  ssoBinding
  # List of allowed email domains for SAML authentication.
  allowedDomains
  # Sign in endpoint URL for the identity provider.
  ssoEndpoint
  # The algorithm of the Signing Certificate. Can be one of `sha1`, `sha256` (default), or `sha512`.
  ssoSignAlgo
  # X.509 Signing Certificate in string form.
  ssoSigningCert
}

# The settings of a user as a JSON object.
fragment UserSettings on UserSettings {
  # The email types the user has unsubscribed from.
  unsubscribedFrom
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The notification channel settings the user has selected.
  notificationPreferences
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The user associated with these settings.
  user {
    id
  }
}

# The subscription of an organization.
fragment Subscription on Subscription {
  # The creator of the subscription.
  creator {
    id
  }
  # The date the subscription was canceled, if any.
  canceledAt
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The number of seats in the subscription.
  seats
  # The subscription type of a pending change. Null if no change pending.
  pendingChangeType
  # The subscription type.
  type
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

# User favorites presented in the sidebar.
fragment Favorite on Favorite {
  # Favorited cycle.
  cycle {
    id
  }
  # Favorited issue label.
  label {
    id
  }
  # Favorited issue.
  issue {
    id
  }
  # Favorited project team.
  projectTeam {
    id
  }
  # Favorited project.
  project {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The order of the item in the favorites list.
  sortOrder
  # The owner of the favorite.
  user {
    id
  }
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The type of the favorite.
  type
  # The unique identifier of the entity.
  id
}

# View preferences.
fragment ViewPreferences on ViewPreferences {
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
  # The view preference type.
  type
  # The view type.
  viewType
}

# Zendesk specific settings.
fragment ZendeskSettings on ZendeskSettings {
  # The ID of the Linear bot user.
  botUserId
  # The URL of the connected Zendesk organization.
  url
  # The subdomain of the Zendesk organization being connected.
  subdomain
}

# [Alpha] Issue attachment (e.g. support ticket, pull request).
fragment Attachment on Attachment {
  # Content for the subtitle line in the Linear attachment widget.
  subtitle
  # Content for the title line in the Linear attachment widget.
  title
  # Custom metadata related to the attachment.
  metadata
  # Indicates if attachments for the same source application should be grouped in the Linear UI.
  groupBySource
  # Information about the source which created the attachment.
  source
  # Location of the attachment which is also used as an identifier. Attachment URLs are unique and calls to create a new attachment are idempotent with the URL.
  url
  # The issue this attachment belongs to.
  issue {
    id
  }
  # The last time at which the entity was updated. This is the same as the creation time if the
  #     entity hasn't been update after creation.
  updatedAt
  # The time at which the entity was archived. Null if the entity has not been archived.
  archivedAt
  # The time at which the entity was created.
  createdAt
  # The unique identifier of the entity.
  id
}

fragment ApiKeyConnection on ApiKeyConnection {
  nodes {
    ...ApiKey
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ApiKeyPayload on ApiKeyPayload {
  # The API key that was created.
  apiKey {
    ...ApiKey
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ArchivePayload on ArchivePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment AttachmentConnection on AttachmentConnection {
  nodes {
    ...Attachment
  }
  pageInfo {
    ...PageInfo
  }
}

fragment AttachmentPayload on AttachmentPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The issue attachment that was created.
  attachment {
    id
  }
  # Whether the operation was successful.
  success
}

fragment AuthResolverResponse on AuthResolverResponse {
  # Email for the authenticated account.
  email
  # JWT token for authentication of the account.
  token
  # Organizations this account has access to, but is not yet a member.
  availableOrganizations {
    ...Organization
  }
  # Should the signup flow allow access for the domain.
  allowDomainAccess
  # User account ID.
  id
  # Users belonging to this account.
  users {
    ...User
  }
}

fragment BillingDetailsPayload on BillingDetailsPayload {
  # List of invoices, if any.
  invoices {
    ...Invoice
  }
  # The customer's email address the invoices are sent to.
  email
  # The payment method.
  paymentMethod {
    ...Card
  }
  # Whether the operation was successful.
  success
}

fragment BillingEmailPayload on BillingEmailPayload {
  # The customer's email address the invoices are sent to.
  email
  # Whether the operation was successful.
  success
}

fragment Card on Card {
  # The brand of the card, e.g. Visa.
  brand
  # The last four digits used to identify the card.
  last4
}

fragment CollaborationDocumentUpdatePayload on CollaborationDocumentUpdatePayload {
  # Document steps the client has not seen yet and need to rebase it's local steps on.
  steps {
    ...StepsResponse
  }
  # Whether the operation was successful.
  success
}

fragment CommentConnection on CommentConnection {
  nodes {
    ...Comment
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CommentPayload on CommentPayload {
  # The comment that was created or updated.
  comment {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ContactPayload on ContactPayload {
  # Whether the operation was successful.
  success
}

fragment CreateCsvExportReportPayload on CreateCsvExportReportPayload {
  # Whether the operation was successful.
  success
}

fragment CreateOrJoinOrganizationResponse on CreateOrJoinOrganizationResponse {
  user {
    id
  }
}

fragment CustomViewConnection on CustomViewConnection {
  nodes {
    ...CustomView
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CustomViewPayload on CustomViewPayload {
  # The custom view that was created or updated.
  customView {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment CycleConnection on CycleConnection {
  nodes {
    ...Cycle
  }
  pageInfo {
    ...PageInfo
  }
}

fragment CyclePayload on CyclePayload {
  # The Cycle that was created or updated.
  cycle {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment DebugPayload on DebugPayload {
  # Whether the operation was successful.
  success
}

fragment EmailUnsubscribePayload on EmailUnsubscribePayload {
  # Whether the operation was successful.
  success
}

fragment EmailUserAccountAuthChallengeResponse on EmailUserAccountAuthChallengeResponse {
  # Supported challenge for this user account. Can be either verificationCode or password.
  authType
  # Whether the operation was successful.
  success
}

fragment EmojiConnection on EmojiConnection {
  nodes {
    ...Emoji
  }
  pageInfo {
    ...PageInfo
  }
}

fragment EmojiPayload on EmojiPayload {
  # The emoji that was created.
  emoji {
    id
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment EventPayload on EventPayload {
  # Whether the operation was successful.
  success
}

fragment FavoriteConnection on FavoriteConnection {
  nodes {
    ...Favorite
  }
  pageInfo {
    ...PageInfo
  }
}

fragment FavoritePayload on FavoritePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The object that was added as a favorite.
  favorite {
    id
  }
  # Whether the operation was successful.
  success
}

fragment FeedbackPayload on FeedbackPayload {
  # Whether the operation was successful.
  success
}

fragment FigmaEmbedPayload on FigmaEmbedPayload {
  # Figma embed information.
  figmaEmbed {
    ...FigmaEmbed
  }
  # Whether the operation was successful.
  success
}

fragment ImageUploadFromUrlPayload on ImageUploadFromUrlPayload {
  # The URL containing the image.
  url
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment IntegrationConnection on IntegrationConnection {
  nodes {
    ...Integration
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IntegrationPayload on IntegrationPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The integration that was created or updated.
  integration {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IntegrationResourceConnection on IntegrationResourceConnection {
  nodes {
    ...IntegrationResource
  }
  pageInfo {
    ...PageInfo
  }
}

fragment InviteData on InviteData {
  # Avatar URLs for the invitees.
  avatarURLs
  # Team identifiers for the invitees.
  teamIds
  # Team names for the invitees.
  teamNames
  # The domain of the organization the users were invited to.
  organizationDomain
  # The logo of the organization the users were invited to.
  organizationLogoUrl
  # The name of the inviter.
  inviterName
  # The name of the organization the users were invited to.
  organizationName
  # The user count of the organization.
  userCount
}

fragment InvitePagePayload on InvitePagePayload {
  # Invite data.
  inviteData {
    ...InviteData
  }
  # Whether the operation was successful.
  success
}

fragment Invoice on Invoice {
  # The URL at which the invoice can be viewed or paid.
  url
  # The creation date of the invoice.
  created
  # The due date of the invoice.
  dueDate
  # The invoice total, in cents.
  total
  # The status of the invoice.
  status
}

fragment IssueConnection on IssueConnection {
  nodes {
    ...Issue
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueHistoryConnection on IssueHistoryConnection {
  nodes {
    ...IssueHistory
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueImportDeletePayload on IssueImportDeletePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The import job that was deleted.
  issueImport {
    ...IssueImport
  }
  # Whether the operation was successful.
  success
}

fragment IssueImportPayload on IssueImportPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The import job that was created or updated.
  issueImport {
    ...IssueImport
  }
  # Whether the operation was successful.
  success
}

fragment IssueLabelConnection on IssueLabelConnection {
  nodes {
    ...IssueLabel
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueLabelPayload on IssueLabelPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The label that was created or updated.
  issueLabel {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssuePayload on IssuePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The issue that was created or updated.
  issue {
    id
  }
  # Whether the operation was successful.
  success
}

fragment IssuePriorityValue on IssuePriorityValue {
  # Priority's label.
  label
  # Priority's number value.
  priority
}

fragment IssueRelationConnection on IssueRelationConnection {
  nodes {
    ...IssueRelation
  }
  pageInfo {
    ...PageInfo
  }
}

fragment IssueRelationPayload on IssueRelationPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The issue relation that was created or updated.
  issueRelation {
    id
  }
  # Whether the operation was successful.
  success
}

fragment MilestoneConnection on MilestoneConnection {
  nodes {
    ...Milestone
  }
  pageInfo {
    ...PageInfo
  }
}

fragment MilestonePayload on MilestonePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The milesteone that was created or updated.
  milestone {
    id
  }
  # Whether the operation was successful.
  success
}

fragment NotificationConnection on NotificationConnection {
  nodes {
    ...Notification
  }
  pageInfo {
    ...PageInfo
  }
}

fragment NotificationPayload on NotificationPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The notification that was created or updated.
  notification {
    id
  }
  # Whether the operation was successful.
  success
}

fragment NotificationSubscriptionConnection on NotificationSubscriptionConnection {
  nodes {
    ...NotificationSubscription
  }
  pageInfo {
    ...PageInfo
  }
}

fragment NotificationSubscriptionPayload on NotificationSubscriptionPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The notification subscription that was created or updated.
  notificationSubscription {
    id
  }
  # Whether the operation was successful.
  success
}

fragment OauthClientPayload on OauthClientPayload {
  # The OAuth client application that was created or updated.
  oauthClient {
    ...OauthClient
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment OauthTokenRevokePayload on OauthTokenRevokePayload {
  # Whether the operation was successful.
  success
}

fragment OrganizationDeletePayload on OrganizationDeletePayload {
  # Whether the operation was successful.
  success
}

fragment OrganizationDomainPayload on OrganizationDomainPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The organization domain that was created or updated.
  organizationDomain {
    ...OrganizationDomain
  }
  # Whether the operation was successful.
  success
}

fragment OrganizationDomainSimplePayload on OrganizationDomainSimplePayload {
  # Whether the operation was successful.
  success
}

fragment OrganizationExistsPayload on OrganizationExistsPayload {
  # Whether the operation was successful.
  success
  # Whether the organization exists.
  exists
}

fragment OrganizationInviteConnection on OrganizationInviteConnection {
  nodes {
    ...OrganizationInvite
  }
  pageInfo {
    ...PageInfo
  }
}

fragment OrganizationInvitePayload on OrganizationInvitePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The organization invite that was created or updated.
  organizationInvite {
    ...OrganizationInvite
  }
  # Whether the operation was successful.
  success
}

fragment OrganizationPayload on OrganizationPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment PageInfo on PageInfo {
  # Cursor representing the first result in the paginated results.
  startCursor
  # Cursor representing the last result in the paginated results.
  endCursor
  # Indicates if there are more results when paginating backward.
  hasPreviousPage
  # Indicates if there are more results when paginating forward.
  hasNextPage
}

fragment ProjectConnection on ProjectConnection {
  nodes {
    ...Project
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectLinkConnection on ProjectLinkConnection {
  nodes {
    ...ProjectLink
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ProjectLinkPayload on ProjectLinkPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The project that was created or updated.
  projectLink {
    id
  }
  # Whether the operation was successful.
  success
}

fragment ProjectPayload on ProjectPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The project that was created or updated.
  project {
    id
  }
  # Whether the operation was successful.
  success
}

fragment PushSubscriptionConnection on PushSubscriptionConnection {
  nodes {
    ...PushSubscription
  }
  pageInfo {
    ...PageInfo
  }
}

fragment PushSubscriptionPayload on PushSubscriptionPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment ReactionConnection on ReactionConnection {
  nodes {
    ...Reaction
  }
  pageInfo {
    ...PageInfo
  }
}

fragment ReactionPayload on ReactionPayload {
  # The identifier of the last sync operation.
  lastSyncId
  reaction {
    id
  }
  success
}

fragment RotateSecretPayload on RotateSecretPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment SsoUrlFromEmailResponse on SsoUrlFromEmailResponse {
  # SAML SSO sign-in URL.
  samlSsoUrl
  # Whether the operation was successful.
  success
}

fragment StepsResponse on StepsResponse {
  # Client's document version.
  version
  # List of client IDs for the document steps.
  clientIds
  # New document steps from the client.
  steps
}

fragment SubscriptionPayload on SubscriptionPayload {
  # The date the subscription was set to cancel at the end of the billing period, if any.
  canceledAt
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment SubscriptionSessionPayload on SubscriptionSessionPayload {
  # The subscription session that was created or updated.
  session
}

fragment SynchronizedPayload on SynchronizedPayload {
  # The identifier of the last sync operation.
  lastSyncId
}

fragment TeamConnection on TeamConnection {
  nodes {
    ...Team
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TeamMembershipConnection on TeamMembershipConnection {
  nodes {
    ...TeamMembership
  }
  pageInfo {
    ...PageInfo
  }
}

fragment TeamMembershipPayload on TeamMembershipPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The team membership that was created or updated.
  teamMembership {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TeamPayload on TeamPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The team that was created or updated.
  team {
    id
  }
  # Whether the operation was successful.
  success
}

fragment TemplateConnection on TemplateConnection {
  pageInfo {
    ...PageInfo
  }
}

fragment TemplatePayload on TemplatePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The template that was created or updated.
  template {
    id
  }
  # Whether the operation was successful.
  success
}

fragment UploadFileHeader on UploadFileHeader {
  # Upload file header key.
  key
  # Upload file header value.
  value
}

fragment UploadPayload on UploadPayload {
  # Object describing the file to be uploaded.
  uploadFile {
    ...UploadFile
  }
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserAdminPayload on UserAdminPayload {
  # Whether the operation was successful.
  success
}

fragment UserConnection on UserConnection {
  nodes {
    ...User
  }
  pageInfo {
    ...PageInfo
  }
}

fragment UserPayload on UserPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The user that was created or updated.
  user {
    id
  }
  # Whether the operation was successful.
  success
}

fragment UserSettingsFlagPayload on UserSettingsFlagPayload {
  # The flag key which was updated.
  flag
  # The flag value after update.
  value
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSettingsFlagsResetPayload on UserSettingsFlagsResetPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSettingsPayload on UserSettingsPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # Whether the operation was successful.
  success
}

fragment UserSubscribeToNewsletterPayload on UserSubscribeToNewsletterPayload {
  # Whether the operation was successful.
  success
}

fragment ViewPreferencesPayload on ViewPreferencesPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The view preferences entity being mutated.
  viewPreferences {
    ...ViewPreferences
  }
  # Whether the operation was successful.
  success
}

fragment WebhookConnection on WebhookConnection {
  nodes {
    ...Webhook
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WebhookPayload on WebhookPayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The webhook entity being mutated.
  webhook {
    id
  }
  # Whether the operation was successful.
  success
}

fragment WorkflowStateConnection on WorkflowStateConnection {
  nodes {
    ...WorkflowState
  }
  pageInfo {
    ...PageInfo
  }
}

fragment WorkflowStatePayload on WorkflowStatePayload {
  # The identifier of the last sync operation.
  lastSyncId
  # The state that was created or updated.
  workflowState {
    id
  }
  # Whether the operation was successful.
  success
}

# All API keys for the user.
query apiKeys(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  apiKeys(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ApiKeyConnection
  }
}
# Get information for an application and whether a user has approved it for the given scopes.
query applicationWithAuthorization(
  # The client ID of the application.
  $clientId: String!
  # Redirect URI for the application.
  $redirectUri: String
  # Scopes being requested by the application
  $scope: [String!]!
) {
  applicationWithAuthorization(clientId: $clientId, redirectUri: $redirectUri, scope: $scope) {
    ...UserAuthorizedApplication
  }
}
# Fetches an archived model.
query archivedModelSync(
  # The identifier of the model to load. What an identifier is specific to the model class.
  $identifier: String!
  # The class name of the model to load.
  $modelClass: String!
) {
  archivedModelSync(identifier: $identifier, modelClass: $modelClass) {
    ...ArchiveResponse
  }
}
# Fetches archived models.
query archivedModelsSync(
  # Retrieve issues that have been archived before this date.
  $before: DateTime
  # The number of issues to load.
  $last: Int
  # The class name of the models to load.
  $modelClass: String!
  # The teamId for which to load archived models.
  $teamId: String!
  # How trashed issues should be loaded. Defaults to TrashOptionType.excludeTrash
  $trashOption: TrashOptionType
) {
  archivedModelsSync(
    before: $before
    last: $last
    modelClass: $modelClass
    teamId: $teamId
    trashOption: $trashOption
  ) {
    ...ArchiveResponse
  }
}
# [Alpha] One specific issue attachment. `url` can be used as the `id` parameter.
query attachment($id: String!) {
  attachment(id: $id) {
    ...Attachment
  }
}
# [Alpha] Query an issue by its associated attachment, and its id or URI.
query attachmentIssue(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
) {
  attachmentIssue(id: $id) {
    ...Issue
  }
}
# Attachments associated with the issue.
query attachmentIssue_attachments(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    attachments(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# Children of the issue.
query attachmentIssue_children(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    children(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query attachmentIssue_comments(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    comments(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query attachmentIssue_history(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query attachmentIssue_inverseRelations(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query attachmentIssue_labels(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    labels(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Relations associated with this issue.
query attachmentIssue_relations(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query attachmentIssue_subscribers(
  # `id` or `url` of the attachment for which you'll want to get the issue for.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachmentIssue(id: $id) {
    subscribers(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# [Alpha] All issue attachments.
query attachments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  attachments(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...AttachmentConnection
  }
}
# Get all authorized applications for a user
query authorizedApplications {
  authorizedApplications {
    ...AuthorizedApplication
  }
}
# Fetch users belonging to this user account.
query availableUsers {
  availableUsers {
    ...AuthResolverResponse
  }
}
# Billing details for the customer.
query billingDetails {
  billingDetails {
    ...BillingDetailsPayload
  }
}
# The payment method.
query billingDetails_paymentMethod {
  billingDetails {
    paymentMethod {
      ...Card
    }
  }
}
# Join collaborative document and get missing steps.
query collaborativeDocumentJoin(
  # The identifier of the client.
  $clientId: String!
  # The identifier of the Issue to join.
  $issueId: String!
  # Document version.
  $version: Int!
) {
  collaborativeDocumentJoin(clientId: $clientId, issueId: $issueId, version: $version) {
    ...CollaborationDocumentUpdatePayload
  }
}
# Document steps the client has not seen yet and need to rebase it's local steps on.
query collaborativeDocumentJoin_steps(
  # The identifier of the client.
  $clientId: String!
  # The identifier of the Issue to join.
  $issueId: String!
  # Document version.
  $version: Int!
) {
  collaborativeDocumentJoin(clientId: $clientId, issueId: $issueId, version: $version) {
    steps {
      ...StepsResponse
    }
  }
}
# A specific comment.
query comment(
  # The identifier of the comment to retrieve.
  $id: String!
) {
  comment(id: $id) {
    ...Comment
  }
}
# All comments.
query comments(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  comments(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CommentConnection
  }
}
# One specific custom view.
query customView($id: String!) {
  customView(id: $id) {
    ...CustomView
  }
}
# Custom views for the user.
query customViews(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  customViews(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CustomViewConnection
  }
}
# One specific cycle.
query cycle($id: String!) {
  cycle(id: $id) {
    ...Cycle
  }
}
# Issues associated with the cycle.
query cycle_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycle(id: $id) {
    issues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues that weren't completed when the cycle was closed.
query cycle_uncompletedIssuesUponClose(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycle(id: $id) {
    uncompletedIssuesUponClose(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All cycles.
query cycles(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  cycles(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...CycleConnection
  }
}
# A specific emoji.
query emoji(
  # The identifier of the emoji to retrieve.
  $id: String!
) {
  emoji(id: $id) {
    ...Emoji
  }
}
# All custom emojis.
query emojis(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  emojis(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...EmojiConnection
  }
}
# One specific favorite.
query favorite($id: String!) {
  favorite(id: $id) {
    ...Favorite
  }
}
# The user's favorites.
query favorites(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  favorites(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...FavoriteConnection
  }
}
# Fetch Figma screenshot and other information with file and node identifiers.
query figmaEmbedInfo(
  # Figma file identifier.
  $fileId: String!
  # Figma node identifier.
  $nodeId: String
) {
  figmaEmbedInfo(fileId: $fileId, nodeId: $nodeId) {
    ...FigmaEmbedPayload
  }
}
# Figma embed information.
query figmaEmbedInfo_figmaEmbed(
  # Figma file identifier.
  $fileId: String!
  # Figma node identifier.
  $nodeId: String
) {
  figmaEmbedInfo(fileId: $fileId, nodeId: $nodeId) {
    figmaEmbed {
      ...FigmaEmbed
    }
  }
}
# One specific integration.
query integration($id: String!) {
  integration(id: $id) {
    ...Integration
  }
}
# All integrations.
query integrations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  integrations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IntegrationConnection
  }
}
# Retrieves information for the public invite page.
query inviteInfo(
  # Team hash.
  $teamHash: String
  # User hash.
  $userHash: String!
) {
  inviteInfo(teamHash: $teamHash, userHash: $userHash) {
    ...InvitePagePayload
  }
}
# Invite data.
query inviteInfo_inviteData(
  # Team hash.
  $teamHash: String
  # User hash.
  $userHash: String!
) {
  inviteInfo(teamHash: $teamHash, userHash: $userHash) {
    inviteData {
      ...InviteData
    }
  }
}
# One specific issue.
query issue($id: String!) {
  issue(id: $id) {
    ...Issue
  }
}
# Attachments associated with the issue.
query issue_attachments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    attachments(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...AttachmentConnection
    }
  }
}
# Children of the issue.
query issue_children(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    children(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Comments associated with the issue.
query issue_comments(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    comments(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CommentConnection
    }
  }
}
# History entries associated with the issue.
query issue_history(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    history(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueHistoryConnection
    }
  }
}
# Inverse relations associated with this issue.
query issue_inverseRelations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    inverseRelations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Labels associated with this issue.
query issue_labels(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    labels(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Relations associated with this issue.
query issue_relations(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    relations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueRelationConnection
    }
  }
}
# Users who are subscribed to the issue.
query issue_subscribers(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issue(id: $id) {
    subscribers(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Fetches the GitHub token, completing the OAuth flow.
query issueImportFinishGithubOAuth(
  # OAuth code.
  $code: String!
) {
  issueImportFinishGithubOAuth(code: $code) {
    ...GithubOAuthTokenPayload
  }
}
# One specific label.
query issueLabel($id: String!) {
  issueLabel(id: $id) {
    ...IssueLabel
  }
}
# Issues associated with the label.
query issueLabel_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabel(id: $id) {
    issues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All issue labels.
query issueLabels(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueLabels(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueLabelConnection
  }
}
# Issue priority values and corresponding labels.
query issuePriorityValues {
  issuePriorityValues {
    ...IssuePriorityValue
  }
}
# One specific issue relation.
query issueRelation($id: String!) {
  issueRelation(id: $id) {
    ...IssueRelation
  }
}
# All issue relationships.
query issueRelations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issueRelations(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueRelationConnection
  }
}
# [ALPHA] Search issues. This query is experimental and is subject to change without notice.
query issueSearch(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
  # Search string to look for.
  $query: String!
) {
  issueSearch(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
    query: $query
  ) {
    ...IssueConnection
  }
}
# All issues.
query issues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  issues(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...IssueConnection
  }
}
# One specific milestone.
query milestone($id: String!) {
  milestone(id: $id) {
    ...Milestone
  }
}
# Projects associated with the milestone.
query milestone_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  milestone(id: $id) {
    projects(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# All milestones.
query milestones(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  milestones(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...MilestoneConnection
  }
}
# One specific notification.
query notification($id: String!) {
  notification(id: $id) {
    ...Notification
  }
}
# One specific notification subscription.
query notificationSubscription($id: String!) {
  notificationSubscription(id: $id) {
    ...NotificationSubscription
  }
}
# The user's notification subscriptions.
query notificationSubscriptions(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  notificationSubscriptions(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...NotificationSubscriptionConnection
  }
}
# All notifications.
query notifications(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  notifications(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...NotificationConnection
  }
}
# The user's organization.
query organization {
  organization {
    ...Organization
  }
}
# Integrations associated with the organization.
query organization_integrations(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    integrations(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IntegrationConnection
    }
  }
}
# Milestones associated with the organization.
query organization_milestones(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    milestones(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...MilestoneConnection
    }
  }
}
# Teams associated with the organization.
query organization_teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    teams(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# Users associated with the organization.
query organization_users(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organization {
    users(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Does the organization exist.
query organizationExists($urlKey: String!) {
  organizationExists(urlKey: $urlKey) {
    ...OrganizationExistsPayload
  }
}
# One specific organization invite.
query organizationInvite($id: String!) {
  organizationInvite(id: $id) {
    ...IssueLabel
  }
}
# Issues associated with the label.
query organizationInvite_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organizationInvite(id: $id) {
    issues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All invites for the organization.
query organizationInvites(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  organizationInvites(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...OrganizationInviteConnection
  }
}
# One specific project.
query project($id: String!) {
  project(id: $id) {
    ...Project
  }
}
# Issues associated with the project.
query project_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    issues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Links associated with the project.
query project_links(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    links(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectLinkConnection
    }
  }
}
# Users that are members of the project.
query project_members(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    members(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Teams associated with this project.
query project_teams(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  project(id: $id) {
    teams(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# One specific project link.
query projectLink($id: String!) {
  projectLink(id: $id) {
    ...ProjectLink
  }
}
# All links for the project.
query projectLinks(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projectLinks(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectLinkConnection
  }
}
# All projects.
query projects(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  projects(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ProjectConnection
  }
}
# Sends a test push message.
query pushSubscriptionTest {
  pushSubscriptionTest {
    ...PushSubscriptionPayload
  }
}
# A specific reaction.
query reaction(
  # The identifier to retrieve.
  $id: String!
) {
  reaction(id: $id) {
    ...Reaction
  }
}
# All comment emoji reactions.
query reactions(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  reactions(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...ReactionConnection
  }
}
# Fetch SSO login URL for the email provided.
query ssoUrlFromEmail(
  # Email to query the SSO login URL by.
  $email: String!
  # Whether the client is the desktop app.
  $isDesktop: Boolean
) {
  ssoUrlFromEmail(email: $email, isDesktop: $isDesktop) {
    ...SsoUrlFromEmailResponse
  }
}
# The organization's subscription.
query subscription {
  subscription {
    ...Subscription
  }
}
# Fetch data to catch up the client to the state of the world.
query syncBootstrap(
  # Deprecated.
  $databaseVersion: Int
  # Deprecated.
  $sinceSyncId: Int
  # If defined, only entities for the given sync groups will be loaded
  $syncGroups: [String!]
) {
  syncBootstrap(databaseVersion: $databaseVersion, sinceSyncId: $sinceSyncId, syncGroups: $syncGroups) {
    ...SyncResponse
  }
}
# One specific team.
query team($id: String!) {
  team(id: $id) {
    ...Team
  }
}
# Cycles associated with the team.
query team_cycles(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    cycles(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...CycleConnection
    }
  }
}
# Issues associated with the team.
query team_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    issues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Labels associated with the team.
query team_labels(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    labels(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueLabelConnection
    }
  }
}
# Users who are members of this team.
query team_members(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    members(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...UserConnection
    }
  }
}
# Memberships associated with the team. For easier access of the same data, use `members` query.
query team_memberships(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    memberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Projects associated with the team.
query team_projects(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    projects(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...ProjectConnection
    }
  }
}
# The states that define the workflow associated with the team.
query team_states(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    states(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...WorkflowStateConnection
    }
  }
}
# Templates associated with the team.
query team_templates(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    templates(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TemplateConnection
    }
  }
}
# Webhooks associated with the team.
query team_webhooks(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  team(id: $id) {
    webhooks(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...WebhookConnection
    }
  }
}
# One specific team membership.
query teamMembership($id: String!) {
  teamMembership(id: $id) {
    ...TeamMembership
  }
}
# All team memberships.
query teamMemberships(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  teamMemberships(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamMembershipConnection
  }
}
# All teams.
query teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  teams(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...TeamConnection
  }
}
# A specific template.
query template(
  # The identifier of the template to retrieve.
  $id: String!
) {
  template(id: $id) {
    ...Template
  }
}
# All templates from all users.
query templates {
  templates {
    ...Template
  }
}
# One specific user.
query user(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
) {
  user(id: $id) {
    ...User
  }
}
# Issues assigned to the user.
query user_assignedIssues(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    assignedIssues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues created by the user.
query user_createdIssues(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    createdIssues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Memberships associated with the user. For easier access of the same data, use `teams` query.
query user_teamMemberships(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    teamMemberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Teams the user is part of.
query user_teams(
  # The identifier of the user to retrieve. To retrieve the authenticated user, use `viewer` query.
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  user(id: $id) {
    teams(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# The user's settings.
query userSettings {
  userSettings {
    ...UserSettings
  }
}
# All users for the organization.
query users(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  users(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...UserConnection
  }
}
# The currently authenticated user.
query viewer {
  viewer {
    ...User
  }
}
# Issues assigned to the user.
query viewer_assignedIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    assignedIssues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Issues created by the user.
query viewer_createdIssues(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    createdIssues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# Memberships associated with the user. For easier access of the same data, use `teams` query.
query viewer_teamMemberships(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    teamMemberships(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamMembershipConnection
    }
  }
}
# Teams the user is part of.
query viewer_teams(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  viewer {
    teams(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...TeamConnection
    }
  }
}
# A specific webhook.
query webhook(
  # The identifier of the webhook to retrieve.
  $id: String!
) {
  webhook(id: $id) {
    ...Webhook
  }
}
# All webhooks.
query webhooks(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  webhooks(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...WebhookConnection
  }
}
# One specific state.
query workflowState($id: String!) {
  workflowState(id: $id) {
    ...WorkflowState
  }
}
# Issues belonging in this state.
query workflowState_issues(
  $id: String!
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  workflowState(id: $id) {
    issues(
      after: $after
      before: $before
      first: $first
      includeArchived: $includeArchived
      last: $last
      orderBy: $orderBy
    ) {
      ...IssueConnection
    }
  }
}
# All issue workflow states.
query workflowStates(
  # A cursor to be used with first for forward pagination
  $after: String
  # A cursor to be used with last for backward pagination.
  $before: String
  # The number of items to forward paginate (used with after). Defaults to 50.
  $first: Int
  # Should archived resources be included (default: false)
  $includeArchived: Boolean
  # The number of items to backward paginate (used with before). Defaults to 50.
  $last: Int
  # By which field should the pagination order by. Available options are createdAt (default) and updatedAt.
  $orderBy: PaginationOrderBy
) {
  workflowStates(
    after: $after
    before: $before
    first: $first
    includeArchived: $includeArchived
    last: $last
    orderBy: $orderBy
  ) {
    ...WorkflowStateConnection
  }
}
# Creates a new API key.
mutation apiKeyCreate(
  # The api key object to create.
  $input: ApiKeyCreateInput!
) {
  apiKeyCreate(input: $input) {
    ...ApiKeyPayload
  }
}
# Deletes an API key.
mutation apiKeyDelete(
  # The identifier of the API key to delete.
  $id: String!
) {
  apiKeyDelete(id: $id) {
    ...ArchivePayload
  }
}
# [Alpha] Archives an issue attachment.
mutation attachmentArchive(
  # The identifier of the attachment to delete.
  $id: String!
) {
  attachmentArchive(id: $id) {
    ...ArchivePayload
  }
}
# [Alpha] Creates a new attachment, or updates existing if the same `uri` is used.
mutation attachmentCreate(
  # The attachment object to create.
  $input: AttachmentCreateInput!
) {
  attachmentCreate(input: $input) {
    ...AttachmentPayload
  }
}
# [Alpha] Updates an existing issue attachment.
mutation attachmentUpdate(
  # The identifier of the comment to update.
  $id: String!
  # A partial attachment object to update the attachment with.
  $input: AttachmentUpdateInput!
) {
  attachmentUpdate(id: $id, input: $input) {
    ...AttachmentPayload
  }
}
# Updates the billing email address for the customer.
mutation billingEmailUpdate(
  # The properties of the billing details.
  $input: BillingEmailUpdateInput!
) {
  billingEmailUpdate(input: $input) {
    ...BillingEmailPayload
  }
}
# Update collaborative document with client steps.
mutation collaborativeDocumentUpdate($input: CollaborationDocumentUpdateInput!) {
  collaborativeDocumentUpdate(input: $input) {
    ...CollaborationDocumentUpdatePayload
  }
}
# Creates a new comment.
mutation commentCreate(
  # The comment object to create.
  $input: CommentCreateInput!
) {
  commentCreate(input: $input) {
    ...CommentPayload
  }
}
# Deletes a comment.
mutation commentDelete(
  # The identifier of the comment to delete.
  $id: String!
) {
  commentDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a comment.
mutation commentUpdate(
  # The identifier of the comment to update.
  $id: String!
  # A partial comment object to update the comment with.
  $input: CommentUpdateInput!
) {
  commentUpdate(id: $id, input: $input) {
    ...CommentPayload
  }
}
# Saves user message.
mutation contactCreate(
  # The contact entry to create.
  $input: ContactCreateInput!
) {
  contactCreate(input: $input) {
    ...ContactPayload
  }
}
# Create CSV export report for the organization.
mutation createCsvExportReport($includePrivateTeamIds: [String!]) {
  createCsvExportReport(includePrivateTeamIds: $includePrivateTeamIds) {
    ...CreateCsvExportReportPayload
  }
}
# Creates an organization from onboarding.
mutation createOrganizationFromOnboarding(
  # Organization details for the new organization.
  $input: CreateOrganizationInput!
  # Onboarding survey.
  $survey: OnboardingCustomerSurvey
) {
  createOrganizationFromOnboarding(input: $input, survey: $survey) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Creates a new custom view.
mutation customViewCreate(
  # The properties of the custom view to create.
  $input: CustomViewCreateInput!
) {
  customViewCreate(input: $input) {
    ...CustomViewPayload
  }
}
# Deletes a custom view.
mutation customViewDelete(
  # The identifier of the custom view to delete.
  $id: String!
) {
  customViewDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a custom view.
mutation customViewUpdate(
  # The identifier of the custom view to update.
  $id: String!
  # The properties of the custom view to update.
  $input: CustomViewUpdateInput!
) {
  customViewUpdate(id: $id, input: $input) {
    ...CustomViewPayload
  }
}
# Archives a cycle.
mutation cycleArchive(
  # The identifier of the cycle to archive.
  $id: String!
) {
  cycleArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new cycle.
mutation cycleCreate(
  # The cycle object to create.
  $input: CycleCreateInput!
) {
  cycleCreate(input: $input) {
    ...CyclePayload
  }
}
# Updates a cycle.
mutation cycleUpdate(
  # The identifier of the cycle to update.
  $id: String!
  # A partial cycle object to update the cycle with.
  $input: CycleUpdateInput!
) {
  cycleUpdate(id: $id, input: $input) {
    ...CyclePayload
  }
}
# Create the SAML test organization in development.
mutation debugCreateSAMLOrg {
  debugCreateSAMLOrg {
    ...DebugPayload
  }
}
# Always fails with internal error. Used to debug logging.
mutation debugFailWithInternalError {
  debugFailWithInternalError {
    ...DebugPayload
  }
}
# Always logs an error to Sentry as warning. Used to debug logging.
mutation debugFailWithWarning {
  debugFailWithWarning {
    ...DebugPayload
  }
}
# Authenticates a user account via email and authentication token.
mutation emailTokenUserAccountAuth(
  # The data used for token authentication.
  $input: TokenUserAccountAuthInput!
) {
  emailTokenUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Unsubscribes the user from one type of emails.
mutation emailUnsubscribe(
  # Unsubscription details.
  $input: EmailUnsubscribeInput!
) {
  emailUnsubscribe(input: $input) {
    ...EmailUnsubscribePayload
  }
}
# Finds or creates a new user account by email and sends an email with token.
mutation emailUserAccountAuthChallenge(
  # The data used for email authentication.
  $input: EmailUserAccountAuthChallengeInput!
) {
  emailUserAccountAuthChallenge(input: $input) {
    ...EmailUserAccountAuthChallengeResponse
  }
}
# Creates a custom emoji.
mutation emojiCreate(
  # The emoji object to create.
  $input: EmojiCreateInput!
) {
  emojiCreate(input: $input) {
    ...EmojiPayload
  }
}
# Deletes an emoji.
mutation emojiDelete(
  # The identifier of the emoji to delete.
  $id: String!
) {
  emojiDelete(id: $id) {
    ...ArchivePayload
  }
}
# [Deprecated] Creates a new event.
mutation eventCreate(
  # The event to create.
  $input: EventCreateInput!
) {
  eventCreate(input: $input) {
    ...EventPayload
  }
}
# Creates a new favorite (project, cycle etc).
mutation favoriteCreate(
  # The favorite object to create.
  $input: FavoriteCreateInput!
) {
  favoriteCreate(input: $input) {
    ...FavoritePayload
  }
}
# Deletes a favorite reference.
mutation favoriteDelete(
  # The identifier of the favorite reference to delete.
  $id: String!
) {
  favoriteDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a favorite.
mutation favoriteUpdate(
  # The identifier of the favorite to update.
  $id: String!
  # A partial favorite object to update the favorite with.
  $input: FavoriteUpdateInput!
) {
  favoriteUpdate(id: $id, input: $input) {
    ...FavoritePayload
  }
}
# Saves user feedback.
mutation feedbackCreate(
  # The feedback entry to create.
  $input: FeedbackCreateInput!
) {
  feedbackCreate(input: $input) {
    ...FeedbackPayload
  }
}
# XHR request payload to upload an images, video and other attachments directly to Linear's cloud
# storage.
mutation fileUpload(
  # MIME type of the uploaded file.
  $contentType: String!
  # Filename of the uploaded file.
  $filename: String!
  # Optional metadata.
  $metaData: JSON
  # File size of the uploaded file.
  $size: Int!
) {
  fileUpload(contentType: $contentType, filename: $filename, metaData: $metaData, size: $size) {
    ...UploadPayload
  }
}
# Authenticate user account through Google OAuth. This is the 2nd step of OAuth flow.
mutation googleUserAccountAuth(
  # The data used for Google authentication.
  $input: GoogleUserAccountAuthInput!
) {
  googleUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Upload an image from an URL to Linear.
mutation imageUploadFromUrl(
  # URL of the file to be uploaded to Linear.
  $url: String!
) {
  imageUploadFromUrl(url: $url) {
    ...ImageUploadFromUrlPayload
  }
}
# Deletes an integration.
mutation integrationDelete(
  # The identifier of the integration to delete.
  $id: String!
) {
  integrationDelete(id: $id) {
    ...ArchivePayload
  }
}
# Integrates the organization with Figma.
mutation integrationFigma(
  # The Figma OAuth code.
  $code: String!
  # The Figma OAuth redirect URI.
  $redirectUri: String!
) {
  integrationFigma(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Connects the organization with the GitHub App.
mutation integrationGithubConnect(
  # The GitHub data to connect with.
  $installationId: String!
) {
  integrationGithubConnect(installationId: $installationId) {
    ...IntegrationPayload
  }
}
# Connects the organization with a GitLab Access Token.
mutation integrationGitlabConnect(
  # The GitLab Access Token to connect with.
  $accessToken: String!
  # The URL of the GitLab installation
  $gitlabUrl: String!
) {
  integrationGitlabConnect(accessToken: $accessToken, gitlabUrl: $gitlabUrl) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Google Sheets.
mutation integrationGoogleSheets(
  # The Google OAuth code.
  $code: String!
) {
  integrationGoogleSheets(code: $code) {
    ...IntegrationPayload
  }
}
# Archives an integration resource.
mutation integrationResourceArchive(
  # The identifier of the integration resource to archive.
  $id: String!
) {
  integrationResourceArchive(id: $id) {
    ...ArchivePayload
  }
}
# Integrates the organization with Sentry.
mutation integrationSentryConnect(
  # The Sentry grant code that's exchanged for OAuth tokens.
  $code: String!
  # The Sentry installationId to connect with.
  $installationId: String!
  # The slug of the Sentry organization being connected.
  $organizationSlug: String!
) {
  integrationSentryConnect(code: $code, installationId: $installationId, organizationSlug: $organizationSlug) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Slack.
mutation integrationSlack(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # Whether or not v2 of Slack OAuth should be used
  $shouldUseV2Auth: Boolean
) {
  integrationSlack(code: $code, redirectUri: $redirectUri, shouldUseV2Auth: $shouldUseV2Auth) {
    ...IntegrationPayload
  }
}
# Imports custom emojis from your Slack workspace.
mutation integrationSlackImportEmojis(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackImportEmojis(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates your personal notifications with Slack.
mutation integrationSlackPersonal(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackPersonal(code: $code, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Slack webhook integration.
mutation integrationSlackPost(
  # The Slack OAuth code.
  $code: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
  # Whether or not v2 of Slack OAuth should be used
  $shouldUseV2Auth: Boolean
  # Integration's associated team.
  $teamId: String!
) {
  integrationSlackPost(code: $code, redirectUri: $redirectUri, shouldUseV2Auth: $shouldUseV2Auth, teamId: $teamId) {
    ...IntegrationPayload
  }
}
# Slack integration for project notifications.
mutation integrationSlackProjectPost(
  # The Slack OAuth code.
  $code: String!
  # Integration's associated project.
  $projectId: String!
  # The Slack OAuth redirect URI.
  $redirectUri: String!
) {
  integrationSlackProjectPost(code: $code, projectId: $projectId, redirectUri: $redirectUri) {
    ...IntegrationPayload
  }
}
# Integrates the organization with Zendesk.
mutation integrationZendesk(
  # The Zendesk OAuth code.
  $code: String!
  # The Zendesk OAuth redirect URI.
  $redirectUri: String!
  # The Zendesk OAuth scopes.
  $scope: String!
  # The Zendesk installation subdomain.
  $subdomain: String!
) {
  integrationZendesk(code: $code, redirectUri: $redirectUri, scope: $scope, subdomain: $subdomain) {
    ...IntegrationPayload
  }
}
# Archives an issue.
mutation issueArchive(
  # The identifier of the issue to archive.
  $id: String!
  # Whether to trash the issue
  $trash: Boolean
) {
  issueArchive(id: $id, trash: $trash) {
    ...ArchivePayload
  }
}
# Creates a new issue.
mutation issueCreate(
  # The issue object to create.
  $input: IssueCreateInput!
) {
  issueCreate(input: $input) {
    ...IssuePayload
  }
}
# Kicks off an Asana import job.
mutation issueImportCreateAsana(
  # Asana team name to choose which issues we should import.
  $asanaTeamName: String!
  # Asana token to fetch information from the Asana API.
  $asanaToken: String!
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the team into which to import data.
  $teamId: String!
) {
  issueImportCreateAsana(
    asanaTeamName: $asanaTeamName
    asanaToken: $asanaToken
    instantProcess: $instantProcess
    teamId: $teamId
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Clubhouse import job.
mutation issueImportCreateClubhouse(
  # Clubhouse team name to choose which issues we should import.
  $clubhouseTeamName: String!
  # Clubhouse token to fetch information from the Clubhouse API.
  $clubhouseToken: String!
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the team into which to import data.
  $teamId: String!
) {
  issueImportCreateClubhouse(
    clubhouseTeamName: $clubhouseTeamName
    clubhouseToken: $clubhouseToken
    instantProcess: $instantProcess
    teamId: $teamId
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a GitHub import job.
mutation issueImportCreateGithub(
  # Github repository name from which we will import data.
  $githubRepoName: String!
  # Github owner (user or org) for the repository from which we will import data.
  $githubRepoOwner: String!
  # Whether or not we should import GitHub organization level projects.
  $githubShouldImportOrgProjects: Boolean
  # Github token to fetch information from the Github API.
  $githubToken: String!
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # ID of the team into which to import data.
  $teamId: String!
) {
  issueImportCreateGithub(
    githubRepoName: $githubRepoName
    githubRepoOwner: $githubRepoOwner
    githubShouldImportOrgProjects: $githubShouldImportOrgProjects
    githubToken: $githubToken
    instantProcess: $instantProcess
    teamId: $teamId
  ) {
    ...IssueImportPayload
  }
}
# Kicks off a Jira import job.
mutation issueImportCreateJira(
  # Whether to instantly process the import with the default configuration mapping.
  $instantProcess: Boolean
  # Jira user account email.
  $jiraEmail: String!
  # Jira installation or cloud hostname.
  $jiraHostname: String!
  # Jira project key from which we will import data.
  $jiraProject: String!
  # Jira personal access token to access Jira REST API.
  $jiraToken: String!
  # ID of the team into which to import data.
  $teamId: String!
) {
  issueImportCreateJira(
    instantProcess: $instantProcess
    jiraEmail: $jiraEmail
    jiraHostname: $jiraHostname
    jiraProject: $jiraProject
    jiraToken: $jiraToken
    teamId: $teamId
  ) {
    ...IssueImportPayload
  }
}
# Deletes an import job.
mutation issueImportDelete(
  # ID of the issue import to delete.
  $issueImportId: String!
) {
  issueImportDelete(issueImportId: $issueImportId) {
    ...IssueImportDeletePayload
  }
}
# Kicks off import processing.
mutation issueImportProcess(
  # ID of the issue import which we're going to process.
  $issueImportId: String!
  # The mapping configuration to use for processing the import.
  $mapping: JSONObject!
) {
  issueImportProcess(issueImportId: $issueImportId, mapping: $mapping) {
    ...IssueImportPayload
  }
}
# Archives an issue label.
mutation issueLabelArchive(
  # The identifier of the label to archive.
  $id: String!
) {
  issueLabelArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new label.
mutation issueLabelCreate(
  # The issue label to create.
  $input: IssueLabelCreateInput!
) {
  issueLabelCreate(input: $input) {
    ...IssueLabelPayload
  }
}
# Updates an label.
mutation issueLabelUpdate(
  # The identifier of the label to update.
  $id: String!
  # A partial label object to update.
  $input: IssueLabelUpdateInput!
) {
  issueLabelUpdate(id: $id, input: $input) {
    ...IssueLabelPayload
  }
}
# Creates a new issue relation.
mutation issueRelationCreate(
  # The issue relation to create.
  $input: IssueRelationCreateInput!
) {
  issueRelationCreate(input: $input) {
    ...IssueRelationPayload
  }
}
# Deletes an issue relation.
mutation issueRelationDelete(
  # The identifier of the issue relation to delete.
  $id: String!
) {
  issueRelationDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an issue relation.
mutation issueRelationUpdate(
  # The identifier of the issue relation to update.
  $id: String!
  # The properties of the issue relation to update.
  $input: IssueRelationUpdateInput!
) {
  issueRelationUpdate(id: $id, input: $input) {
    ...IssueRelationPayload
  }
}
# Unarchives an issue.
mutation issueUnarchive(
  # The identifier of the issue to archive.
  $id: String!
) {
  issueUnarchive(id: $id) {
    ...ArchivePayload
  }
}
# Updates an issue.
mutation issueUpdate(
  # The identifier of the issue to update.
  $id: String!
  # A partial issue object to update the issue with.
  $input: IssueUpdateInput!
) {
  issueUpdate(id: $id, input: $input) {
    ...IssuePayload
  }
}
# Join an organization from onboarding.
mutation joinOrganizationFromOnboarding(
  # Organization details for the organization to join.
  $input: JoinOrganizationInput!
) {
  joinOrganizationFromOnboarding(input: $input) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Leave an organization.
mutation leaveOrganization(
  # ID of the organization to leave.
  $organizationId: String!
) {
  leaveOrganization(organizationId: $organizationId) {
    ...CreateOrJoinOrganizationResponse
  }
}
# Creates a new milestone.
mutation milestoneCreate(
  # The issue object to create.
  $input: MilestoneCreateInput!
) {
  milestoneCreate(input: $input) {
    ...MilestonePayload
  }
}
# Deletes a milestone.
mutation milestoneDelete(
  # The identifier of the milestone to delete. Only milestones without projects can be deleted.
  $id: String!
) {
  milestoneDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a milestone.
mutation milestoneUpdate(
  # The identifier of the milestone to update.
  $id: String!
  # A partial milestone object to update the milestone with.
  $input: MilestoneUpdateInput!
) {
  milestoneUpdate(id: $id, input: $input) {
    ...MilestonePayload
  }
}
# Archives a notification.
mutation notificationArchive(
  # The id of the notification to archive.
  $id: String!
) {
  notificationArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a notification.
mutation notificationCreate(
  # The identifier of the notification to update.
  $id: String!
  # A partial notification object to update the issue with.
  $input: NotificationUpdateInput!
) {
  notificationCreate(id: $id, input: $input) {
    ...NotificationPayload
  }
}
# Creates a new notification subscription for a team or a project.
mutation notificationSubscriptionCreate(
  # The subscription object to create.
  $input: NotificationSubscriptionCreateInput!
) {
  notificationSubscriptionCreate(input: $input) {
    ...NotificationSubscriptionPayload
  }
}
# Deletes a notification subscription reference.
mutation notificationSubscriptionDelete(
  # The identifier of the notification subscription reference to delete.
  $id: String!
) {
  notificationSubscriptionDelete(id: $id) {
    ...ArchivePayload
  }
}
# Unarchives a notification.
mutation notificationUnarchive(
  # The id of the notification to archive.
  $id: String!
) {
  notificationUnarchive(id: $id) {
    ...ArchivePayload
  }
}
# Updates a notification.
mutation notificationUpdate(
  # The identifier of the notification to update.
  $id: String!
  # A partial notification object to update the issue with.
  $input: NotificationUpdateInput!
) {
  notificationUpdate(id: $id, input: $input) {
    ...NotificationPayload
  }
}
# Archives an OAuth client.
mutation oauthClientArchive(
  # The identifier of the OAuth client to archive.
  $id: String!
) {
  oauthClientArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new OAuth client.
mutation oauthClientCreate(
  # The OAuth client application object to create.
  $input: OauthClientCreateInput!
) {
  oauthClientCreate(input: $input) {
    ...OauthClientPayload
  }
}
# Updates an OAuth client.
mutation oauthClientRotateSecret(
  # The identifier of the OAuth client for which we want to rotate the secret.
  $id: String!
) {
  oauthClientRotateSecret(id: $id) {
    ...RotateSecretPayload
  }
}
# Updates an OAuth client.
mutation oauthClientUpdate(
  # The identifier of the OAuth client to update.
  $id: String!
  # A partial client object to update the OAuth client with.
  $input: OauthClientUpdateInput!
) {
  oauthClientUpdate(id: $id, input: $input) {
    ...OauthClientPayload
  }
}
# Revokes an OAuth token.
mutation oauthTokenRevoke(
  # The identifier of the OAuth client for the tokens to be revoked.
  $appId: String!
  # The group of scopes for the tokens to be revoked.
  $scope: [String!]!
) {
  oauthTokenRevoke(appId: $appId, scope: $scope) {
    ...OauthTokenRevokePayload
  }
}
# Delete's an organization. Administrator privileges required.
mutation organizationDelete(
  # Information required to delete an organization.
  $input: DeleteOrganizationInput!
) {
  organizationDelete(input: $input) {
    ...OrganizationDeletePayload
  }
}
# Get an organization's delete confirmation token. Administrator privileges required.
mutation organizationDeleteChallenge {
  organizationDeleteChallenge {
    ...OrganizationDeletePayload
  }
}
# Adds a domain to be allowed for an organization.
mutation organizationDomainCreate(
  # The organization domain entry to create.
  $input: OrganizationDomainCreateInput!
) {
  organizationDomainCreate(input: $input) {
    ...OrganizationDomainPayload
  }
}
# Deletes a domain.
mutation organizationDomainDelete(
  # The identifier of the domain to delete.
  $id: String!
) {
  organizationDomainDelete(id: $id) {
    ...ArchivePayload
  }
}
# Verifies a domain to be added to an organization.
mutation organizationDomainVerify(
  # The organization domain to verify.
  $input: OrganizationDomainVerificationInput!
) {
  organizationDomainVerify(input: $input) {
    ...OrganizationDomainPayload
  }
}
# Creates a new organization invite.
mutation organizationInviteCreate(
  # The organization invite object to create.
  $input: OrganizationInviteCreateInput!
) {
  organizationInviteCreate(input: $input) {
    ...OrganizationInvitePayload
  }
}
# Deletes an organization invite.
mutation organizationInviteDelete(
  # The identifier of the organization invite to delete.
  $id: String!
) {
  organizationInviteDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates the user's organization.
mutation organizationUpdate(
  # A partial organization object to update the organization with.
  $input: UpdateOrganizationInput!
) {
  organizationUpdate(input: $input) {
    ...OrganizationPayload
  }
}
# Archives a project.
mutation projectArchive(
  # The identifier of the project to archive. Also the identifier from the URL is accepted.
  $id: String!
) {
  projectArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new project.
mutation projectCreate(
  # The issue object to create.
  $input: ProjectCreateInput!
) {
  projectCreate(input: $input) {
    ...ProjectPayload
  }
}
# Creates a new project link.
mutation projectLinkCreate(
  # The project link object to create.
  $input: ProjectLinkCreateInput!
) {
  projectLinkCreate(input: $input) {
    ...ProjectLinkPayload
  }
}
# Deletes a project link.
mutation projectLinkDelete(
  # The identifier of the project link to delete.
  $id: String!
) {
  projectLinkDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a project.
mutation projectUpdate(
  # The identifier of the project to update. Also the identifier from the URL is accepted.
  $id: String!
  # A partial project object to update the project with.
  $input: ProjectUpdateInput!
) {
  projectUpdate(id: $id, input: $input) {
    ...ProjectPayload
  }
}
# Creates a push subscription.
mutation pushSubscriptionCreate(
  # The push subscription to create.
  $input: PushSubscriptionCreateInput!
) {
  pushSubscriptionCreate(input: $input) {
    ...PushSubscriptionPayload
  }
}
# Deletes a push subscription.
mutation pushSubscriptionDelete(
  # The identifier of the push subscription to delete.
  $id: String!
) {
  pushSubscriptionDelete(id: $id) {
    ...PushSubscriptionPayload
  }
}
# Creates a new reaction.
mutation reactionCreate(
  # The reaction object to create.
  $input: ReactionCreateInput!
) {
  reactionCreate(input: $input) {
    ...ReactionPayload
  }
}
# Deletes a reaction.
mutation reactionDelete(
  # The identifier of the reaction to delete.
  $id: String!
) {
  reactionDelete(id: $id) {
    ...ArchivePayload
  }
}
# Manually update Google Sheets data.
mutation refreshGoogleSheetsData(
  # The identifier of the Google Sheets integration to update.
  $id: String!
) {
  refreshGoogleSheetsData(id: $id) {
    ...IntegrationPayload
  }
}
# Re-send an organization invite.
mutation resentOrganizationInvite(
  # The identifier of the organization invite to be re-send.
  $id: String!
) {
  resentOrganizationInvite(id: $id) {
    ...ArchivePayload
  }
}
# Authenticates a user account via email and authentication token for SAML.
mutation samlTokenUserAccountAuth(
  # The data used for token authentication.
  $input: TokenUserAccountAuthInput!
) {
  samlTokenUserAccountAuth(input: $input) {
    ...AuthResolverResponse
  }
}
# Archives a subscription.
mutation subscriptionArchive(
  # The identifier of the subscription to archive.
  $id: String!
) {
  subscriptionArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a subscription session. Used internally to integrate with Stripe.
mutation subscriptionSessionCreate(
  # The name of the plan.
  $plan: String!
) {
  subscriptionSessionCreate(plan: $plan) {
    ...SubscriptionSessionPayload
  }
}
# Updates a subscription.
mutation subscriptionUpdate(
  # The identifier of the subscription.
  $id: String!
  # The properties of the subscription.
  $input: SubscriptionUpdateInput!
) {
  subscriptionUpdate(id: $id, input: $input) {
    ...SubscriptionPayload
  }
}
# Creates a subscription update session. Used internally to integrate with Stripe.
mutation subscriptionUpdateSessionCreate {
  subscriptionUpdateSessionCreate {
    ...SubscriptionSessionPayload
  }
}
# Upgrades a subscription plan.
mutation subscriptionUpgrade(
  # The identifier of the subscription.
  $id: String!
  # The subscription type to upgrade to.
  $type: String!
) {
  subscriptionUpgrade(id: $id, type: $type) {
    ...SubscriptionPayload
  }
}
# Archives a team.
mutation teamArchive(
  # The identifier of the team to archive.
  $id: String!
) {
  teamArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new team. The user who creates the team will automatically be added as a member to the
# newly created team.
mutation teamCreate(
  # The team id to copy settings from.
  $copySettingsFromTeamId: String
  # The team object to create.
  $input: TeamCreateInput!
) {
  teamCreate(copySettingsFromTeamId: $copySettingsFromTeamId, input: $input) {
    ...TeamPayload
  }
}
# Deletes a team.
mutation teamDelete(
  # The identifier of the team to delete.
  $id: String!
) {
  teamDelete(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new team membership.
mutation teamMembershipCreate(
  # The team membership object to create.
  $input: TeamMembershipCreateInput!
) {
  teamMembershipCreate(input: $input) {
    ...TeamMembershipPayload
  }
}
# Deletes a team membership.
mutation teamMembershipDelete(
  # The identifier of the team membership to delete.
  $id: String!
) {
  teamMembershipDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates a team membership.
mutation teamMembershipUpdate(
  # The identifier of the team membership to update.
  $id: String!
  # A partial team membership object to update the team membership with.
  $input: TeamMembershipUpdateInput!
) {
  teamMembershipUpdate(id: $id, input: $input) {
    ...TeamMembershipPayload
  }
}
# Updates a team.
mutation teamUpdate(
  # The identifier of the team to update.
  $id: String!
  # A partial team object to update the team with.
  $input: TeamUpdateInput!
) {
  teamUpdate(id: $id, input: $input) {
    ...TeamPayload
  }
}
# Creates a new template.
mutation templateCreate(
  # The template object to create.
  $input: TemplateCreateInput!
) {
  templateCreate(input: $input) {
    ...TemplatePayload
  }
}
# Deletes a template.
mutation templateDelete(
  # The identifier of the template to delete.
  $id: String!
) {
  templateDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an existing template.
mutation templateUpdate(
  # The identifier of the template.
  $id: String!
  # The properties of the template to update.
  $input: TemplateUpdateInput!
) {
  templateUpdate(id: $id, input: $input) {
    ...TemplatePayload
  }
}
# Makes user a regular user. Can only be called by an admin.
mutation userDemoteAdmin(
  # The identifier of the user to make a regular user.
  $id: String!
) {
  userDemoteAdmin(id: $id) {
    ...UserAdminPayload
  }
}
# Updates a user's settings flag.
mutation userFlagUpdate(
  # Settings flag to increment.
  $flag: UserFlagType!
  # Flag operation to perform
  $operation: UserFlagUpdateOperation!
) {
  userFlagUpdate(flag: $flag, operation: $operation) {
    ...UserSettingsFlagPayload
  }
}
# Makes user an admin. Can only be called by an admin.
mutation userPromoteAdmin(
  # The identifier of the user to make an admin.
  $id: String!
) {
  userPromoteAdmin(id: $id) {
    ...UserAdminPayload
  }
}
# [Deprecated] Updates a user's settings flag.
mutation userSettingsFlagIncrement(
  # Flag to increment.
  $flag: String!
) {
  userSettingsFlagIncrement(flag: $flag) {
    ...UserSettingsFlagPayload
  }
}
# Resets user's setting flags.
mutation userSettingsFlagsReset {
  userSettingsFlagsReset {
    ...UserSettingsFlagsResetPayload
  }
}
# Updates the user's settings.
mutation userSettingsUpdate(
  # The identifier of the userSettings to update.
  $id: String!
  # A partial notification object to update the settings with.
  $input: UserSettingsUpdateInput!
) {
  userSettingsUpdate(id: $id, input: $input) {
    ...UserSettingsPayload
  }
}
# Subscribes user to changelog newsletter.
mutation userSubscribeToNewsletter {
  userSubscribeToNewsletter {
    ...UserSubscribeToNewsletterPayload
  }
}
# Suspends a user. Can only be called by an admin.
mutation userSuspend(
  # The identifier of the user to suspend.
  $id: String!
) {
  userSuspend(id: $id) {
    ...UserAdminPayload
  }
}
# Un-suspends a user. Can only be called by an admin.
mutation userUnsuspend(
  # The identifier of the user to unsuspend.
  $id: String!
) {
  userUnsuspend(id: $id) {
    ...UserAdminPayload
  }
}
# Updates a user. Only available to organization admins and the user themselves.
mutation userUpdate(
  # The identifier of the user to update. Use `me` to reference currently authenticated user.
  $id: String!
  # A partial user object to update the user with.
  $input: UpdateUserInput!
) {
  userUpdate(id: $id, input: $input) {
    ...UserPayload
  }
}
# Creates a new ViewPreferences object.
mutation viewPreferencesCreate(
  # The ViewPreferences object to create.
  $input: ViewPreferencesCreateInput!
) {
  viewPreferencesCreate(input: $input) {
    ...ViewPreferencesPayload
  }
}
# Deletes a ViewPreferences.
mutation viewPreferencesDelete(
  # The identifier of the ViewPreferences to delete.
  $id: String!
) {
  viewPreferencesDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an existing ViewPreferences object.
mutation viewPreferencesUpdate(
  # The identifier of the ViewPreferences object.
  $id: String!
  # The properties of the view preferences.
  $input: ViewPreferencesUpdateInput!
) {
  viewPreferencesUpdate(id: $id, input: $input) {
    ...ViewPreferencesPayload
  }
}
# Creates a new webhook.
mutation webhookCreate(
  # The webhook object to create.
  $input: WebhookCreateInput!
) {
  webhookCreate(input: $input) {
    ...WebhookPayload
  }
}
# Deletes a Webhook.
mutation webhookDelete(
  # The identifier of the Webhook to delete.
  $id: String!
) {
  webhookDelete(id: $id) {
    ...ArchivePayload
  }
}
# Updates an existing Webhook.
mutation webhookUpdate(
  # The identifier of the Webhook.
  $id: String!
  # The properties of the Webhook.
  $input: WebhookUpdateInput!
) {
  webhookUpdate(id: $id, input: $input) {
    ...WebhookPayload
  }
}
# Archives a state. Only states with issues that have all been archived can be archived.
mutation workflowStateArchive(
  # The identifier of the state to archive.
  $id: String!
) {
  workflowStateArchive(id: $id) {
    ...ArchivePayload
  }
}
# Creates a new state, adding it to the workflow of a team.
mutation workflowStateCreate(
  # The state to create.
  $input: WorkflowStateCreateInput!
) {
  workflowStateCreate(input: $input) {
    ...WorkflowStatePayload
  }
}
# Updates a state.
mutation workflowStateUpdate(
  # The identifier of the state to update.
  $id: String!
  # A partial state object to update.
  $input: WorkflowStateUpdateInput!
) {
  workflowStateUpdate(id: $id, input: $input) {
    ...WorkflowStatePayload
  }
}
